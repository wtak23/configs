

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>tak.ml.nmf</title>
  

  
  
    <link rel="shortcut icon" href="../../../_static/terminal.ico"/>
  

  

  
  
    

  

  
  
    <link rel="stylesheet" href="../../../_static/css/my_theme.css" type="text/css" />
  

  

  
    <link rel="top" title="" href="../../../index.html"/>
        <link rel="up" title="Module code" href="../../index.html"/> 

  
  <script src="../../../_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="../../../index.html" class="icon icon-home"> My Configs
          

          
          </a>

          
            
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
                <p class="caption"><span class="caption-text">Table of Contents</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../python.html">Python (<code class="docutils literal"><span class="pre">python.rst</span></code>)</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../../python/py-sbia.html">1 sbia workstation (<code class="docutils literal"><span class="pre">py-sbia.rst</span></code>)</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../python/py-sbia.html#symlink-summary">1.1 symlink summary</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../python/py-sbia.html#ipython-setup">1.2 ipython setup</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../python/py-sbia.html#content-of-ipython-kernel-config">1.2.1 Content of <code class="docutils literal"><span class="pre">ipython_kernel_config</span></code></a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../python/py-sbia.html#matplotlibrc">1.3 matplotlibrc</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../python/py-sbia.html#content-of-matplotlibrc">1.3.1 Content of <code class="docutils literal"><span class="pre">matplotlibrc</span></code></a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../python/py-sbia.html#new-symlink-to-sitecustomize-py">1.4 New - symlink to sitecustomize.py</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../python/py-sbia.html#current-content-of-sitecustomize-py">1.4.1 Current content of <code class="docutils literal"><span class="pre">sitecustomize.py</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../python/py-sbia.html#what-does-sitecustomize-py-do">1.4.2 what does sitecustomize.py do?</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../python/py-sbia.html#current-content-of-sitecustomize-spyder-py">1.4.3 Current content of <code class="docutils literal"><span class="pre">sitecustomize_spyder.py</span></code></a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../python/py-sbia.html#changes-with-original">1.5 Changes with _original</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../../python/py-win.html">2 Windows machine (<code class="docutils literal"><span class="pre">py-win.rst</span></code>)</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../python/py-win.html#pip-installs">2.1 pip installs</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../python/py-win.html#rollback-sphinx-to-version-1-3-5">2.2 Rollback Sphinx to Version 1.3.5</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../../python/old/py-old.html">3 old-notes (<code class="docutils literal"><span class="pre">py-old.rst</span></code>)</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../python/old/py-old.html#feb-24-2016">3.1 Feb 24, 2016</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../python/old/py-old.html#stuffs-installed-after-03-30-2016">3.2 Stuffs installed after 03-30-2016</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../python/old/py-old.html#bleeding-edge-version-of-lasagne-04-11-2016">3.2.1 Bleeding edge version of lasagne (04/11/2016)</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../python/old/py-old.html#reupdate-theano-to-0-8-04-1-2016">3.2.2 Reupdate theano to 0.8 (04/1/2016)</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../python/old/py-old.html#stuffs-installed-11-30-2015">3.3 Stuffs installed (11/30/2015)</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../python/old/py-old.html#moduel-install-very-old-modules-install">3.4 moduel-install: VERY old modules install</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../python/old/py-old.html#module-installs-install-modules-sh">3.4.1 <code class="docutils literal"><span class="pre">./module-installs/install_modules.sh</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../python/old/py-old.html#module-installs-pyinstall-sh">3.4.2 <code class="docutils literal"><span class="pre">./module-installs/pyinstall.sh</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../python/old/py-old.html#module-installs-spams-install-sh">3.4.3 <code class="docutils literal"><span class="pre">./module-installs/spams_install.sh</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../python/old/py-old.html#module-installs-tak-install-sh">3.4.4 <code class="docutils literal"><span class="pre">./module-installs/tak_install.sh</span></code></a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../../bash_config.html">Bash config files (<code class="docutils literal"><span class="pre">bash_config.rst</span></code>)</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../../bash_config/bash-sbia.html">1 SBIA Workstation (<code class="docutils literal"><span class="pre">bash-sbia.rst</span></code>)</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../bash_config/bash-sbia.html#symlinks">1.1 Symlinks</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../bash_config/bash-sbia.html#bashrc-contents">1.2 bashrc contents</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../bash_config/bash-sbia.html#gitconfig-content">1.3 gitconfig content</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../../bash_config/bash-cygwin.html">2 Cygwin setup (<code class="docutils literal"><span class="pre">bash-cygwin.rst</span></code>)</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../bash_config/bash-cygwin.html#symlink-setup">2.1 symlink setup</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../bash_config/bash-cygwin.html#bashrc-content">2.2 bashrc content</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../bash_config/bash-cygwin.html#bash-aliases-content">2.3 bash_aliases content</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../bash_config/bash-cygwin.html#apt-cyg">2.4 apt-cyg</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../bash_config/bash-cygwin.html#things-i-install-on-most-of-my-computers">2.4.1 Things I install on most of my computers</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../bash_config/bash-cygwin.html#git-related-stuffs">2.5 git related stuffs</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../bash_config/bash-cygwin.html#github-sshkey">2.5.1 github sshkey</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../bash_config/bash-cygwin.html#git-code-completion">2.5.2 git code completion</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../bash_config/bash-cygwin.html#random-overflows">2.6 Random overflows</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../bash_config/bash-cygwin.html#to-get-git-gui-working">2.6.1 to get git gui working...</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../bash_config/bash-cygwin.html#xming-setup">2.6.2 xming setup</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../bash_config/bash-cygwin.html#disable-annoying-bell-sound-in-cygwin">2.6.3 disable annoying bell sound in cygwin</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../../bash_config/bash-defaults.html">3 Default bash config files (<code class="docutils literal"><span class="pre">bash-defaults.rst</span></code>)</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../bash_config/bash-defaults.html#default-bashrc-ubuntu">3.1 Default .bashrc, ubuntu</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../bash_config/bash-defaults.html#default-bashrc-cygwin">3.2 Default .bashrc, cygwin</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../../sublime.html">Sublime Text Setup (<code class="docutils literal"><span class="pre">sublime.rst</span></code>)</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../../sublime/subl-gen.html">1 Sublime &#8211; General Notes (<code class="docutils literal"><span class="pre">subl-gen</span></code>)</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../sublime/subl-gen.html#packages-installed">1.1 Packages Installed</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../../sublime/subl-sbia.html">2 SBIA Workstation (<code class="docutils literal"><span class="pre">subl-sbia.rst</span></code>)</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../sublime/subl-sbia.html#file-tree">2.1 File-tree</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../sublime/subl-sbia.html#symbolic-links-created">2.2 Symbolic links created</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../sublime/subl-sbia.html#file-wise-setup">2.2.1 File-wise setup</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../sublime/subl-sbia.html#installed-packges">2.3 Installed packges</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../sublime/subl-sbia.html#preferences-sublime-settings-content">2.4 Preferences.sublime-settings Content</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../sublime/subl-sbia.html#default-linux-sublime-keymap-content">2.5 Default (Linux).sublime-keymap Content</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../../sublime/subl-win.html">3 Windows setup (<code class="docutils literal"><span class="pre">subl-win.rst</span></code>)</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../sublime/subl-win.html#symlinks">3.1 Symlinks</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../sublime/subl-win.html#installed-packages">3.2 Installed Packages</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../sublime/subl-win.html#xps8900">3.2.1 xps8900</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../sublime/subl-win.html#asus">3.2.2 asus</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../sublime/subl-win.html#asus-diff-with-sbia-workstation">3.2.3 asus diff with sbia workstation</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../sublime/subl-win.html#bunch-of-random-helpful-config-stuffs">3.3 Bunch of random helpful config stuffs</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../sublime/subl-win.html#open-cygwin-shell-via-right-click-in-explorer">3.3.1 Open cygwin shell via right-click in explorer</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../sublime/subl-win.html#getting-buildsystem-to-work-with-cygwin">3.3.2 Getting buildsystem to work with cygwin</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../../sublime/subl-ref.html">4 References (<code class="docutils literal"><span class="pre">subl-ref.rst</span></code>)</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../sublime/subl-ref.html#scope-info-for-snippets-and-build-system">4.1 Scope info (for snippets and build system)</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../sublime/subl-ref.html#build-system-info">4.2 Build system info</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../sublime/subl-ref.html#when-sublime-keeps-crashing-at-startup">4.3 When sublime keeps crashing at startup...</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../../sublime/subl-defaults.html">5 Default-settings (<code class="docutils literal"><span class="pre">subl-defaults.rst</span></code>)</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../sublime/subl-defaults.html#preferences-sublime-settings-linux">5.1 Preferences.sublime-settings (Linux)</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../../R.html">R (<code class="docutils literal"><span class="pre">R.rst</span></code>)</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../../R.html#configuring-r-startup">Configuring R startup</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../R.html#linux-sylminks">Linux - sylminks</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../R.html#windows-symlinks">Windows - symlinks</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../R.html#config-file-contents">Config file contents</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../R.html#r-snippets">r.snippets</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../R.html#hotkeys">hotkeys</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../../windows.html">Windows machine setup (<code class="docutils literal"><span class="pre">windows.rst</span></code>)</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../../windows/autohotkey/win-ahk.html">1 Autohotkey (<code class="docutils literal"><span class="pre">win-ahk.rst</span></code>)</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../windows/autohotkey/win-ahk.html#main-references">1.1 Main references</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../windows/autohotkey/win-ahk.html#notes">1.2 Notes</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../windows/autohotkey/win-ahk.html#details-on-sentinput">1.2.1 Details on <strong>SentInput</strong></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../windows/autohotkey/win-ahk.html#variables-in-ahk">1.2.2 Variables in AHK</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../windows/autohotkey/win-ahk.html#looping-in-ahk">1.2.3 Looping in AHK</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../windows/autohotkey/win-ahk.html#other-useful-references">1.2.4 other useful references</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../../windows/office-setup/win-office.html">2 MS Office Setups (<code class="docutils literal"><span class="pre">win-office.rst</span></code>)</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../windows/office-setup/win-office.html#word-macro">2.1 Word macro</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../windows/office-setup/win-office.html#one-note">2.2 One-note</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../../windows/win-xps8900.html">3 XPS8900 Desktop settings (<code class="docutils literal"><span class="pre">win-xps8900.rst</span></code>)</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../windows/win-xps8900.html#startup-files">3.1 Startup Files</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../windows/win-xps8900.html#symlinks">3.2 symlinks</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../windows/win-xps8900.html#cygwin-configs">3.2.1 cygwin configs</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../windows/win-xps8900.html#sublime-text">3.2.2 Sublime text</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../windows/win-xps8900.html#office">3.2.3 Office</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../../windows/win-asus.html">4 ASUS laptop settings (<code class="docutils literal"><span class="pre">win-asus.rst</span></code>)</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../windows/win-asus.html#startup-files">4.1 Startup Files</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../windows/win-asus.html#symlinks">4.2 symlinks</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../windows/win-asus.html#cygwin-configs">4.2.1 cygwin configs</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../windows/win-asus.html#sublime-text">4.2.2 Sublime text</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../windows/win-asus.html#office">4.2.3 Office</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../../windows/win-old-notes.html">5 (Old) Thing to do on a new computer (<code class="docutils literal"><span class="pre">win-old-notes.rst</span></code>)</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../windows/win-old-notes.html#softwares-to-install">5.1 Softwares to install</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../windows/win-old-notes.html#the-essentials">5.1.1 The &#8220;Essentials&#8221;</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../windows/win-old-notes.html#computational">5.1.2 Computational</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../windows/win-old-notes.html#non-essentials">5.1.3 Non-essentials</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../windows/win-old-notes.html#short-cuts-to-add-in-startup-folder">5.2 Short-cuts to add in &#8220;Startup&#8221; folder</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../windows/win-old-notes.html#xming">5.2.1 xming</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../windows/win-old-notes.html#misc">5.3 misc</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../windows/win-old-notes.html#username-change">5.3.1 Username change</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../windows/win-old-notes.html#location-of-normal-dotm">5.3.2 Location of <code class="docutils literal"><span class="pre">Normal.dotm</span></code></a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../../trouble-shooting.html">Trouble-shooting notes (<code class="docutils literal"><span class="pre">trouble-shooting.rst</span></code>)</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../../trouble-shooting/ts-bash.html">1 ts-bash (<code class="docutils literal"><span class="pre">ts-bash.rst</span></code>)</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../trouble-shooting/ts-bash.html#getting-mysql-to-work-on-cygwin">1.1 Getting mysql to work on cygwin</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../trouble-shooting/ts-bash.html#conf-file">1.1.1 conf file</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../trouble-shooting/ts-bash.html#pip-install-mysql-doesn-t-work">1.1.2 pip install mysql doesn&#8217;t work</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../trouble-shooting/ts-bash.html#cygwin-apt-cyg-didn-t-work-well">1.1.3 cygwin apt-cyg didn&#8217;t work well...</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../trouble-shooting/ts-bash.html#apt-cyg-install-md5sum-error">1.1.4 apt-cyg install md5sum error</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../trouble-shooting/ts-bash.html#old-notes-from-old-config-master-repos">1.2 Old-notes from old config_master repos</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../trouble-shooting/ts-bash.html#color-in-less">1.2.1 Color in less</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../trouble-shooting/ts-bash.html#latex-installer-06-15-2016-21-48">1.2.2 Latex installer 06-15-2016 (21:48)</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../../trouble-shooting/ts-sublime.html">2 ts-sublime (<code class="docutils literal"><span class="pre">ts-sublime.rst</span></code>)</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../trouble-shooting/ts-sublime.html#latexing-complaining-cannot-find-pdflatex-command">2.1 Latexing complaining cannot find pdflatex command</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../trouble-shooting/ts-sublime.html#old-notes-from-old-config-master-repos">2.2 Old-notes from old config_master repos</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../trouble-shooting/ts-sublime.html#how-to-remove-startup-session">2.2.1 How to remove startup session</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../trouble-shooting/ts-sublime.html#omni-markup-error">2.2.2 omni-markup error</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../trouble-shooting/ts-sublime.html#get-images-from-goto">2.2.3 get images from goto</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../../trouble-shooting/ts-python.html">3 ts-python (<code class="docutils literal"><span class="pre">ts-python.rst</span></code>)</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../trouble-shooting/ts-python.html#getting-theano-to-work-on-windows">3.1 Getting theano to work on Windows</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../trouble-shooting/ts-python.html#no-clue-why-but-jupyter-kernel-keeps-dying">3.2 No clue why, but jupyter kernel keeps dying...</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../trouble-shooting/ts-python.html#pip-install-mysql-doesn-t-work">3.3 pip install mysql doesn&#8217;t work</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../trouble-shooting/ts-python.html#cygwin">3.3.1 cygwin</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../trouble-shooting/ts-python.html#linux-ubutu-14-04">3.3.2 Linux (ubutu 14.04)</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../trouble-shooting/ts-python.html#pip-install-psycopg2-for-postgreql">3.4 pip install psycopg2 for postgreql</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../../trouble-shooting/ts-R.html">4 ts-R (<code class="docutils literal"><span class="pre">ts-R.rst</span></code>)</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../trouble-shooting/ts-R.html#ggplot2-load-error-on-windows">4.1 ggplot2 load error on windows</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../../misc.html">Miscellaneous (<code class="docutils literal"><span class="pre">misc.rst</span></code>)</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../../misc/misc-symlinks.html">1 Misc symlinks (<code class="docutils literal"><span class="pre">misc-symlinks.rst</span></code>)</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../misc/misc-symlinks.html#sql-related">1.1 SQL related</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../misc/misc-symlinks.html#mysql-setup-windows">1.1.1 MySql setup (windows)</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../misc/misc-symlinks.html#sqlite-setup">1.1.2 sqlite setup</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../../misc/misc-cuda-old.html">2 cuda-installation (old) (<code class="docutils literal"><span class="pre">misc-cuda-old.rst</span></code>)</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../misc/misc-cuda-old.html#installing-theano">2.1 Installing Theano</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../misc/misc-cuda-old.html#installing-cuda">2.2 Installing cuda</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../misc/misc-cuda-old.html#references">2.2.1 references</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../misc/misc-cuda-old.html#pre-september">2.3 Pre september</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../misc/misc-cuda-old.html#cuda-install-output">2.4 cuda install output</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../../misc/misc-sbia-setups.html">3 Misc symlinks (<code class="docutils literal"><span class="pre">misc-symlinks.rst</span></code>)</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../misc/misc-sbia-setups.html#sql-related">3.1 SQL related</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../../test_autodoc.html"><code class="docutils literal"><span class="pre">test_autodoc.rst</span></code></a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../../test_autodoc.html#visualization">Visualization</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../test_autodoc.html#imconnmat">imconnmat</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../../test_autodoc.html#non-negative-matrix-factorization">Non-negative Matrix Factorization</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../test_autodoc.html#nmf-ls-pnmf-admm">nmf.ls_pnmf_admm</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../test_autodoc.html#nmf-ls-sgpnmf-admm">nmf.LS_SGPNMF_ADMM</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../../test_autodoc.html#data-io">Data IO</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../test_autodoc.html#data-tob-pnc-load-bct-measures">data.tob_pnc.load_bct_measures</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../test_autodoc.html#data-tob-pnc-load-diffusion-volume-matfile">data.tob_pnc.load_diffusion_volume_matfile</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../test_autodoc.html#data-tob-pnc-load-connectome-matfile">data.tob_pnc.load_connectome_matfile</a></li>
</ul>
</li>
</ul>
</li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
        <a href="../../../index.html">My Configs</a>
      </nav>


      
      <div class="wy-nav-content">
        <div class="rst-content">
          





<div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="../../../index.html">Docs</a> &raquo;</li>
      
          <li><a href="../../index.html">Module code</a> &raquo;</li>
      
    <li>tak.ml.nmf</li>
      <li class="wy-breadcrumbs-aside">
        
          
        
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <h1>Source code for tak.ml.nmf</h1><div class="highlight"><pre>
<span></span><span class="c1"># -*- coding: utf-8 -*-</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">===============================================================================</span>
<span class="sd">Code forked from ~/python/analysis/nmf/nmf_module.py (05/09/2016)</span>

<span class="sd">Here, I can import this module from anywhere</span>
<span class="sd">===============================================================================</span>
<span class="sd">Created on 9, May 2016</span>

<span class="sd">Note: big update on 02/11/2016 - replaced all np.argsort with tw.argsort so</span>
<span class="sd">that &quot;ties&quot;-indices are ordered by their occurence.  This helps me do</span>
<span class="sd">consistency check with my various knn-type methods.</span>

<span class="sd">Note: big update on 02/13/2016 - all NMF methods now default initializes via</span>
<span class="sd">&#39;nndsvd&#39;, and rho=1e3, tol=5e-5.</span>

<span class="sd">Update 02/14/2016 - all NMF methods max_iter now set to 5000</span>
<span class="sd">Update 02/14/2016 - changed tol=1e-4 for all nmf methods</span>

<span class="sd">@author: takanori</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="kn">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">scipy</span> <span class="kn">as</span> <span class="nn">sp</span>
<span class="kn">import</span> <span class="nn">pandas</span> <span class="kn">as</span> <span class="nn">pd</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="kn">as</span> <span class="nn">plt</span>

<span class="kn">from</span> <span class="nn">numpy</span> <span class="kn">import</span> <span class="n">dot</span><span class="p">,</span> <span class="n">trace</span>

<span class="kn">from</span> <span class="nn">sklearn.utils.validation</span> <span class="kn">import</span> <span class="n">check_is_fitted</span><span class="c1">#, check_random_state</span>
<span class="kn">from</span> <span class="nn">sklearn.base</span> <span class="kn">import</span> <span class="n">BaseEstimator</span><span class="p">,</span><span class="n">TransformerMixin</span><span class="p">,</span><span class="n">ClassifierMixin</span>

<span class="kn">import</span> <span class="nn">time</span>

<span class="kn">import</span> <span class="nn">tak</span> <span class="kn">as</span> <span class="nn">tw</span>
<span class="kn">from</span> <span class="nn">scipy.linalg</span> <span class="kn">import</span> <span class="n">norm</span><span class="p">,</span><span class="n">solve</span><span class="p">,</span><span class="n">svd</span>

<span class="kn">from</span> <span class="nn">tak.core</span> <span class="kn">import</span> <span class="n">print_time</span>
<span class="kn">from</span> <span class="nn">sklearn.linear_model</span> <span class="kn">import</span> <span class="n">Ridge</span>
<span class="c1">#%%==== Main functions ====</span>
<span class="k">def</span> <span class="nf">pnmf</span><span class="p">(</span><span class="n">X</span><span class="p">,</span><span class="n">r</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span><span class="n">max_iter</span><span class="o">=</span><span class="mi">5000</span><span class="p">,</span> <span class="n">tol</span><span class="o">=</span><span class="mf">1e-4</span><span class="p">,</span> <span class="n">l2_pen</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">W</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span><span class="n">return_cost</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
    <span class="sd">r&quot;&quot;&quot; Projective NMF</span>

<span class="sd">    Projective NMF model of 2010 N. Yang</span>

<span class="sd">    Model: :math:`X \approx W(W^T X)`</span>

<span class="sd">    .. math::</span>

<span class="sd">        \min_{W\geq 0} \frac{1}{2}\|X-WH\|^2_F \text{  such that  } H=W^T X</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    X : ndarray of shape (n_features, n_samples)=(p,n)</span>
<span class="sd">        Data matrix with columns as data points</span>
<span class="sd">    r : int</span>
<span class="sd">        Dimension of the embedding space (n_components)</span>
<span class="sd">    max_iter : int</span>
<span class="sd">        max number of iterations</span>
<span class="sd">    tol : float</span>
<span class="sd">        convergence tolerance</span>
<span class="sd">    l2_pen : float (Default = None)</span>
<span class="sd">        L2 regularization on basis W</span>
<span class="sd">    W : ndarray of shape (n_features, n_components)=(p,r)</span>
<span class="sd">        Initial basis-matrix estimate</span>
<span class="sd">    return_cost : bool (Default = False)</span>
<span class="sd">        Return per-iteration cost and diffW (increases computation)</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    W : array of shape (n_features,n_components) = (p,r)</span>
<span class="sd">        Non-negative Basis matrix</span>

<span class="sd">    Usage</span>
<span class="sd">    -----</span>
<span class="sd">    &gt;&gt;&gt; # usually X = (n,p) matrix... but pnmf assumes X=(p,n), so apply transpose</span>
<span class="sd">    &gt;&gt;&gt; W = pnmf(X.T,r=10)</span>
<span class="sd">    &gt;&gt;&gt; W, cost_, diffW_ = pnmf(X.T,r=10,return_cost=True)</span>

<span class="sd">    History</span>
<span class="sd">    -------</span>
<span class="sd">    Update 02/14/2016 - modified &quot;cost&quot; from frobenius to **squared**-</span>
<span class="sd">    frobenius norm (for consistency with my other admm scripts)</span>
<span class="sd">    </span>
<span class="sd">    - update 07/11/2016 -- added keyboard interrupt exception</span>
<span class="sd">    - update 10/04/2016 -- added nnd-svd option for W</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">p</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="k">if</span> <span class="n">W</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
        <span class="n">W</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="n">p</span><span class="p">,</span><span class="n">r</span><span class="p">)</span>
        <span class="n">W</span> <span class="o">/=</span> <span class="n">norm</span><span class="p">(</span><span class="n">W</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">W</span> <span class="o">==</span> <span class="s1">&#39;nndsvd&#39;</span><span class="p">:</span>
        <span class="n">W</span> <span class="o">=</span> <span class="n">nnd_svd</span><span class="p">(</span><span class="n">X</span><span class="p">,</span><span class="n">r</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">return_cost</span><span class="p">:</span>
        <span class="n">diffW_list</span><span class="o">=</span><span class="p">[]</span>
        <span class="n">cost_list</span><span class="o">=</span><span class="p">[]</span>

    <span class="n">start</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
    <span class="k">for</span> <span class="nb">iter</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">max_iter</span><span class="p">):</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">W_old</span> <span class="o">=</span> <span class="n">W</span>
    
            <span class="n">XtW</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">W</span><span class="p">)</span>
            <span class="n">WtW</span> <span class="o">=</span> <span class="n">W</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">W</span><span class="p">)</span>
    
            <span class="c1"># numerator term</span>
            <span class="n">num</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">XtW</span><span class="p">)</span>
            <span class="n">den</span> <span class="o">=</span> <span class="n">W</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">XtW</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">XtW</span><span class="p">))</span> <span class="o">+</span> <span class="n">X</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">XtW</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">WtW</span><span class="p">))</span> <span class="o">+</span> <span class="mf">1e-10</span>
    <span class="c1">#        den = W.dot(XtW.T.dot(XtW)) + 1e-10</span>
            <span class="k">if</span> <span class="n">l2_pen</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
                <span class="c1"># extra term arising from Frobenius norm regularizer</span>
                <span class="n">den</span> <span class="o">=</span> <span class="n">den</span> <span class="o">+</span> <span class="n">l2_pen</span> <span class="o">*</span> <span class="n">W</span>
    
            <span class="n">W</span> <span class="o">=</span> <span class="n">W</span><span class="o">*</span> <span class="p">(</span><span class="n">num</span> <span class="o">/</span> <span class="n">den</span><span class="p">)</span>
            <span class="n">W</span> <span class="o">/=</span> <span class="n">norm</span><span class="p">(</span><span class="n">W</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span> <span class="c1"># divide by largest singular value</span>
    
            <span class="n">diffW</span> <span class="o">=</span> <span class="n">norm</span><span class="p">(</span><span class="n">W_old</span> <span class="o">-</span> <span class="n">W</span><span class="p">,</span> <span class="s1">&#39;fro&#39;</span><span class="p">)</span> <span class="o">/</span> <span class="n">norm</span><span class="p">(</span><span class="n">W_old</span><span class="p">,</span> <span class="s1">&#39;fro&#39;</span><span class="p">)</span>
    
            <span class="k">if</span> <span class="p">(</span><span class="n">diffW</span> <span class="o">&lt;</span> <span class="n">tol</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="nb">iter</span> <span class="o">&gt;</span> <span class="mi">100</span><span class="p">):</span> <span class="c1"># allow at least 100 iter for &quot;burn-in&quot;</span>
                <span class="k">break</span>
    
            <span class="k">if</span> <span class="n">return_cost</span><span class="p">:</span>
                <span class="sd">&quot;&quot;&quot;keep track of relevant per-iteration values&quot;&quot;&quot;</span>
                <span class="n">diffW_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">diffW</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">l2_pen</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
                    <span class="n">cost_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">norm</span><span class="p">(</span><span class="n">X</span> <span class="o">-</span> <span class="n">W</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">W</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">X</span><span class="p">)),</span><span class="s1">&#39;fro&#39;</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">cost_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">norm</span><span class="p">(</span><span class="n">X</span> <span class="o">-</span> <span class="n">W</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">W</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">X</span><span class="p">)),</span><span class="s1">&#39;fro&#39;</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span>
                                     <span class="mf">0.5</span><span class="o">*</span><span class="n">l2_pen</span><span class="o">*</span><span class="n">norm</span><span class="p">(</span><span class="n">W</span><span class="p">,</span><span class="s1">&#39;fro&#39;</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
    
            <span class="k">if</span> <span class="nb">iter</span> <span class="o">%</span> <span class="mi">500</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">obj_val</span> <span class="o">=</span> <span class="n">norm</span><span class="p">(</span><span class="n">X</span> <span class="o">-</span> <span class="n">W</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">W</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">X</span><span class="p">)),</span><span class="s1">&#39;fro&#39;</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span>
                <span class="k">if</span> <span class="n">l2_pen</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
                    <span class="c1"># add frobenius norm L2 penalty to objective</span>
                    <span class="n">obj_val</span> <span class="o">=</span> <span class="n">obj_val</span> <span class="o">+</span> <span class="mf">0.5</span><span class="o">*</span><span class="n">l2_pen</span><span class="o">*</span><span class="n">norm</span><span class="p">(</span><span class="n">W</span><span class="p">,</span><span class="s1">&#39;fro&#39;</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span>
                <span class="k">print</span> <span class="s2">&quot;iter = {:4}, diff = {:3.2e}, cost = {:6.5e} ({:3.1f} sec)&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                    <span class="nb">iter</span><span class="p">,</span><span class="n">diffW</span><span class="p">,</span> <span class="n">obj_val</span><span class="p">,</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span><span class="o">-</span><span class="n">start</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">KeyboardInterrupt</span><span class="p">:</span>
            <span class="k">break</span>
    <span class="c1">#print iter, diffW</span>
    <span class="k">if</span> <span class="n">return_cost</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">W</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">cost_list</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">diffW_list</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">W</span>


<span class="k">def</span> <span class="nf">gpnmf</span><span class="p">(</span><span class="n">X</span><span class="p">,</span><span class="n">r</span><span class="p">,</span> <span class="n">A</span><span class="p">,</span> <span class="n">lam</span><span class="p">,</span> <span class="n">max_iter</span><span class="o">=</span><span class="mi">5000</span><span class="p">,</span> <span class="n">tol</span><span class="o">=</span><span class="mf">1e-4</span><span class="p">,</span> <span class="n">l2_pen</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">W</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span><span class="n">return_cost</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Graph-regularized Projective NMF</span>

<span class="sd">    Projective NMF model of 2010 N. Yang</span>

<span class="sd">    Model: :math:`X \\approx W(W^T X)`</span>

<span class="sd">    .. math::</span>

<span class="sd">        \\min_{W\\geq 0} \\frac{1}{2}\\|X-WH\|^2_F \\text{  such that  } H=W^T X</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    X : ndarray of shape (n_features, n_samples)=(p,n)</span>
<span class="sd">        Data matrix with columns as data points</span>
<span class="sd">    r : int</span>
<span class="sd">        Dimension of the embedding space (n_components)</span>
<span class="sd">    A : ndarray of shape [n_samples,n_samples]</span>
<span class="sd">        Similarity/adjacency matrix</span>
<span class="sd">    lam : float</span>
<span class="sd">        regularization parameter on graph penalty</span>
<span class="sd">    max_iter : int</span>
<span class="sd">        max number of iterations</span>
<span class="sd">    tol : float</span>
<span class="sd">        convergence tolerance</span>
<span class="sd">    l2_pen : float (Default = None)</span>
<span class="sd">        L2 regularization on basis W</span>
<span class="sd">    W : ndarray of shape (n_features, n_components)=(p,r)</span>
<span class="sd">        Initial basis-matrix estimate</span>
<span class="sd">    return_cost : bool (Default = False)</span>
<span class="sd">        Return per-iteration cost and diffW (increases computation)</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    W : array of shape (n_features,n_components) = (p,r)</span>
<span class="sd">        Non-negative Basis matrix</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">p</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="c1"># degree matrix</span>
    <span class="n">D</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">A</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">))</span>

    <span class="k">if</span> <span class="n">W</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
        <span class="n">W</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="n">p</span><span class="p">,</span><span class="n">r</span><span class="p">)</span>
        <span class="n">W</span> <span class="o">/=</span> <span class="n">norm</span><span class="p">(</span><span class="n">W</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">return_cost</span><span class="p">:</span>
        <span class="n">diffW_list</span><span class="o">=</span><span class="p">[]</span>
        <span class="n">cost_list</span><span class="o">=</span><span class="p">[]</span>

    <span class="n">start</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
    <span class="n">XA</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
    <span class="n">XD</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">D</span><span class="p">)</span>
    <span class="k">for</span> <span class="nb">iter</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">max_iter</span><span class="p">):</span>
        <span class="n">W_old</span> <span class="o">=</span> <span class="n">W</span>

        <span class="n">XtW</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">W</span><span class="p">)</span>
        <span class="n">WtW</span> <span class="o">=</span> <span class="n">W</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">W</span><span class="p">)</span>

        <span class="c1"># numerator term</span>
        <span class="n">num</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">X</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">XtW</span><span class="p">)</span> <span class="o">+</span> <span class="n">lam</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">XA</span><span class="p">,</span><span class="n">XtW</span><span class="p">)</span>
        <span class="n">den</span> <span class="o">=</span> <span class="n">W</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">XtW</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">XtW</span><span class="p">))</span> <span class="o">+</span> <span class="n">X</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">XtW</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">WtW</span><span class="p">))</span> <span class="o">+</span> <span class="n">lam</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">XD</span><span class="p">,</span><span class="n">XtW</span><span class="p">)</span> <span class="o">+</span> <span class="mf">1e-10</span>

<span class="c1">#        den = W.dot(XtW.T.dot(XtW)) + 1e-10</span>
        <span class="k">if</span> <span class="n">l2_pen</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="c1"># extra term arising from Frobenius norm regularizer</span>
            <span class="n">den</span> <span class="o">=</span> <span class="n">den</span> <span class="o">+</span> <span class="n">l2_pen</span> <span class="o">*</span> <span class="n">W</span>

        <span class="n">W</span> <span class="o">=</span> <span class="n">W</span><span class="o">*</span> <span class="p">(</span><span class="n">num</span> <span class="o">/</span> <span class="n">den</span><span class="p">)</span>
        <span class="n">W</span> <span class="o">/=</span> <span class="n">norm</span><span class="p">(</span><span class="n">W</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span> <span class="c1"># divide by largest singular value</span>

        <span class="n">diffW</span> <span class="o">=</span> <span class="n">norm</span><span class="p">(</span><span class="n">W_old</span> <span class="o">-</span> <span class="n">W</span><span class="p">,</span> <span class="s1">&#39;fro&#39;</span><span class="p">)</span> <span class="o">/</span> <span class="n">norm</span><span class="p">(</span><span class="n">W_old</span><span class="p">,</span> <span class="s1">&#39;fro&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">diffW</span> <span class="o">&lt;</span> <span class="n">tol</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="nb">iter</span> <span class="o">&gt;</span> <span class="mi">100</span><span class="p">):</span> <span class="c1"># allow at least 100 iter for &quot;burn-in&quot;</span>
            <span class="k">break</span>

        <span class="k">if</span> <span class="n">return_cost</span><span class="p">:</span>
            <span class="sd">&quot;&quot;&quot;keep track of relevant per-iteration values&quot;&quot;&quot;</span>
            <span class="n">diffW_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">diffW</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">l2_pen</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
                <span class="n">cost_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">norm</span><span class="p">(</span><span class="n">X</span> <span class="o">-</span> <span class="n">W</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">W</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">X</span><span class="p">)),</span><span class="s1">&#39;fro&#39;</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">cost_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">norm</span><span class="p">(</span><span class="n">X</span> <span class="o">-</span> <span class="n">W</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">W</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">X</span><span class="p">)),</span><span class="s1">&#39;fro&#39;</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="o">/</span><span class="mi">2</span> <span class="o">+</span>
                                 <span class="mf">0.5</span><span class="o">*</span><span class="n">l2_pen</span><span class="o">*</span><span class="n">norm</span><span class="p">(</span><span class="n">W</span><span class="p">,</span><span class="s1">&#39;fro&#39;</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">iter</span> <span class="o">%</span> <span class="mi">500</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">obj_val</span> <span class="o">=</span> <span class="n">norm</span><span class="p">(</span><span class="n">X</span> <span class="o">-</span> <span class="n">W</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">W</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">X</span><span class="p">)),</span><span class="s1">&#39;fro&#39;</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span>
            <span class="k">if</span> <span class="n">l2_pen</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
                <span class="c1"># add frobenius norm L2 penalty to objective</span>
                <span class="n">obj_val</span> <span class="o">=</span> <span class="n">obj_val</span> <span class="o">+</span> <span class="mf">0.5</span><span class="o">*</span><span class="n">l2_pen</span><span class="o">*</span><span class="n">norm</span><span class="p">(</span><span class="n">W</span><span class="p">,</span><span class="s1">&#39;fro&#39;</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span>
            <span class="k">print</span> <span class="s2">&quot;iter = {:4}, diff = {:3.2e}, cost = {:6.5e} ({:3.1f} sec)&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                <span class="nb">iter</span><span class="p">,</span><span class="n">diffW</span><span class="p">,</span> <span class="n">obj_val</span><span class="p">,</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span><span class="o">-</span><span class="n">start</span><span class="p">)</span>
    <span class="c1">#print iter, diffW</span>
    <span class="k">if</span> <span class="n">return_cost</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">W</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">cost_list</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">diffW_list</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">W</span>


<span class="k">def</span> <span class="nf">nmf_admm</span><span class="p">(</span><span class="n">X</span><span class="p">,</span><span class="n">r</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span><span class="n">rho</span><span class="o">=</span><span class="mf">1e3</span><span class="p">,</span><span class="n">max_iter</span><span class="o">=</span><span class="mi">5000</span><span class="p">,</span><span class="n">tol</span><span class="o">=</span><span class="mf">1e-4</span><span class="p">,</span> <span class="n">disp_freq</span><span class="o">=</span><span class="mi">500</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; NMF solved via ADMM, as proposed in 2010 Y. Zhang from Rice</span>

<span class="sd">    [1] 2010 Yin Zhang, &quot;An Alternating direction algorithm for NMF&quot;</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">p</span><span class="p">,</span><span class="n">n</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">shape</span>

    <span class="c1"># main primal variables</span>
    <span class="n">W</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="n">p</span><span class="p">,</span><span class="n">r</span><span class="p">)</span> <span class="c1"># X in Y. Zhang</span>
    <span class="n">H</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="n">r</span><span class="p">,</span><span class="n">n</span><span class="p">)</span> <span class="c1"># Y in Y. Zhang</span>

    <span class="c1"># auxiliary variables introduced via variable splitting</span>
    <span class="n">Wtil</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">W</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="c1"># U in Y. Zhang</span>
    <span class="n">Htil</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">H</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="c1"># V in Y. Zhang</span>

    <span class="c1"># dual variables</span>
    <span class="n">Lam_W</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">W</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="c1"># Lambda in Y. Zhang</span>
    <span class="n">Lam_H</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">H</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="c1"># Pie    in Y. Zhang</span>

    <span class="n">eye_r</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="n">r</span><span class="p">)</span>

    <span class="c1"># keep track of frobenius norm loss</span>
    <span class="n">cost_list</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">cost</span> <span class="o">=</span> <span class="n">norm</span><span class="p">(</span><span class="n">W</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">H</span><span class="p">)</span> <span class="o">-</span> <span class="n">X</span><span class="p">,</span><span class="s1">&#39;fro&#39;</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="o">/</span><span class="mi">2</span>
    <span class="n">cost_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">cost</span><span class="p">)</span>

    <span class="c1"># keep track of relative prima residual</span>
    <span class="n">res_W</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">res_H</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="c1"># also keep track of diffW</span>
    <span class="n">diffW</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="n">start</span><span class="o">=</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
    <span class="c1">#--- begin admm iterations ---#</span>
    <span class="k">for</span> <span class="nb">iter</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">max_iter</span><span class="p">):</span>
        <span class="n">W_old</span> <span class="o">=</span> <span class="n">W</span>

        <span class="c1">#--- primal updates (W,H,Wtil,Htil) ---#</span>
        <span class="n">W</span> <span class="o">=</span> <span class="n">solve</span><span class="p">(</span> <span class="n">dot</span><span class="p">(</span><span class="n">H</span><span class="p">,</span><span class="n">H</span><span class="o">.</span><span class="n">T</span><span class="p">)</span> <span class="o">+</span> <span class="n">rho</span><span class="o">*</span><span class="n">eye_r</span><span class="p">,</span>
                   <span class="n">dot</span><span class="p">(</span><span class="n">H</span><span class="p">,</span><span class="n">X</span><span class="o">.</span><span class="n">T</span><span class="p">)</span> <span class="o">+</span> <span class="n">rho</span><span class="o">*</span><span class="n">Wtil</span><span class="o">.</span><span class="n">T</span> <span class="o">-</span> <span class="n">Lam_W</span><span class="o">.</span><span class="n">T</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>

        <span class="n">H</span> <span class="o">=</span> <span class="n">solve</span><span class="p">(</span> <span class="n">dot</span><span class="p">(</span><span class="n">W</span><span class="o">.</span><span class="n">T</span><span class="p">,</span><span class="n">W</span><span class="p">)</span> <span class="o">+</span> <span class="n">rho</span><span class="o">*</span><span class="n">eye_r</span><span class="p">,</span>
                   <span class="n">dot</span><span class="p">(</span><span class="n">W</span><span class="o">.</span><span class="n">T</span><span class="p">,</span><span class="n">X</span><span class="p">)</span> <span class="o">+</span> <span class="n">rho</span><span class="o">*</span><span class="n">Htil</span> <span class="o">-</span> <span class="n">Lam_H</span><span class="p">)</span>

        <span class="n">Wtil</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">W</span><span class="o">+</span><span class="n">Lam_W</span><span class="o">/</span><span class="n">rho</span><span class="p">)</span>
        <span class="n">Htil</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">H</span><span class="o">+</span><span class="n">Lam_H</span><span class="o">/</span><span class="n">rho</span><span class="p">)</span>

        <span class="c1">#--- dual updates (Lam_W, Lam_H) ---</span>
        <span class="n">Lam_W</span> <span class="o">+=</span> <span class="n">rho</span><span class="o">*</span><span class="p">(</span><span class="n">W</span><span class="o">-</span><span class="n">Wtil</span><span class="p">)</span>
        <span class="n">Lam_H</span> <span class="o">+=</span> <span class="n">rho</span><span class="o">*</span><span class="p">(</span><span class="n">H</span><span class="o">-</span><span class="n">Htil</span><span class="p">)</span>

        <span class="c1">#--- compute main objective/cost ---#</span>
        <span class="n">cost</span> <span class="o">=</span> <span class="n">norm</span><span class="p">(</span><span class="n">X</span> <span class="o">-</span> <span class="n">dot</span><span class="p">(</span><span class="n">W</span><span class="p">,</span><span class="n">H</span><span class="p">),</span> <span class="s1">&#39;fro&#39;</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="o">/</span><span class="mi">2</span>
        <span class="n">cost_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">cost</span><span class="p">)</span>

        <span class="c1">#--- compute relative primal residual ---#</span>
        <span class="n">res_W</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">norm</span><span class="p">(</span><span class="n">W</span><span class="o">-</span><span class="n">Wtil</span><span class="p">,</span><span class="s1">&#39;fro&#39;</span><span class="p">)</span><span class="o">/</span><span class="n">norm</span><span class="p">(</span><span class="n">W</span><span class="p">,</span><span class="s1">&#39;fro&#39;</span><span class="p">))</span>
        <span class="n">res_H</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">norm</span><span class="p">(</span><span class="n">H</span><span class="o">-</span><span class="n">Htil</span><span class="p">,</span><span class="s1">&#39;fro&#39;</span><span class="p">)</span><span class="o">/</span><span class="n">norm</span><span class="p">(</span><span class="n">H</span><span class="p">,</span><span class="s1">&#39;fro&#39;</span><span class="p">))</span>
        <span class="n">diffW</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">norm</span><span class="p">(</span><span class="n">W</span><span class="o">-</span><span class="n">W_old</span><span class="p">,</span><span class="s1">&#39;fro&#39;</span><span class="p">)</span><span class="o">/</span><span class="n">norm</span><span class="p">(</span><span class="n">W_old</span><span class="p">,</span><span class="s1">&#39;fro&#39;</span><span class="p">))</span>
        <span class="k">if</span> <span class="nb">iter</span> <span class="o">%</span> <span class="n">disp_freq</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
<span class="c1">#            print &quot;iter = {:4}, cost = {:3.3f} ({:3.1f} sec)&quot;.format(</span>
<span class="c1">#                iter,  cost_list[iter+1],time.time()-start)</span>
            <span class="n">str_</span> <span class="o">=</span> <span class="s2">&quot;iter={:4} cost={:3.3f} &quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">iter</span><span class="p">,</span><span class="n">cost_list</span><span class="p">[</span><span class="nb">iter</span><span class="o">+</span><span class="mi">1</span><span class="p">])</span><span class="o">+</span>\
                   <span class="s2">&quot;res_W={:3.2e} res_H={:3.2e} diffW={:3.2e} ({:3.1f} sec)&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                   <span class="n">res_W</span><span class="p">[</span><span class="nb">iter</span><span class="p">],</span><span class="n">res_H</span><span class="p">[</span><span class="nb">iter</span><span class="p">],</span><span class="n">diffW</span><span class="p">[</span><span class="nb">iter</span><span class="p">],</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span><span class="o">-</span><span class="n">start</span><span class="p">)</span>
            <span class="k">print</span> <span class="n">str_</span>

    <span class="c1"># convert residual in pandas dataframe</span>
    <span class="n">res</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">([</span><span class="n">res_W</span><span class="p">,</span><span class="n">res_H</span><span class="p">,</span><span class="n">diffW</span><span class="p">],</span><span class="n">index</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;res_W&#39;</span><span class="p">,</span><span class="s1">&#39;res_H&#39;</span><span class="p">,</span><span class="s1">&#39;diffW&#39;</span><span class="p">])</span><span class="o">.</span><span class="n">T</span>
    <span class="k">return</span> <span class="n">W</span><span class="p">,</span><span class="n">H</span><span class="p">,</span><span class="n">Wtil</span><span class="p">,</span><span class="n">Htil</span><span class="p">,</span><span class="n">cost</span><span class="p">,</span><span class="n">res</span>


<span class="k">def</span> <span class="nf">pnmf_admm</span><span class="p">(</span><span class="n">X</span><span class="p">,</span><span class="n">r</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span><span class="n">rho</span><span class="o">=</span><span class="mf">1e3</span><span class="p">,</span><span class="n">max_iter</span><span class="o">=</span><span class="mi">5000</span><span class="p">,</span><span class="n">tol</span><span class="o">=</span><span class="mf">1e-4</span><span class="p">,</span><span class="n">W_init</span><span class="o">=</span><span class="s1">&#39;nndsvd&#39;</span><span class="p">,</span><span class="n">disp_freq</span><span class="o">=</span><span class="mi">1000</span><span class="p">,</span>
              <span class="n">silence</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Projective NMF using ADMM.</span>

<span class="sd">    &gt;&gt;&gt; W,P,H,Wtil,Ptil,cost_list,res = pnmf_admm(X,r,rho=1e2)</span>

<span class="sd">    The projective NMF here adopts the following parametrization:</span>

<span class="sd">    .. math ::</span>

<span class="sd">        \\min_{W,P} \\frac{1}{2}\|X - W(PX)\|^2_F</span>
<span class="sd">            \;\; \\text{s.t.}\;\;  W\ge 0, P \ge 0</span>

<span class="sd">    This is converted into the following equivalent constrained problem:</span>

<span class="sd">    .. math ::</span>

<span class="sd">        \\min_{W,P,H} \\frac{1}{2}\|X - WH\|^2_F</span>
<span class="sd">            + I_+(\\tilde{W}) + I_+(\\tilde{P})</span>
<span class="sd">            \\\\ \\quad \\text{s.t.}\;\;  W\ge 0, P \ge 0, H=PX,</span>
<span class="sd">                         W=\\tilde{W}, P=\\tilde{P}</span>

<span class="sd">        W,\\tilde{W} \in \mathbb{R}_+^{p\\times r}\\quad</span>
<span class="sd">        P,\\tilde{P} \in \mathbb{R}_+^{r\\times p}\\quad</span>
<span class="sd">        H \in \mathbb{R}_+^{r\\times n}\\quad</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    X : ndarray of shape (n_features, n_samples)=(p,n)</span>
<span class="sd">        Data matrix with columns as data points</span>
<span class="sd">    r : int</span>
<span class="sd">        Dimension of the embedding space (n_components)</span>
<span class="sd">    rho : float</span>
<span class="sd">        Augmented Lagrangian parameter</span>
<span class="sd">    max_iter : int</span>
<span class="sd">        max number of iterations</span>
<span class="sd">    tol : float</span>
<span class="sd">        convergence tolerance (on relative change in objective value and</span>
<span class="sd">        all primal residuals)</span>
<span class="sd">    W_init : None, rng, or &#39;nndsvd&#39; (default)</span>
<span class="sd">        Way to initialize W (and H).  If ``None`` or ``RandomState object``</span>
<span class="sd">        is supplied, both W and H will be initialized via non-negative</span>
<span class="sd">        random number.  If ``&#39;nndsvd&#39;``, will use deterministic initialization</span>
<span class="sd">        NNDSVD &quot;Non-Negative Double Singular Value Decomposition&quot;, proposed by</span>
<span class="sd">        Boutsidis2008.</span>
<span class="sd">    disp_freq : int</span>
<span class="sd">        Frequency of update display (in iterations)</span>
<span class="sd">    silence : bool</span>
<span class="sd">        If True, don&#39;t print-out convergence detail at the end.</span>

<span class="sd">    Update history</span>
<span class="sd">    --------------</span>
<span class="sd">    **02/01/2016** - updates based on ``t_0127d2_revisit_pnmf_admm.py``</span>

<span class="sd">    - change initialization scheme and order of primal admm updates</span>

<span class="sd">    **02/02/2016**</span>

<span class="sd">    - added ``silence`` option</span>
<span class="sd">    - changed input ``W`` to ``W_init``</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">p</span><span class="p">,</span><span class="n">n</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">shape</span>
    <span class="c1">#%%=== initialize variables =====</span>
    <span class="c1"># define main primal variable W (basis matrix)</span>
    <span class="k">if</span> <span class="n">W_init</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
        <span class="n">W</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="n">p</span><span class="p">,</span><span class="n">r</span><span class="p">)</span>
        <span class="n">W</span> <span class="o">/=</span> <span class="n">norm</span><span class="p">(</span><span class="n">W</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>

        <span class="n">H</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="n">r</span><span class="p">,</span><span class="n">n</span><span class="p">)</span>
        <span class="n">H</span> <span class="o">/=</span> <span class="n">norm</span><span class="p">(</span><span class="n">H</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">W_init</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">RandomState</span><span class="p">):</span>
        <span class="n">rng</span> <span class="o">=</span> <span class="n">W_init</span>

        <span class="n">W</span> <span class="o">=</span> <span class="n">rng</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="n">p</span><span class="p">,</span><span class="n">r</span><span class="p">)</span>
        <span class="n">W</span> <span class="o">/=</span> <span class="n">norm</span><span class="p">(</span><span class="n">W</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>

        <span class="n">H</span> <span class="o">=</span> <span class="n">rng</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="n">r</span><span class="p">,</span><span class="n">n</span><span class="p">)</span>
        <span class="n">H</span> <span class="o">/=</span> <span class="n">norm</span><span class="p">(</span><span class="n">H</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">W_init</span> <span class="o">==</span> <span class="s1">&#39;nndsvd&#39;</span><span class="p">:</span>
<span class="c1">#        W = nnd_svd(X,r)</span>
        <span class="n">W</span><span class="p">,</span><span class="n">H</span> <span class="o">=</span> <span class="n">nnd_svd</span><span class="p">(</span><span class="n">X</span><span class="p">,</span><span class="n">r</span><span class="p">,</span><span class="n">get_H</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Invalid input for &quot;W_init&quot;&#39;</span><span class="p">)</span>

    <span class="n">P</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">r</span><span class="p">,</span><span class="n">p</span><span class="p">))</span>
<span class="c1">#    P = np.random.rand(r,p)</span>

    <span class="c1"># aux. variables</span>
    <span class="n">Wtil</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">W</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
    <span class="n">Ptil</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">P</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>

    <span class="c1"># dual variables</span>
    <span class="n">Lam_W</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">W</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
    <span class="n">Lam_P</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">P</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
    <span class="n">Lam_H</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">H</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>


    <span class="c1">#%%=== create empty lists for tracking updates ===</span>
    <span class="c1"># keep track of frobenius norm loss</span>
    <span class="n">cost_list</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">cost</span> <span class="o">=</span> <span class="n">norm</span><span class="p">(</span><span class="n">Wtil</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">Ptil</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">X</span><span class="p">))</span> <span class="o">-</span> <span class="n">X</span><span class="p">,</span><span class="s1">&#39;fro&#39;</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="o">/</span><span class="mi">2</span>
<span class="c1">#    cost = norm( X - dot(W,P.dot(X)), &#39;fro&#39;)**2/2</span>
    <span class="n">cost_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">cost</span><span class="p">)</span>

    <span class="c1"># relative change in cost</span>
    <span class="n">diffcost</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="c1"># keep track of relative primal residual</span>
    <span class="n">res_W</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">res_P</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">res_H</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="c1"># also keep track of diffW</span>
<span class="c1">#    diffW = []</span>
    <span class="c1">#%%=== run admm iterations ===</span>
    <span class="n">eye_r</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="n">r</span><span class="p">)</span>

    <span class="c1"># precompute term needed for inversion lemma</span>
    <span class="n">K</span> <span class="o">=</span> <span class="n">solve</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="o">+</span> <span class="n">dot</span><span class="p">(</span><span class="n">X</span><span class="o">.</span><span class="n">T</span><span class="p">,</span><span class="n">X</span><span class="p">),</span> <span class="n">X</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>

    <span class="n">start</span><span class="o">=</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
    <span class="k">for</span> <span class="nb">iter</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">max_iter</span><span class="p">):</span>
        <span class="c1">#W_old = W #&lt;- to keep track of diffW</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="c1">#================ primal updates (P, W, H, Ptil, Wtil) ===============#</span>
            <span class="c1"># update for P involves inversion lemma...</span>
            <span class="n">_R</span> <span class="o">=</span> <span class="n">dot</span><span class="p">(</span><span class="n">X</span><span class="p">,</span><span class="n">Lam_H</span><span class="o">.</span><span class="n">T</span><span class="p">)</span><span class="o">/</span><span class="n">rho</span> <span class="o">-</span> <span class="n">Lam_P</span><span class="o">.</span><span class="n">T</span><span class="o">/</span><span class="n">rho</span> <span class="o">+</span> <span class="n">dot</span><span class="p">(</span><span class="n">X</span><span class="p">,</span><span class="n">H</span><span class="o">.</span><span class="n">T</span><span class="p">)</span> <span class="o">+</span> <span class="n">Ptil</span><span class="o">.</span><span class="n">T</span>
            <span class="n">P</span> <span class="o">=</span> <span class="p">(</span><span class="n">_R</span> <span class="o">-</span> <span class="n">X</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span> <span class="n">dot</span><span class="p">(</span><span class="n">K</span><span class="p">,</span><span class="n">_R</span><span class="p">)</span> <span class="p">))</span><span class="o">.</span><span class="n">T</span>
            <span class="n">Ptil</span> <span class="o">=</span> <span class="p">(</span><span class="n">P</span><span class="o">+</span><span class="n">Lam_P</span><span class="o">/</span><span class="n">rho</span><span class="p">)</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
    
            <span class="c1"># (W,H) updates</span>
            <span class="n">H</span> <span class="o">=</span> <span class="n">solve</span><span class="p">(</span><span class="n">dot</span><span class="p">(</span><span class="n">W</span><span class="o">.</span><span class="n">T</span><span class="p">,</span><span class="n">W</span><span class="p">)</span><span class="o">+</span><span class="n">rho</span><span class="o">*</span><span class="n">eye_r</span><span class="p">,</span> <span class="n">dot</span><span class="p">(</span><span class="n">W</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">X</span><span class="p">)</span> <span class="o">+</span> <span class="n">rho</span><span class="o">*</span><span class="n">dot</span><span class="p">(</span><span class="n">P</span><span class="p">,</span><span class="n">X</span><span class="p">)</span> <span class="o">-</span> <span class="n">Lam_H</span><span class="p">)</span>
            <span class="n">W</span> <span class="o">=</span> <span class="n">solve</span><span class="p">(</span><span class="n">dot</span><span class="p">(</span><span class="n">H</span><span class="p">,</span><span class="n">H</span><span class="o">.</span><span class="n">T</span><span class="p">)</span><span class="o">+</span><span class="n">rho</span><span class="o">*</span><span class="n">eye_r</span><span class="p">,</span> <span class="n">dot</span><span class="p">(</span><span class="n">H</span><span class="p">,</span> <span class="n">X</span><span class="o">.</span><span class="n">T</span><span class="p">)</span> <span class="o">+</span> <span class="n">rho</span><span class="o">*</span><span class="n">Wtil</span><span class="o">.</span><span class="n">T</span> <span class="o">-</span> <span class="n">Lam_W</span><span class="o">.</span><span class="n">T</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>
            <span class="n">Wtil</span> <span class="o">=</span> <span class="p">(</span><span class="n">W</span><span class="o">+</span><span class="n">Lam_W</span><span class="o">/</span><span class="n">rho</span><span class="p">)</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
    
            <span class="c1">#====================== dual updates =================================#</span>
            <span class="n">Lam_W</span> <span class="o">=</span> <span class="n">Lam_W</span> <span class="o">+</span> <span class="n">rho</span><span class="o">*</span><span class="p">(</span><span class="n">W</span> <span class="o">-</span> <span class="n">Wtil</span><span class="p">)</span>
            <span class="n">Lam_P</span> <span class="o">=</span> <span class="n">Lam_P</span> <span class="o">+</span> <span class="n">rho</span><span class="o">*</span><span class="p">(</span><span class="n">P</span> <span class="o">-</span> <span class="n">Ptil</span><span class="p">)</span>
            <span class="n">Lam_H</span> <span class="o">=</span> <span class="n">Lam_H</span> <span class="o">+</span> <span class="n">rho</span><span class="o">*</span><span class="p">(</span><span class="n">H</span> <span class="o">-</span> <span class="n">dot</span><span class="p">(</span><span class="n">P</span><span class="p">,</span><span class="n">X</span><span class="p">))</span>
    
            <span class="c1">#============ comptute objective values ==============================#</span>
            <span class="c1"># main loss function</span>
            <span class="n">cost</span> <span class="o">=</span> <span class="n">norm</span><span class="p">(</span><span class="n">Wtil</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">Ptil</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">X</span><span class="p">))</span> <span class="o">-</span> <span class="n">X</span><span class="p">,</span><span class="s1">&#39;fro&#39;</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="o">/</span><span class="mi">2</span>
    <span class="c1">#        cost = norm( X - dot(W,P.dot(X)), &#39;fro&#39;)**2/2</span>
            <span class="n">cost_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">cost</span><span class="p">)</span>
    
            <span class="c1"># relative change in cost</span>
            <span class="n">diffcost</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">cost_list</span><span class="p">[</span><span class="nb">iter</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">cost_list</span><span class="p">[</span><span class="nb">iter</span><span class="p">])</span><span class="o">/</span><span class="n">cost_list</span><span class="p">[</span><span class="nb">iter</span><span class="p">])</span>
    
            <span class="c1"># relative primal residuals</span>
            <span class="n">res_W</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">norm</span><span class="p">(</span><span class="n">W</span><span class="o">-</span><span class="n">Wtil</span><span class="p">,</span><span class="s1">&#39;fro&#39;</span><span class="p">)</span><span class="o">/</span><span class="n">norm</span><span class="p">(</span><span class="n">W</span><span class="p">,</span><span class="s1">&#39;fro&#39;</span><span class="p">))</span>
            <span class="n">res_P</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">norm</span><span class="p">(</span><span class="n">P</span><span class="o">-</span><span class="n">Ptil</span><span class="p">,</span><span class="s1">&#39;fro&#39;</span><span class="p">)</span><span class="o">/</span><span class="n">norm</span><span class="p">(</span><span class="n">P</span><span class="p">,</span><span class="s1">&#39;fro&#39;</span><span class="p">))</span>
            <span class="n">res_H</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">norm</span><span class="p">(</span><span class="n">H</span><span class="o">-</span><span class="n">P</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">X</span><span class="p">),</span><span class="s1">&#39;fro&#39;</span><span class="p">)</span><span class="o">/</span><span class="n">norm</span><span class="p">(</span><span class="n">H</span><span class="p">,</span><span class="s1">&#39;fro&#39;</span><span class="p">))</span>
    
            <span class="c1"># relative change in basis matrix</span>
    <span class="c1">#        diffW.append( norm(W-W_old,&#39;fro&#39;)/ norm(W_old, &#39;fro&#39;) )</span>
    
            <span class="c1">#=== termination check ====#</span>
            <span class="n">check_exit</span>  <span class="o">=</span> <span class="p">(</span><span class="n">diffcost</span><span class="p">[</span><span class="nb">iter</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">tol</span><span class="p">)</span>
            <span class="n">check_exit</span> <span class="o">&amp;=</span> <span class="p">(</span><span class="n">res_W</span><span class="p">[</span><span class="nb">iter</span><span class="p">]</span> <span class="o">&lt;</span>  <span class="n">tol</span><span class="p">)</span>
            <span class="n">check_exit</span> <span class="o">&amp;=</span> <span class="p">(</span><span class="n">res_P</span><span class="p">[</span><span class="nb">iter</span><span class="p">]</span> <span class="o">&lt;</span>  <span class="n">tol</span><span class="p">)</span>
            <span class="n">check_exit</span> <span class="o">&amp;=</span> <span class="p">(</span><span class="n">res_H</span><span class="p">[</span><span class="nb">iter</span><span class="p">]</span> <span class="o">&lt;</span>  <span class="n">tol</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">check_exit</span> <span class="ow">and</span> <span class="nb">iter</span> <span class="o">&gt;</span> <span class="mi">300</span><span class="p">:</span> <span class="c1"># allow 300 iterations of &quot;burn-in&quot;</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">silence</span><span class="p">:</span>
                    <span class="k">print</span> <span class="s2">&quot;Termination condition met.  Exit at iter =&quot;</span><span class="p">,</span><span class="nb">iter</span><span class="p">,</span>
                <span class="k">break</span>
            <span class="c1">#=============== print current progress ==============================#</span>
    <span class="c1">#        if iter % disp_freq == 0:</span>
            <span class="k">if</span> <span class="p">(</span><span class="nb">iter</span><span class="o">&gt;</span><span class="mi">1</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="nb">iter</span> <span class="o">%</span> <span class="n">disp_freq</span> <span class="o">==</span> <span class="mi">0</span><span class="p">):</span>
    <span class="c1">#            str_ = &quot;iter={:4} cost={:3.3f}&quot;.format(iter,cost_list[iter+1])</span>
                <span class="n">str_</span> <span class="o">=</span> <span class="s2">&quot;iter={:4} cost={:6.5e}&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">iter</span><span class="p">,</span><span class="n">cost_list</span><span class="p">[</span><span class="nb">iter</span><span class="o">+</span><span class="mi">1</span><span class="p">])</span>
                <span class="n">str_</span> <span class="o">+=</span> <span class="s2">&quot; diffcost={:3.2e}&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">diffcost</span><span class="p">[</span><span class="nb">iter</span><span class="p">])</span>
                <span class="n">str_</span> <span class="o">+=</span> <span class="s2">&quot; res_W={:3.2e}&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">res_W</span><span class="p">[</span><span class="nb">iter</span><span class="p">])</span>
                <span class="n">str_</span> <span class="o">+=</span> <span class="s2">&quot; res_P={:3.2e}&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">res_P</span><span class="p">[</span><span class="nb">iter</span><span class="p">])</span>
                <span class="n">str_</span> <span class="o">+=</span> <span class="s2">&quot; res_H={:3.2e}&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">res_H</span><span class="p">[</span><span class="nb">iter</span><span class="p">])</span>
    <span class="c1">#            str_ += &quot; diffW={:3.2e}&quot;.format(diffW[iter])</span>
                <span class="k">print</span> <span class="n">str_</span> <span class="o">+</span> <span class="s2">&quot; ({:3.1f} sec)&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span><span class="o">-</span><span class="n">start</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">KeyboardInterrupt</span><span class="p">:</span>
            <span class="k">break</span>
    <span class="c1">#%%---- end of admm for loop ---------------------------------------------#</span>
    <span class="n">cost_list</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">cost_list</span><span class="p">)</span>

    <span class="c1"># convert residual in pandas dataframe</span>
    <span class="n">res</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">([</span><span class="n">res_W</span><span class="p">,</span><span class="n">res_P</span><span class="p">,</span><span class="n">res_H</span><span class="p">,</span><span class="n">diffcost</span><span class="p">],</span>
                       <span class="n">index</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;res_W&#39;</span><span class="p">,</span><span class="s1">&#39;res_P&#39;</span><span class="p">,</span><span class="s1">&#39;res_H&#39;</span><span class="p">,</span><span class="s1">&#39;diffcost&#39;</span><span class="p">])</span><span class="o">.</span><span class="n">T</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">silence</span><span class="p">:</span> <span class="n">print_time</span><span class="p">(</span><span class="n">start</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">W</span><span class="p">,</span><span class="n">P</span><span class="p">,</span><span class="n">H</span><span class="p">,</span><span class="n">Wtil</span><span class="p">,</span><span class="n">Ptil</span><span class="p">,</span><span class="n">cost_list</span><span class="p">,</span><span class="n">res</span>


<span class="k">def</span> <span class="nf">projection_spectral</span><span class="p">(</span><span class="n">W</span><span class="p">,</span><span class="n">projection_type</span><span class="o">=</span><span class="s1">&#39;stiefel&#39;</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Projection onto Stiefel manifold or its convex relaxation.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    W : ndarray of shape [p,r], p &gt;= r</span>
<span class="sd">        Input matrix</span>
<span class="sd">    projection_type : string</span>
<span class="sd">        &#39;stiefel&#39; (default) or &#39;convex&#39;</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    The projection of input ``W`` onto the Stiefel manifold or its convex</span>
<span class="sd">    relaxation.</span>

<span class="sd">    History</span>
<span class="sd">    -------</span>
<span class="sd">    Created 02/02/2016</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">U</span><span class="p">,</span><span class="n">S</span><span class="p">,</span><span class="n">V</span> <span class="o">=</span> <span class="n">svd</span><span class="p">(</span><span class="n">W</span><span class="p">,</span><span class="n">full_matrices</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">projection_type</span> <span class="o">==</span> <span class="s1">&#39;stiefel&#39;</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">U</span><span class="p">)</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">V</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">projection_type</span> <span class="o">==</span> <span class="s1">&#39;convex&#39;</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">U</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">minimum</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="n">S</span><span class="p">))</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">V</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Projection must be &#39;stiefel&#39; or &#39;convex&#39;&quot;</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">spnmf_admm</span><span class="p">(</span><span class="n">X</span><span class="p">,</span><span class="n">r</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span><span class="n">constraint</span><span class="o">=</span><span class="s1">&#39;stiefel&#39;</span><span class="p">,</span><span class="n">rho</span><span class="o">=</span><span class="mf">1e3</span><span class="p">,</span><span class="n">max_iter</span><span class="o">=</span><span class="mi">5000</span><span class="p">,</span><span class="n">tol</span><span class="o">=</span><span class="mf">1e-4</span><span class="p">,</span>
               <span class="n">W_init</span><span class="o">=</span><span class="s1">&#39;nndsvd&#39;</span><span class="p">,</span><span class="n">disp_freq</span><span class="o">=</span><span class="mi">1000</span><span class="p">,</span><span class="n">silence</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Spectral Projective NMF using ADMM.</span>

<span class="sd">    Projective NMF with either the orthogonal **Stiefel Manifold contraint**</span>
<span class="sd">    or the convex relaxation **</span>

<span class="sd">    Usage</span>
<span class="sd">    -----</span>
<span class="sd">    &gt;&gt;&gt; W,P,H,W1,Ptil,cost_list,res = spnmf_admm(X, r=10, rho=1e2,</span>
<span class="sd">    &gt;&gt;&gt; ... constraint=&#39;stiefel&#39;,max_iter=5000,tol=1e-4,W=&#39;nndsvd&#39;)</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    X : ndarray of shape (n_features, n_samples)=(p,n)</span>
<span class="sd">        Data matrix with columns as data points</span>
<span class="sd">    r : int</span>
<span class="sd">        Dimension of the embedding space (n_components)</span>
<span class="sd">    constraint : ``&#39;stiefel&#39;`` or ``&#39;convex&#39;``</span>
<span class="sd">        The type of spectral constraint (default: ``&#39;stiefel&#39;``).  This</span>
<span class="sd">        determines the type of spectral projection applied.</span>
<span class="sd">    rho : float</span>
<span class="sd">        Augmented Lagrangian parameter</span>
<span class="sd">    max_iter : int</span>
<span class="sd">        max number of iterations</span>
<span class="sd">    tol : float</span>
<span class="sd">        convergence tolerance (on relative change in objective value and</span>
<span class="sd">        all primal residuals)</span>
<span class="sd">    W_init : None,  rng, or &#39;nndsvd&#39; (default)</span>
<span class="sd">        Way to initialize W (and H).  If ``None`` or ``RandomState object``</span>
<span class="sd">        is supplied, both W and H will be initialized via non-negative</span>
<span class="sd">        random number.  If ``&#39;nndsvd&#39;``, will use deterministic initialization</span>
<span class="sd">        NNDSVD &quot;Non-Negative Double Singular Value Decomposition&quot;, proposed by</span>
<span class="sd">        Boutsidis2008.</span>
<span class="sd">    disp_freq : int</span>
<span class="sd">        Frequency of update display (in iterations)</span>
<span class="sd">    silence : bool</span>
<span class="sd">        If True, don&#39;t print-out convergence detail at the end.</span>

<span class="sd">    History</span>
<span class="sd">    --------------</span>
<span class="sd">    **02/01/2016**</span>

<span class="sd">    - updates based on ``t_0127d2_revisit_pnmf_admm.py``</span>
<span class="sd">    - change initialization scheme and order of primal admm updates</span>

<span class="sd">    **02/02/2016**</span>

<span class="sd">    - Function moved to my nmf_module.  cleaned up codes and docstring.</span>

<span class="sd">    **02/03/2016**</span>

<span class="sd">    - removed ``W2`` from output for consistency with other PNMFtype methods.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">p</span><span class="p">,</span><span class="n">n</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">shape</span>
    <span class="c1">#%%=== initialize variables =====</span>
    <span class="k">if</span> <span class="n">W_init</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
        <span class="n">W</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="n">p</span><span class="p">,</span><span class="n">r</span><span class="p">)</span>
        <span class="n">W</span> <span class="o">/=</span> <span class="n">norm</span><span class="p">(</span><span class="n">W</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>

        <span class="n">H</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="n">r</span><span class="p">,</span><span class="n">n</span><span class="p">)</span>
        <span class="n">H</span> <span class="o">/=</span> <span class="n">norm</span><span class="p">(</span><span class="n">H</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">W_init</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">RandomState</span><span class="p">):</span>
        <span class="n">rng</span> <span class="o">=</span> <span class="n">W_init</span>

        <span class="n">W</span> <span class="o">=</span> <span class="n">rng</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="n">p</span><span class="p">,</span><span class="n">r</span><span class="p">)</span>
        <span class="n">W</span> <span class="o">/=</span> <span class="n">norm</span><span class="p">(</span><span class="n">W</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>

        <span class="n">H</span> <span class="o">=</span> <span class="n">rng</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="n">r</span><span class="p">,</span><span class="n">n</span><span class="p">)</span>
        <span class="n">H</span> <span class="o">/=</span> <span class="n">norm</span><span class="p">(</span><span class="n">H</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">W_init</span> <span class="o">==</span> <span class="s1">&#39;nndsvd&#39;</span><span class="p">:</span>
<span class="c1">#        W = nnd_svd(X,r)</span>
        <span class="n">W</span><span class="p">,</span><span class="n">H</span> <span class="o">=</span> <span class="n">nnd_svd</span><span class="p">(</span><span class="n">X</span><span class="p">,</span><span class="n">r</span><span class="p">,</span><span class="n">get_H</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Invalid input for &quot;W_init&quot;&#39;</span><span class="p">)</span>

    <span class="n">P</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">r</span><span class="p">,</span><span class="n">p</span><span class="p">))</span>
<span class="c1">#    P = np.random.rand(r,p)</span>

    <span class="c1"># aux. variables</span>
    <span class="n">W1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">W</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
    <span class="n">W2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">W</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
    <span class="n">Ptil</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">P</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>

    <span class="c1"># dual variables</span>
    <span class="n">Lam_W1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">W</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
    <span class="n">Lam_W2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">W</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
    <span class="n">Lam_P</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">P</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
    <span class="n">Lam_H</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">H</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>


    <span class="c1">#%%=== create empty lists for tracking updates ===</span>
    <span class="c1"># keep track of frobenius norm loss</span>
    <span class="n">cost_list</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">cost</span> <span class="o">=</span> <span class="n">norm</span><span class="p">(</span><span class="n">W1</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">Ptil</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">X</span><span class="p">))</span> <span class="o">-</span> <span class="n">X</span><span class="p">,</span><span class="s1">&#39;fro&#39;</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="o">/</span><span class="mi">2</span>
<span class="c1">#    cost = norm( X - dot(W,P.dot(X)), &#39;fro&#39;)**2/2</span>
    <span class="n">cost_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">cost</span><span class="p">)</span>

    <span class="c1"># relative change in cost</span>
    <span class="n">diffcost</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="c1"># keep track of relative primal residual</span>
    <span class="n">res_W1</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">res_W2</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">res_P</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">res_H</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="c1"># also keep track of diffW</span>
<span class="c1">#    diffW = []</span>
    <span class="c1">#%%=== run admm iterations ===</span>
    <span class="n">eye_r</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="n">r</span><span class="p">)</span>

    <span class="c1"># precompute term needed for inversion lemma</span>
    <span class="n">K</span> <span class="o">=</span> <span class="n">solve</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="o">+</span> <span class="n">dot</span><span class="p">(</span><span class="n">X</span><span class="o">.</span><span class="n">T</span><span class="p">,</span><span class="n">X</span><span class="p">),</span> <span class="n">X</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>

    <span class="n">start</span><span class="o">=</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
    <span class="k">for</span> <span class="nb">iter</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">max_iter</span><span class="p">):</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="c1">#================ primal updates (P, W, H, Ptil, Wtil) ===============#</span>
            <span class="c1"># update for P involves inversion lemma...</span>
            <span class="n">_R</span> <span class="o">=</span> <span class="n">dot</span><span class="p">(</span><span class="n">X</span><span class="p">,</span><span class="n">Lam_H</span><span class="o">.</span><span class="n">T</span><span class="p">)</span><span class="o">/</span><span class="n">rho</span> <span class="o">-</span> <span class="n">Lam_P</span><span class="o">.</span><span class="n">T</span><span class="o">/</span><span class="n">rho</span> <span class="o">+</span> <span class="n">dot</span><span class="p">(</span><span class="n">X</span><span class="p">,</span><span class="n">H</span><span class="o">.</span><span class="n">T</span><span class="p">)</span> <span class="o">+</span> <span class="n">Ptil</span><span class="o">.</span><span class="n">T</span>
            <span class="n">P</span> <span class="o">=</span> <span class="p">(</span><span class="n">_R</span> <span class="o">-</span> <span class="n">X</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span> <span class="n">dot</span><span class="p">(</span><span class="n">K</span><span class="p">,</span><span class="n">_R</span><span class="p">)</span> <span class="p">))</span><span class="o">.</span><span class="n">T</span>
            <span class="n">Ptil</span> <span class="o">=</span> <span class="p">(</span><span class="n">P</span><span class="o">+</span><span class="n">Lam_P</span><span class="o">/</span><span class="n">rho</span><span class="p">)</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
    
            <span class="c1"># (W,H) updates</span>
            <span class="n">H</span> <span class="o">=</span> <span class="n">solve</span><span class="p">(</span><span class="n">dot</span><span class="p">(</span><span class="n">W</span><span class="o">.</span><span class="n">T</span><span class="p">,</span><span class="n">W</span><span class="p">)</span><span class="o">+</span><span class="n">rho</span><span class="o">*</span><span class="n">eye_r</span><span class="p">,</span> <span class="n">dot</span><span class="p">(</span><span class="n">W</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">X</span><span class="p">)</span> <span class="o">+</span> <span class="n">rho</span><span class="o">*</span><span class="n">dot</span><span class="p">(</span><span class="n">P</span><span class="p">,</span><span class="n">X</span><span class="p">)</span> <span class="o">-</span> <span class="n">Lam_H</span><span class="p">)</span>
            <span class="n">W</span> <span class="o">=</span> <span class="n">solve</span><span class="p">(</span><span class="n">dot</span><span class="p">(</span><span class="n">H</span><span class="p">,</span><span class="n">H</span><span class="o">.</span><span class="n">T</span><span class="p">)</span><span class="o">+</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">rho</span><span class="p">)</span><span class="o">*</span><span class="n">eye_r</span><span class="p">,</span>
                      <span class="n">dot</span><span class="p">(</span><span class="n">H</span><span class="p">,</span> <span class="n">X</span><span class="o">.</span><span class="n">T</span><span class="p">)</span> <span class="o">+</span> <span class="n">rho</span><span class="o">*</span><span class="p">(</span><span class="n">W1</span><span class="o">+</span><span class="n">W2</span><span class="p">)</span><span class="o">.</span><span class="n">T</span> <span class="o">-</span> <span class="n">Lam_W1</span><span class="o">.</span><span class="n">T</span> <span class="o">-</span> <span class="n">Lam_W2</span><span class="o">.</span><span class="n">T</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>
    
            <span class="c1"># projections</span>
            <span class="n">W1</span> <span class="o">=</span> <span class="p">(</span><span class="n">W</span><span class="o">+</span><span class="n">Lam_W1</span><span class="o">/</span><span class="n">rho</span><span class="p">)</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
            <span class="n">W2</span> <span class="o">=</span> <span class="n">projection_spectral</span><span class="p">(</span><span class="n">W</span><span class="o">+</span><span class="n">Lam_W2</span><span class="o">/</span><span class="n">rho</span><span class="p">,</span><span class="n">projection_type</span><span class="o">=</span><span class="n">constraint</span><span class="p">)</span>
    
            <span class="c1">#====================== dual updates =================================#</span>
            <span class="n">Lam_W1</span> <span class="o">=</span> <span class="n">Lam_W1</span> <span class="o">+</span> <span class="n">rho</span><span class="o">*</span><span class="p">(</span><span class="n">W</span> <span class="o">-</span> <span class="n">W1</span><span class="p">)</span>
            <span class="n">Lam_W2</span> <span class="o">=</span> <span class="n">Lam_W2</span> <span class="o">+</span> <span class="n">rho</span><span class="o">*</span><span class="p">(</span><span class="n">W</span> <span class="o">-</span> <span class="n">W2</span><span class="p">)</span>
            <span class="n">Lam_P</span> <span class="o">=</span> <span class="n">Lam_P</span> <span class="o">+</span> <span class="n">rho</span><span class="o">*</span><span class="p">(</span><span class="n">P</span> <span class="o">-</span> <span class="n">Ptil</span><span class="p">)</span>
            <span class="n">Lam_H</span> <span class="o">=</span> <span class="n">Lam_H</span> <span class="o">+</span> <span class="n">rho</span><span class="o">*</span><span class="p">(</span><span class="n">H</span> <span class="o">-</span> <span class="n">dot</span><span class="p">(</span><span class="n">P</span><span class="p">,</span><span class="n">X</span><span class="p">))</span>
    
            <span class="c1">#============ comptute objective values ==============================#</span>
            <span class="c1"># main loss function</span>
            <span class="n">cost</span> <span class="o">=</span> <span class="n">norm</span><span class="p">(</span><span class="n">W1</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">Ptil</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">X</span><span class="p">))</span> <span class="o">-</span> <span class="n">X</span><span class="p">,</span><span class="s1">&#39;fro&#39;</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="o">/</span><span class="mi">2</span>
    <span class="c1">#        cost = norm( X - dot(W,P.dot(X)), &#39;fro&#39;)**2/2</span>
            <span class="n">cost_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">cost</span><span class="p">)</span>
    
            <span class="c1"># relative change in cost</span>
            <span class="n">diffcost</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">cost_list</span><span class="p">[</span><span class="nb">iter</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">cost_list</span><span class="p">[</span><span class="nb">iter</span><span class="p">])</span><span class="o">/</span><span class="n">cost_list</span><span class="p">[</span><span class="nb">iter</span><span class="p">])</span>
    
            <span class="c1"># relative primal residuals</span>
            <span class="n">res_W1</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">norm</span><span class="p">(</span><span class="n">W</span><span class="o">-</span><span class="n">W1</span><span class="p">,</span><span class="s1">&#39;fro&#39;</span><span class="p">)</span><span class="o">/</span><span class="n">norm</span><span class="p">(</span><span class="n">W</span><span class="p">,</span><span class="s1">&#39;fro&#39;</span><span class="p">))</span>
            <span class="n">res_W2</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">norm</span><span class="p">(</span><span class="n">W</span><span class="o">-</span><span class="n">W2</span><span class="p">,</span><span class="s1">&#39;fro&#39;</span><span class="p">)</span><span class="o">/</span><span class="n">norm</span><span class="p">(</span><span class="n">W</span><span class="p">,</span><span class="s1">&#39;fro&#39;</span><span class="p">))</span>
            <span class="n">res_P</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">norm</span><span class="p">(</span><span class="n">P</span><span class="o">-</span><span class="n">Ptil</span><span class="p">,</span><span class="s1">&#39;fro&#39;</span><span class="p">)</span><span class="o">/</span><span class="n">norm</span><span class="p">(</span><span class="n">P</span><span class="p">,</span><span class="s1">&#39;fro&#39;</span><span class="p">))</span>
            <span class="n">res_H</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">norm</span><span class="p">(</span><span class="n">H</span><span class="o">-</span><span class="n">P</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">X</span><span class="p">),</span><span class="s1">&#39;fro&#39;</span><span class="p">)</span><span class="o">/</span><span class="n">norm</span><span class="p">(</span><span class="n">H</span><span class="p">,</span><span class="s1">&#39;fro&#39;</span><span class="p">))</span>
    
            <span class="c1"># relative change in basis matrix</span>
    <span class="c1">#        diffW.append( norm(W-W_old,&#39;fro&#39;)/ norm(W_old, &#39;fro&#39;) )</span>
    
            <span class="c1">#=== termination check =============#</span>
            <span class="n">check_exit</span> <span class="o">=</span>  <span class="p">(</span><span class="n">diffcost</span><span class="p">[</span><span class="nb">iter</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">tol</span><span class="p">)</span>
            <span class="n">check_exit</span> <span class="o">&amp;=</span> <span class="p">(</span>  <span class="n">res_W1</span><span class="p">[</span><span class="nb">iter</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">tol</span><span class="p">)</span>
            <span class="n">check_exit</span> <span class="o">&amp;=</span> <span class="p">(</span>  <span class="n">res_W2</span><span class="p">[</span><span class="nb">iter</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">tol</span><span class="p">)</span>
            <span class="n">check_exit</span> <span class="o">&amp;=</span> <span class="p">(</span>   <span class="n">res_P</span><span class="p">[</span><span class="nb">iter</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">tol</span><span class="p">)</span>
            <span class="n">check_exit</span> <span class="o">&amp;=</span> <span class="p">(</span>   <span class="n">res_H</span><span class="p">[</span><span class="nb">iter</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">tol</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">check_exit</span> <span class="ow">and</span> <span class="nb">iter</span> <span class="o">&gt;</span> <span class="mi">300</span><span class="p">:</span> <span class="c1"># allow 300 iterations of &quot;burn-in&quot;</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">silence</span><span class="p">:</span>
                    <span class="k">print</span> <span class="s2">&quot;Termination condition met.  Exit at iter =&quot;</span><span class="p">,</span><span class="nb">iter</span><span class="p">,</span>
                <span class="k">break</span>
            <span class="c1">#=============== print current progress ==============================#</span>
    <span class="c1">#        if iter % disp_freq == 0:</span>
            <span class="k">if</span> <span class="p">(</span><span class="nb">iter</span><span class="o">&gt;</span><span class="mi">1</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="nb">iter</span> <span class="o">%</span> <span class="n">disp_freq</span> <span class="o">==</span> <span class="mi">0</span><span class="p">):</span>
                <span class="n">str_</span> <span class="o">=</span> <span class="s2">&quot;iter={:4} cost={:6.5e}&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">iter</span><span class="p">,</span><span class="n">cost_list</span><span class="p">[</span><span class="nb">iter</span><span class="o">+</span><span class="mi">1</span><span class="p">])</span>
                <span class="n">str_</span> <span class="o">+=</span> <span class="s2">&quot; diffcost={:3.2e}&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">diffcost</span><span class="p">[</span><span class="nb">iter</span><span class="p">])</span>
                <span class="n">str_</span> <span class="o">+=</span> <span class="s2">&quot; W1={:3.2e}&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">res_W1</span><span class="p">[</span><span class="nb">iter</span><span class="p">])</span>
                <span class="n">str_</span> <span class="o">+=</span> <span class="s2">&quot; W2={:3.2e}&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">res_W2</span><span class="p">[</span><span class="nb">iter</span><span class="p">])</span>
                <span class="n">str_</span> <span class="o">+=</span> <span class="s2">&quot; P={:3.2e}&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">res_P</span><span class="p">[</span><span class="nb">iter</span><span class="p">])</span>
                <span class="n">str_</span> <span class="o">+=</span> <span class="s2">&quot; H={:3.2e}&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">res_H</span><span class="p">[</span><span class="nb">iter</span><span class="p">])</span>
    <span class="c1">#            str_ += &quot; diffW={:3.2e}&quot;.format(diffW[iter])</span>
                <span class="k">print</span> <span class="n">str_</span> <span class="o">+</span> <span class="s2">&quot; ({:3.1f} sec)&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span><span class="o">-</span><span class="n">start</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">KeyboardInterrupt</span><span class="p">:</span>
            <span class="k">break</span>
    <span class="c1">#%%---- end of admm for loop ---------------------------------------------#</span>
    <span class="n">cost_list</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">cost_list</span><span class="p">)</span>

    <span class="c1"># convert residual in pandas dataframe</span>
    <span class="n">res</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">([</span><span class="n">res_W1</span><span class="p">,</span><span class="n">res_W2</span><span class="p">,</span><span class="n">res_P</span><span class="p">,</span><span class="n">res_H</span><span class="p">,</span><span class="n">diffcost</span><span class="p">],</span>
                       <span class="n">index</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;res_W1&#39;</span><span class="p">,</span><span class="s1">&#39;res_W2&#39;</span><span class="p">,</span><span class="s1">&#39;res_P&#39;</span><span class="p">,</span><span class="s1">&#39;res_H&#39;</span><span class="p">,</span><span class="s1">&#39;diffcost&#39;</span><span class="p">])</span><span class="o">.</span><span class="n">T</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">silence</span><span class="p">:</span> <span class="n">print_time</span><span class="p">(</span><span class="n">start</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">W</span><span class="p">,</span><span class="n">P</span><span class="p">,</span><span class="n">H</span><span class="p">,</span><span class="n">W1</span><span class="p">,</span><span class="n">Ptil</span><span class="p">,</span><span class="n">cost_list</span><span class="p">,</span><span class="n">res</span>


<span class="k">def</span> <span class="nf">ls_pnmf_admm</span><span class="p">(</span><span class="n">X</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">r</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span><span class="n">gam</span><span class="o">=</span><span class="mf">1e-1</span><span class="p">,</span><span class="n">rho</span><span class="o">=</span><span class="mf">1e3</span><span class="p">,</span><span class="n">max_iter</span><span class="o">=</span><span class="mi">5000</span><span class="p">,</span><span class="n">tol</span><span class="o">=</span><span class="mf">1e-4</span><span class="p">,</span><span class="n">gam2</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
                 <span class="n">W_init</span><span class="o">=</span><span class="s1">&#39;nndsvd&#39;</span><span class="p">,</span><span class="n">disp_freq</span><span class="o">=</span><span class="mi">1000</span><span class="p">,</span><span class="n">silence</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span><span class="n">add_intercept</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Projective NMF using ADMM.</span>

<span class="sd">    &gt;&gt;&gt; W,P,H,w,Wtil,Ptil,cost,res = ls_pnmf_admm(X,r,rho=1e2)</span>

<span class="sd">    The projective NMF here adopts the following parametrization:</span>

<span class="sd">    .. math ::</span>

<span class="sd">        \\min_{W,P} \\frac{1}{2}\|X - W(PX)\|^2_F</span>
<span class="sd">            \;\; \\text{s.t.}\;\;  W\ge 0, P \ge 0</span>

<span class="sd">    This is converted into the following equivalent constrained problem:</span>

<span class="sd">    .. math ::</span>

<span class="sd">        \\min_{W,P,H} \\frac{1}{2}\|X - WH\|^2_F</span>
<span class="sd">            + I_+(\\tilde{W}) + I_+(\\tilde{P})</span>
<span class="sd">            \\\\ \\quad \\text{s.t.}\;\;  W\ge 0, P \ge 0, H=PX,</span>
<span class="sd">                         W=\\tilde{W}, P=\\tilde{P}</span>

<span class="sd">        W,\\tilde{W} \in \mathbb{R}_+^{p\\times r}\\quad</span>
<span class="sd">        P,\\tilde{P} \in \mathbb{R}_+^{r\\times p}\\quad</span>
<span class="sd">        H \in \mathbb{R}_+^{r\\times n}\\quad</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    X : ndarray of shape (n_features, n_samples)=(p,n)</span>
<span class="sd">        Data matrix with columns as data points</span>
<span class="sd">    y : array-like of shape [n_samples,]</span>
<span class="sd">        Label vector</span>
<span class="sd">    r : int</span>
<span class="sd">        Dimension of the embedding space (n_components)</span>
<span class="sd">    rho : float</span>
<span class="sd">        Augmented Lagrangian parameter</span>
<span class="sd">    max_iter : int</span>
<span class="sd">        max number of iterations</span>
<span class="sd">    tol : float</span>
<span class="sd">        convergence tolerance (on relative change in objective value and</span>
<span class="sd">        all primal residuals)</span>
<span class="sd">    W_init : None, rng, or &#39;nndsvd&#39;</span>
<span class="sd">        Way to initialize W (and H).  If ``None`` or ``RandomState object``</span>
<span class="sd">        is supplied, both W and H will be initialized via non-negative</span>
<span class="sd">        random number.  If ``&#39;nndsvd&#39;``, will use deterministic initialization</span>
<span class="sd">        NNDSVD &quot;Non-Negative Double Singular Value Decomposition&quot;, proposed by</span>
<span class="sd">        Boutsidis2008.</span>
<span class="sd">    disp_freq : int</span>
<span class="sd">        Frequency of update display (in iterations)</span>
<span class="sd">    silence : bool</span>
<span class="sd">        If True, don&#39;t print-out convergence detail at the end.</span>
<span class="sd">    add_intercept : bool (default=False)</span>
<span class="sd">        Add intercept term to classifier (added 02/17/2016)</span>

<span class="sd">    Update history</span>
<span class="sd">    --------------</span>
<span class="sd">    **02/01/2016** - updates based on ``t_0127d2_revisit_pnmf_admm.py``</span>

<span class="sd">    - change initialization scheme and order of primal admm updates</span>

<span class="sd">    **02/02/2016**</span>

<span class="sd">    - added ``silence`` option</span>
<span class="sd">    - changed input ``W`` to ``W_init``</span>

<span class="sd">    **02/17/2016** - added ``add_intercept`` option</span>
<span class="sd">    </span>
<span class="sd">    07/11/2016 -- added keyboard interrupt</span>
<span class="sd">    </span>
<span class="sd">    07/13/2016 -- added &#39;gam2&#39; for regularization (only affects the H update)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">p</span><span class="p">,</span><span class="n">n</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">shape</span>
    <span class="n">gam</span> <span class="o">*=</span> <span class="mf">1.</span><span class="c1"># &lt;- ensure float</span>
    <span class="n">gam2</span> <span class="o">*=</span> <span class="mf">1.</span><span class="c1"># &lt;- ensure float</span>
    <span class="c1">#%%=== initialize variables =====</span>
    <span class="c1"># define main primal variable W (basis matrix)</span>
    <span class="k">if</span> <span class="n">W_init</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
        <span class="n">W</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="n">p</span><span class="p">,</span><span class="n">r</span><span class="p">)</span>
        <span class="n">W</span> <span class="o">/=</span> <span class="n">norm</span><span class="p">(</span><span class="n">W</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>

        <span class="n">H</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="n">r</span><span class="p">,</span><span class="n">n</span><span class="p">)</span>
        <span class="n">H</span> <span class="o">/=</span> <span class="n">norm</span><span class="p">(</span><span class="n">H</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">W_init</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">RandomState</span><span class="p">):</span>
        <span class="n">rng</span> <span class="o">=</span> <span class="n">W_init</span>

        <span class="n">W</span> <span class="o">=</span> <span class="n">rng</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="n">p</span><span class="p">,</span><span class="n">r</span><span class="p">)</span>
        <span class="n">W</span> <span class="o">/=</span> <span class="n">norm</span><span class="p">(</span><span class="n">W</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>

        <span class="n">H</span> <span class="o">=</span> <span class="n">rng</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="n">r</span><span class="p">,</span><span class="n">n</span><span class="p">)</span>
        <span class="n">H</span> <span class="o">/=</span> <span class="n">norm</span><span class="p">(</span><span class="n">H</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">W_init</span> <span class="o">==</span> <span class="s1">&#39;nndsvd&#39;</span><span class="p">:</span>
<span class="c1">#        W = nnd_svd(X,r)</span>
        <span class="n">W</span><span class="p">,</span><span class="n">H</span> <span class="o">=</span> <span class="n">nnd_svd</span><span class="p">(</span><span class="n">X</span><span class="p">,</span><span class="n">r</span><span class="p">,</span><span class="n">get_H</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Invalid input for &quot;W_init&quot;&#39;</span><span class="p">)</span>

    <span class="n">P</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">r</span><span class="p">,</span><span class="n">p</span><span class="p">))</span>
<span class="c1">#    P = np.random.rand(r,p)</span>

    <span class="k">if</span> <span class="n">add_intercept</span><span class="p">:</span>
        <span class="n">w</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">r</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="c1"># &lt;- classification vector</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">w</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">r</span><span class="p">)</span> <span class="c1"># &lt;- classification vector</span>

    <span class="c1"># aux. variables</span>
    <span class="n">Wtil</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">W</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
    <span class="n">Ptil</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">P</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>

    <span class="c1"># dual variables</span>
    <span class="n">Lam_W</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">W</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
    <span class="n">Lam_P</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">P</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
    <span class="n">Lam_H</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">H</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>


    <span class="c1">#%%=== create empty lists for tracking updates ===</span>
    <span class="c1"># keep track of frobenius norm loss</span>
    <span class="n">cost_list</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">cost_nmf_list</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">cost_ls_list</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="n">PX</span> <span class="o">=</span> <span class="n">Ptil</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>
    <span class="n">cost_nmf</span> <span class="o">=</span> <span class="n">norm</span><span class="p">(</span><span class="n">Wtil</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">PX</span><span class="p">)</span> <span class="o">-</span> <span class="n">X</span><span class="p">,</span><span class="s1">&#39;fro&#39;</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="o">/</span><span class="mi">2</span>
    <span class="k">if</span> <span class="n">add_intercept</span><span class="p">:</span>
        <span class="c1"># used for the least-squares term</span>
        <span class="n">one_n</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
        <span class="n">PX</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="n">PX</span><span class="p">,</span><span class="n">one_n</span><span class="p">))</span>
        
        <span class="c1"># used in regularized ridge regression for w update</span>
        <span class="n">eye_r0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="n">r</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">eye_r0</span><span class="p">[</span><span class="n">r</span><span class="p">,</span><span class="n">r</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span> <span class="c1"># to avoid penalizing intercept term</span>
        
    <span class="n">cost_ls</span>  <span class="o">=</span> <span class="n">gam</span><span class="o">*</span><span class="n">norm</span><span class="p">(</span><span class="n">y</span> <span class="o">-</span> <span class="n">PX</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">w</span><span class="p">))</span> <span class="o">**</span><span class="mi">2</span><span class="o">/</span><span class="mi">2</span>
    <span class="n">cost</span> <span class="o">=</span> <span class="n">cost_nmf</span> <span class="o">+</span> <span class="n">cost_ls</span>

    <span class="n">cost_nmf_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">cost_nmf</span><span class="p">)</span>
    <span class="n">cost_ls_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">cost_ls</span><span class="p">)</span>
    <span class="n">cost_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">cost</span><span class="p">)</span>

    <span class="c1"># relative change in cost</span>
    <span class="n">diffcost</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="c1"># keep track of relative primal residual</span>
    <span class="n">res_W</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">res_P</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">res_H</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="c1"># also keep track of diffW</span>
<span class="c1">#    diffW = []</span>
    <span class="c1">#%%=== run admm iterations ===</span>
    <span class="n">eye_r</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="n">r</span><span class="p">)</span>
    
    <span class="c1"># precompute term needed for inversion lemma</span>
    <span class="n">K</span> <span class="o">=</span> <span class="n">solve</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="o">+</span> <span class="n">dot</span><span class="p">(</span><span class="n">X</span><span class="o">.</span><span class="n">T</span><span class="p">,</span><span class="n">X</span><span class="p">),</span> <span class="n">X</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>

    <span class="n">start</span><span class="o">=</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
    <span class="k">for</span> <span class="nb">iter</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">max_iter</span><span class="p">):</span>
        <span class="k">try</span><span class="p">:</span>
    <span class="c1">#        W_old = W #&lt;- to keep track of diffW</span>
    
            <span class="c1">#================ primal updates (P, W, H, Ptil, Wtil) ===============#</span>
            <span class="c1"># update for P involves inversion lemma...</span>
            <span class="n">_R</span> <span class="o">=</span> <span class="n">dot</span><span class="p">(</span><span class="n">X</span><span class="p">,</span><span class="n">Lam_H</span><span class="o">.</span><span class="n">T</span><span class="p">)</span><span class="o">/</span><span class="n">rho</span> <span class="o">-</span> <span class="n">Lam_P</span><span class="o">.</span><span class="n">T</span><span class="o">/</span><span class="n">rho</span> <span class="o">+</span> <span class="n">dot</span><span class="p">(</span><span class="n">X</span><span class="p">,</span><span class="n">H</span><span class="o">.</span><span class="n">T</span><span class="p">)</span> <span class="o">+</span> <span class="n">Ptil</span><span class="o">.</span><span class="n">T</span>
            <span class="n">P</span> <span class="o">=</span> <span class="p">(</span><span class="n">_R</span> <span class="o">-</span> <span class="n">X</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span> <span class="n">dot</span><span class="p">(</span><span class="n">K</span><span class="p">,</span><span class="n">_R</span><span class="p">)</span> <span class="p">))</span><span class="o">.</span><span class="n">T</span>
            <span class="n">Ptil</span> <span class="o">=</span> <span class="p">(</span><span class="n">P</span><span class="o">+</span><span class="n">Lam_P</span><span class="o">/</span><span class="n">rho</span><span class="p">)</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
    
            <span class="c1"># (W,H) updates</span>
            <span class="k">if</span> <span class="n">add_intercept</span><span class="p">:</span>
                <span class="n">ytil</span> <span class="o">=</span> <span class="n">y</span> <span class="o">-</span> <span class="n">one_n</span><span class="o">*</span><span class="n">w</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
                <span class="n">H</span> <span class="o">=</span> <span class="n">solve</span><span class="p">(</span><span class="n">dot</span><span class="p">(</span><span class="n">W</span><span class="o">.</span><span class="n">T</span><span class="p">,</span><span class="n">W</span><span class="p">)</span> <span class="o">+</span> <span class="n">rho</span><span class="o">*</span><span class="n">eye_r</span> <span class="o">+</span> <span class="n">gam</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">outer</span><span class="p">(</span><span class="n">w</span><span class="p">[:</span><span class="n">r</span><span class="p">],</span><span class="n">w</span><span class="p">[:</span><span class="n">r</span><span class="p">]),</span>
                      <span class="n">dot</span><span class="p">(</span><span class="n">W</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">X</span><span class="p">)</span> <span class="o">+</span> <span class="n">rho</span><span class="o">*</span><span class="n">dot</span><span class="p">(</span><span class="n">P</span><span class="p">,</span><span class="n">X</span><span class="p">)</span> <span class="o">-</span> <span class="n">Lam_H</span> <span class="o">+</span> <span class="n">gam</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">outer</span><span class="p">(</span><span class="n">w</span><span class="p">[:</span><span class="n">r</span><span class="p">],</span><span class="n">ytil</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">H</span> <span class="o">=</span> <span class="n">solve</span><span class="p">(</span><span class="n">dot</span><span class="p">(</span><span class="n">W</span><span class="o">.</span><span class="n">T</span><span class="p">,</span><span class="n">W</span><span class="p">)</span> <span class="o">+</span> <span class="n">rho</span><span class="o">*</span><span class="n">eye_r</span> <span class="o">+</span> <span class="n">gam</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">outer</span><span class="p">(</span><span class="n">w</span><span class="p">,</span><span class="n">w</span><span class="p">),</span>
                      <span class="n">dot</span><span class="p">(</span><span class="n">W</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">X</span><span class="p">)</span> <span class="o">+</span> <span class="n">rho</span><span class="o">*</span><span class="n">dot</span><span class="p">(</span><span class="n">P</span><span class="p">,</span><span class="n">X</span><span class="p">)</span> <span class="o">-</span> <span class="n">Lam_H</span> <span class="o">+</span> <span class="n">gam</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">outer</span><span class="p">(</span><span class="n">w</span><span class="p">,</span><span class="n">y</span><span class="p">))</span>
                      
            <span class="k">if</span> <span class="n">add_intercept</span><span class="p">:</span>
                <span class="c1"># H with intercept</span>
                <span class="n">H_</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="n">H</span><span class="p">,</span><span class="n">one_n</span><span class="p">))</span>
                <span class="c1"># for now, ignore gam2 regularizer...i never use them</span>
                <span class="c1">#w = solve( H_.dot(H_.T) , H_.dot(y))</span>
                <span class="c1"># regularized case</span>
                <span class="n">w</span> <span class="o">=</span> <span class="n">solve</span><span class="p">(</span> <span class="n">H_</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">H_</span><span class="o">.</span><span class="n">T</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="n">gam2</span><span class="o">/</span><span class="n">gam</span><span class="p">)</span><span class="o">*</span><span class="n">eye_r0</span><span class="p">,</span> <span class="n">H_</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">y</span><span class="p">))</span>
                
            <span class="k">else</span><span class="p">:</span>
                <span class="n">w</span> <span class="o">=</span> <span class="n">solve</span><span class="p">(</span> <span class="n">H</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">H</span><span class="o">.</span><span class="n">T</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="n">gam2</span><span class="o">/</span><span class="n">gam</span><span class="p">)</span><span class="o">*</span><span class="n">eye_r</span> <span class="p">,</span> <span class="n">H</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">y</span><span class="p">))</span>
    
            <span class="n">W</span> <span class="o">=</span> <span class="n">solve</span><span class="p">(</span><span class="n">dot</span><span class="p">(</span><span class="n">H</span><span class="p">,</span><span class="n">H</span><span class="o">.</span><span class="n">T</span><span class="p">)</span><span class="o">+</span><span class="n">rho</span><span class="o">*</span><span class="n">eye_r</span><span class="p">,</span> <span class="n">dot</span><span class="p">(</span><span class="n">H</span><span class="p">,</span> <span class="n">X</span><span class="o">.</span><span class="n">T</span><span class="p">)</span> <span class="o">+</span> <span class="n">rho</span><span class="o">*</span><span class="n">Wtil</span><span class="o">.</span><span class="n">T</span> <span class="o">-</span> <span class="n">Lam_W</span><span class="o">.</span><span class="n">T</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>
            <span class="n">Wtil</span> <span class="o">=</span> <span class="p">(</span><span class="n">W</span><span class="o">+</span><span class="n">Lam_W</span><span class="o">/</span><span class="n">rho</span><span class="p">)</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
    
            <span class="c1">#====================== dual updates =================================#</span>
            <span class="n">Lam_W</span> <span class="o">=</span> <span class="n">Lam_W</span> <span class="o">+</span> <span class="n">rho</span><span class="o">*</span><span class="p">(</span><span class="n">W</span> <span class="o">-</span> <span class="n">Wtil</span><span class="p">)</span>
            <span class="n">Lam_P</span> <span class="o">=</span> <span class="n">Lam_P</span> <span class="o">+</span> <span class="n">rho</span><span class="o">*</span><span class="p">(</span><span class="n">P</span> <span class="o">-</span> <span class="n">Ptil</span><span class="p">)</span>
            <span class="n">Lam_H</span> <span class="o">=</span> <span class="n">Lam_H</span> <span class="o">+</span> <span class="n">rho</span><span class="o">*</span><span class="p">(</span><span class="n">H</span> <span class="o">-</span> <span class="n">dot</span><span class="p">(</span><span class="n">P</span><span class="p">,</span><span class="n">X</span><span class="p">))</span>
    
            <span class="c1">#============ comptute objective values ==============================#</span>
            <span class="c1"># main loss function</span>
            <span class="n">PX</span> <span class="o">=</span> <span class="n">Ptil</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>
            <span class="n">cost_nmf</span> <span class="o">=</span> <span class="n">norm</span><span class="p">(</span><span class="n">Wtil</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">PX</span><span class="p">)</span> <span class="o">-</span> <span class="n">X</span><span class="p">,</span><span class="s1">&#39;fro&#39;</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="o">/</span><span class="mi">2</span>
            <span class="k">if</span> <span class="n">add_intercept</span><span class="p">:</span> <span class="c1"># for computing LS loss term</span>
                <span class="n">PX</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="n">PX</span><span class="p">,</span><span class="n">one_n</span><span class="p">))</span>
            <span class="n">cost_ls</span>  <span class="o">=</span> <span class="n">gam</span><span class="o">*</span><span class="n">norm</span><span class="p">(</span><span class="n">y</span> <span class="o">-</span> <span class="n">PX</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">w</span><span class="p">))</span> <span class="o">**</span><span class="mi">2</span><span class="o">/</span><span class="mi">2</span>
            <span class="n">cost</span> <span class="o">=</span> <span class="n">cost_nmf</span> <span class="o">+</span> <span class="n">cost_ls</span>
    
            <span class="n">cost_nmf_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">cost_nmf</span><span class="p">)</span>
            <span class="n">cost_ls_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">cost_ls</span><span class="p">)</span>
            <span class="n">cost_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">cost</span><span class="p">)</span>
    
            <span class="c1"># relative change in cost</span>
            <span class="n">diffcost</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">cost_list</span><span class="p">[</span><span class="nb">iter</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">cost_list</span><span class="p">[</span><span class="nb">iter</span><span class="p">])</span><span class="o">/</span><span class="n">cost_list</span><span class="p">[</span><span class="nb">iter</span><span class="p">])</span>
    
            <span class="c1"># relative primal residuals</span>
            <span class="n">res_W</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">norm</span><span class="p">(</span><span class="n">W</span><span class="o">-</span><span class="n">Wtil</span><span class="p">,</span><span class="s1">&#39;fro&#39;</span><span class="p">)</span><span class="o">/</span><span class="n">norm</span><span class="p">(</span><span class="n">W</span><span class="p">,</span><span class="s1">&#39;fro&#39;</span><span class="p">))</span>
            <span class="n">res_P</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">norm</span><span class="p">(</span><span class="n">P</span><span class="o">-</span><span class="n">Ptil</span><span class="p">,</span><span class="s1">&#39;fro&#39;</span><span class="p">)</span><span class="o">/</span><span class="n">norm</span><span class="p">(</span><span class="n">P</span><span class="p">,</span><span class="s1">&#39;fro&#39;</span><span class="p">))</span>
            <span class="n">res_H</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">norm</span><span class="p">(</span><span class="n">H</span><span class="o">-</span><span class="n">P</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">X</span><span class="p">),</span><span class="s1">&#39;fro&#39;</span><span class="p">)</span><span class="o">/</span><span class="n">norm</span><span class="p">(</span><span class="n">H</span><span class="p">,</span><span class="s1">&#39;fro&#39;</span><span class="p">))</span>
    
            <span class="c1"># relative change in basis matrix</span>
    <span class="c1">#        diffW.append( norm(W-W_old,&#39;fro&#39;)/ norm(W_old, &#39;fro&#39;) )</span>
    
            <span class="c1">#=== termination check ====#</span>
            <span class="n">check_exit</span>  <span class="o">=</span> <span class="p">(</span><span class="n">diffcost</span><span class="p">[</span><span class="nb">iter</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">tol</span><span class="p">)</span>
            <span class="n">check_exit</span> <span class="o">&amp;=</span> <span class="p">(</span><span class="n">res_W</span><span class="p">[</span><span class="nb">iter</span><span class="p">]</span> <span class="o">&lt;</span>  <span class="n">tol</span><span class="p">)</span>
            <span class="n">check_exit</span> <span class="o">&amp;=</span> <span class="p">(</span><span class="n">res_P</span><span class="p">[</span><span class="nb">iter</span><span class="p">]</span> <span class="o">&lt;</span>  <span class="n">tol</span><span class="p">)</span>
            <span class="n">check_exit</span> <span class="o">&amp;=</span> <span class="p">(</span><span class="n">res_H</span><span class="p">[</span><span class="nb">iter</span><span class="p">]</span> <span class="o">&lt;</span>  <span class="n">tol</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">check_exit</span> <span class="ow">and</span> <span class="nb">iter</span> <span class="o">&gt;</span> <span class="mi">300</span><span class="p">:</span> <span class="c1"># allow 300 iterations of &quot;burn-in&quot;</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">silence</span><span class="p">:</span>
                    <span class="k">print</span> <span class="s2">&quot;    Termination condition met.  Exit at iter =&quot;</span><span class="p">,</span><span class="nb">iter</span><span class="p">,</span>
                <span class="k">break</span>
            <span class="c1">#=============== print current progress ==============================#</span>
    <span class="c1">#        if iter % disp_freq == 0:</span>
            <span class="k">if</span> <span class="p">(</span><span class="nb">iter</span><span class="o">&gt;</span><span class="mi">1</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="nb">iter</span> <span class="o">%</span> <span class="n">disp_freq</span> <span class="o">==</span> <span class="mi">0</span><span class="p">):</span>
    <span class="c1">#            str_ = &quot;iter={:4} cost={:3.3f}&quot;.format(iter,cost_list[iter+1])</span>
                <span class="n">str_</span> <span class="o">=</span> <span class="s2">&quot;iter={:4} cost={:6.5e}&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">iter</span><span class="p">,</span><span class="n">cost_list</span><span class="p">[</span><span class="nb">iter</span><span class="o">+</span><span class="mi">1</span><span class="p">])</span>
                <span class="n">str_</span> <span class="o">+=</span> <span class="s2">&quot; nmf={:.2e}&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">cost_nmf_list</span><span class="p">[</span><span class="nb">iter</span><span class="o">+</span><span class="mi">1</span><span class="p">])</span>
                <span class="n">str_</span> <span class="o">+=</span> <span class="s2">&quot; ls={:.2e}&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">cost_ls_list</span><span class="p">[</span><span class="nb">iter</span><span class="o">+</span><span class="mi">1</span><span class="p">])</span>
                <span class="n">str_</span> <span class="o">+=</span> <span class="s2">&quot; diffcost={:3.2e}&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">diffcost</span><span class="p">[</span><span class="nb">iter</span><span class="p">])</span>
                <span class="n">str_</span> <span class="o">+=</span> <span class="s2">&quot; res_W={:3.2e}&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">res_W</span><span class="p">[</span><span class="nb">iter</span><span class="p">])</span>
                <span class="n">str_</span> <span class="o">+=</span> <span class="s2">&quot; res_P={:3.2e}&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">res_P</span><span class="p">[</span><span class="nb">iter</span><span class="p">])</span>
                <span class="n">str_</span> <span class="o">+=</span> <span class="s2">&quot; res_H={:3.2e}&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">res_H</span><span class="p">[</span><span class="nb">iter</span><span class="p">])</span>
    <span class="c1">#            str_ += &quot; diffW={:3.2e}&quot;.format(diffW[iter])</span>
                <span class="k">print</span> <span class="n">str_</span> <span class="o">+</span> <span class="s2">&quot; ({:3.1f} sec)&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span><span class="o">-</span><span class="n">start</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">KeyboardInterrupt</span><span class="p">:</span>
            <span class="k">break</span>
    <span class="c1">#%%---- end of admm for loop ---------------------------------------------#</span>
<span class="c1">#    cost_list = np.array(cost_list)</span>

    <span class="c1"># convert residual in pandas dataframe</span>
    <span class="n">cost</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">([</span><span class="n">cost_list</span><span class="p">,</span> <span class="n">cost_nmf_list</span><span class="p">,</span> <span class="n">cost_ls_list</span><span class="p">],</span>
                        <span class="n">index</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;total&#39;</span><span class="p">,</span><span class="s1">&#39;nmf&#39;</span><span class="p">,</span><span class="s1">&#39;ls&#39;</span><span class="p">])</span><span class="o">.</span><span class="n">T</span>
    <span class="n">res</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">([</span><span class="n">res_W</span><span class="p">,</span><span class="n">res_P</span><span class="p">,</span><span class="n">res_H</span><span class="p">,</span><span class="n">diffcost</span><span class="p">],</span>
                       <span class="n">index</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;res_W&#39;</span><span class="p">,</span><span class="s1">&#39;res_P&#39;</span><span class="p">,</span><span class="s1">&#39;res_H&#39;</span><span class="p">,</span><span class="s1">&#39;diffcost&#39;</span><span class="p">])</span><span class="o">.</span><span class="n">T</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">silence</span><span class="p">:</span> <span class="n">print_time</span><span class="p">(</span><span class="n">start</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">W</span><span class="p">,</span><span class="n">P</span><span class="p">,</span><span class="n">H</span><span class="p">,</span><span class="n">w</span><span class="p">,</span><span class="n">Wtil</span><span class="p">,</span><span class="n">Ptil</span><span class="p">,</span><span class="n">cost</span><span class="p">,</span><span class="n">res</span>

<span class="k">def</span> <span class="nf">ls_pnmf_admm_bal</span><span class="p">(</span><span class="n">X</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">r</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span><span class="n">gam</span><span class="o">=</span><span class="mf">1e-1</span><span class="p">,</span><span class="n">rho</span><span class="o">=</span><span class="mf">1e3</span><span class="p">,</span><span class="n">max_iter</span><span class="o">=</span><span class="mi">5000</span><span class="p">,</span><span class="n">tol</span><span class="o">=</span><span class="mf">1e-4</span><span class="p">,</span>
                 <span class="n">W_init</span><span class="o">=</span><span class="s1">&#39;nndsvd&#39;</span><span class="p">,</span><span class="n">disp_freq</span><span class="o">=</span><span class="mi">1000</span><span class="p">,</span><span class="n">silence</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span><span class="n">add_intercept</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Same as ``ls_pnmf_admm``, but with class-weighted loss</span>

<span class="sd">    &gt;&gt;&gt; W,P,H,Wtil,Ptil,cost_list,res = ls_pnmf_admm_bal(X,r,rho=1e2)</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    X : ndarray of shape (n_features, n_samples)=(p,n)</span>
<span class="sd">        Data matrix with columns as data points</span>
<span class="sd">    y : array-like of shape [n_samples,]</span>
<span class="sd">        Label vector</span>
<span class="sd">    r : int</span>
<span class="sd">        Dimension of the embedding space (n_components)</span>
<span class="sd">    rho : float</span>
<span class="sd">        Augmented Lagrangian parameter</span>
<span class="sd">    max_iter : int</span>
<span class="sd">        max number of iterations</span>
<span class="sd">    tol : float</span>
<span class="sd">        convergence tolerance (on relative change in objective value and</span>
<span class="sd">        all primal residuals)</span>
<span class="sd">    W_init : None, rng, or &#39;nndsvd&#39;</span>
<span class="sd">        Way to initialize W (and H).  If ``None`` or ``RandomState object``</span>
<span class="sd">        is supplied, both W and H will be initialized via non-negative</span>
<span class="sd">        random number.  If ``&#39;nndsvd&#39;``, will use deterministic initialization</span>
<span class="sd">        NNDSVD &quot;Non-Negative Double Singular Value Decomposition&quot;, proposed by</span>
<span class="sd">        Boutsidis2008.</span>
<span class="sd">    disp_freq : int</span>
<span class="sd">        Frequency of update display (in iterations)</span>
<span class="sd">    silence : bool</span>
<span class="sd">        If True, don&#39;t print-out convergence detail at the end.</span>
<span class="sd">    add_intercept : bool (default=False)</span>
<span class="sd">        Add intercept term to classifier (added 02/17/2016)</span>

<span class="sd">    Update history</span>
<span class="sd">    --------------</span>
<span class="sd">    **02/17/2016** - created</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">p</span><span class="p">,</span><span class="n">n</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">shape</span>
    <span class="n">rho</span> <span class="o">*=</span> <span class="mf">1.</span>
    <span class="n">gam</span> <span class="o">*=</span> <span class="mf">1.</span><span class="c1"># &lt;- ensure float</span>
    <span class="c1">#%% get class balance info</span>
    <span class="n">weight_pos</span> <span class="o">=</span> <span class="mf">1.</span><span class="o">*</span><span class="p">(</span><span class="n">y</span><span class="o">==-</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span><span class="o">/</span><span class="n">n</span>
    <span class="n">weight_neg</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">weight_pos</span>
    <span class="n">weight_vec</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
    <span class="n">weight_vec</span><span class="p">[</span><span class="n">y</span><span class="o">==+</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">weight_pos</span>
    <span class="n">weight_vec</span><span class="p">[</span><span class="n">y</span><span class="o">==-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">weight_neg</span>
    <span class="n">J</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span> <span class="n">weight_vec</span> <span class="p">)</span>
    <span class="c1">#%%=== initialize variables =====</span>
    <span class="c1"># define main primal variable W (basis matrix)</span>
    <span class="k">if</span> <span class="n">W_init</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
        <span class="n">W</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="n">p</span><span class="p">,</span><span class="n">r</span><span class="p">)</span>
        <span class="n">W</span> <span class="o">/=</span> <span class="n">norm</span><span class="p">(</span><span class="n">W</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>

        <span class="n">H</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="n">r</span><span class="p">,</span><span class="n">n</span><span class="p">)</span>
        <span class="n">H</span> <span class="o">/=</span> <span class="n">norm</span><span class="p">(</span><span class="n">H</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">W_init</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">RandomState</span><span class="p">):</span>
        <span class="n">rng</span> <span class="o">=</span> <span class="n">W_init</span>

        <span class="n">W</span> <span class="o">=</span> <span class="n">rng</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="n">p</span><span class="p">,</span><span class="n">r</span><span class="p">)</span>
        <span class="n">W</span> <span class="o">/=</span> <span class="n">norm</span><span class="p">(</span><span class="n">W</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>

        <span class="n">H</span> <span class="o">=</span> <span class="n">rng</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="n">r</span><span class="p">,</span><span class="n">n</span><span class="p">)</span>
        <span class="n">H</span> <span class="o">/=</span> <span class="n">norm</span><span class="p">(</span><span class="n">H</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">W_init</span> <span class="o">==</span> <span class="s1">&#39;nndsvd&#39;</span><span class="p">:</span>
<span class="c1">#        W = nnd_svd(X,r)</span>
        <span class="n">W</span><span class="p">,</span><span class="n">H</span> <span class="o">=</span> <span class="n">nnd_svd</span><span class="p">(</span><span class="n">X</span><span class="p">,</span><span class="n">r</span><span class="p">,</span><span class="n">get_H</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Invalid input for &quot;W_init&quot;&#39;</span><span class="p">)</span>

    <span class="n">P</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">r</span><span class="p">,</span><span class="n">p</span><span class="p">))</span>
<span class="c1">#    P = np.random.rand(r,p)</span>

    <span class="k">if</span> <span class="n">add_intercept</span><span class="p">:</span>
        <span class="n">w</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">r</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="c1"># &lt;- classification vector</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">w</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">r</span><span class="p">)</span> <span class="c1"># &lt;- classification vector</span>

    <span class="c1"># aux. variables</span>
    <span class="n">Wtil</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">W</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
    <span class="n">Ptil</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">P</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>

    <span class="c1"># dual variables</span>
    <span class="n">Lam_W</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">W</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
    <span class="n">Lam_P</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">P</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
    <span class="n">Lam_H</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">H</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>


    <span class="c1">#%%=== create empty lists for tracking updates ===</span>
    <span class="c1"># keep track of frobenius norm loss</span>
    <span class="n">cost_list</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">cost_nmf_list</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">cost_ls_list</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="n">PX</span> <span class="o">=</span> <span class="n">Ptil</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>
    <span class="n">cost_nmf</span> <span class="o">=</span> <span class="n">norm</span><span class="p">(</span><span class="n">Wtil</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">PX</span><span class="p">)</span> <span class="o">-</span> <span class="n">X</span><span class="p">,</span><span class="s1">&#39;fro&#39;</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="o">/</span><span class="mi">2</span>
    <span class="k">if</span> <span class="n">add_intercept</span><span class="p">:</span>
        <span class="c1"># used for the least-squares term</span>
        <span class="n">one_n</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
        <span class="n">PX</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="n">PX</span><span class="p">,</span><span class="n">one_n</span><span class="p">))</span>
    <span class="c1"># compute weighted error</span>
    <span class="n">_err</span> <span class="o">=</span> <span class="p">(</span><span class="n">y</span><span class="o">-</span><span class="n">PX</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">w</span><span class="p">))</span>
    <span class="n">_err</span> <span class="o">=</span> <span class="n">_err</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span> <span class="n">J</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">_err</span><span class="p">))</span>
    <span class="n">cost_ls</span>  <span class="o">=</span> <span class="n">gam</span><span class="o">*</span><span class="n">_err</span><span class="o">/</span><span class="mi">2</span>
    <span class="c1">#cost_ls  = gam*norm(y - PX.T.dot(w)) **2/2</span>
    <span class="n">cost</span> <span class="o">=</span> <span class="n">cost_nmf</span> <span class="o">+</span> <span class="n">cost_ls</span>

    <span class="n">cost_nmf_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">cost_nmf</span><span class="p">)</span>
    <span class="n">cost_ls_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">cost_ls</span><span class="p">)</span>
    <span class="n">cost_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">cost</span><span class="p">)</span>

    <span class="c1"># relative change in cost</span>
    <span class="n">diffcost</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="c1"># keep track of relative primal residual</span>
    <span class="n">res_W</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">res_P</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">res_H</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="c1"># also keep track of diffW</span>
<span class="c1">#    diffW = []</span>
    <span class="c1">#%%=== run admm iterations ===</span>
    <span class="n">eye_r</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="n">r</span><span class="p">)</span>

    <span class="c1"># precompute term needed for inversion lemma</span>
    <span class="n">K</span> <span class="o">=</span> <span class="n">solve</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="o">+</span> <span class="n">dot</span><span class="p">(</span><span class="n">X</span><span class="o">.</span><span class="n">T</span><span class="p">,</span><span class="n">X</span><span class="p">),</span> <span class="n">X</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>

    <span class="n">start</span><span class="o">=</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
    <span class="k">for</span> <span class="nb">iter</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">max_iter</span><span class="p">):</span>
<span class="c1">#        W_old = W #&lt;- to keep track of diffW</span>

        <span class="c1">#================ primal updates (P, W, H, Ptil, Wtil) ===============#</span>
        <span class="c1"># update for P involves inversion lemma...</span>
        <span class="n">_R</span> <span class="o">=</span> <span class="n">dot</span><span class="p">(</span><span class="n">X</span><span class="p">,</span><span class="n">Lam_H</span><span class="o">.</span><span class="n">T</span><span class="p">)</span><span class="o">/</span><span class="n">rho</span> <span class="o">-</span> <span class="n">Lam_P</span><span class="o">.</span><span class="n">T</span><span class="o">/</span><span class="n">rho</span> <span class="o">+</span> <span class="n">dot</span><span class="p">(</span><span class="n">X</span><span class="p">,</span><span class="n">H</span><span class="o">.</span><span class="n">T</span><span class="p">)</span> <span class="o">+</span> <span class="n">Ptil</span><span class="o">.</span><span class="n">T</span>
        <span class="n">P</span> <span class="o">=</span> <span class="p">(</span><span class="n">_R</span> <span class="o">-</span> <span class="n">X</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span> <span class="n">dot</span><span class="p">(</span><span class="n">K</span><span class="p">,</span><span class="n">_R</span><span class="p">)</span> <span class="p">))</span><span class="o">.</span><span class="n">T</span>
        <span class="n">Ptil</span> <span class="o">=</span> <span class="p">(</span><span class="n">P</span><span class="o">+</span><span class="n">Lam_P</span><span class="o">/</span><span class="n">rho</span><span class="p">)</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>

        <span class="c1"># (W,H) updates</span>
        <span class="n">WtW</span> <span class="o">=</span> <span class="n">dot</span><span class="p">(</span><span class="n">W</span><span class="o">.</span><span class="n">T</span><span class="p">,</span><span class="n">W</span><span class="p">)</span> <span class="o">+</span> <span class="n">rho</span><span class="o">*</span><span class="n">eye_r</span>
        <span class="k">if</span> <span class="n">add_intercept</span><span class="p">:</span>
            <span class="n">ytil</span> <span class="o">=</span> <span class="n">y</span> <span class="o">-</span> <span class="n">one_n</span><span class="o">*</span><span class="n">w</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">_S</span> <span class="o">=</span> <span class="n">dot</span><span class="p">(</span><span class="n">W</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">X</span><span class="p">)</span> <span class="o">+</span> <span class="n">rho</span><span class="o">*</span><span class="n">dot</span><span class="p">(</span><span class="n">P</span><span class="p">,</span><span class="n">X</span><span class="p">)</span> <span class="o">-</span> <span class="n">Lam_H</span> <span class="o">+</span> <span class="n">gam</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">outer</span><span class="p">(</span><span class="n">w</span><span class="p">[:</span><span class="n">r</span><span class="p">],</span><span class="n">ytil</span><span class="p">)</span>
            <span class="n">wtw</span> <span class="o">=</span> <span class="n">gam</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">outer</span><span class="p">(</span><span class="n">w</span><span class="p">[:</span><span class="n">r</span><span class="p">],</span><span class="n">w</span><span class="p">[:</span><span class="n">r</span><span class="p">])</span>
            <span class="c1">#H = solve(dot(W.T,W) + rho*eye_r + gam*np.outer(w[:r],w[:r]),_S)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">_S</span> <span class="o">=</span> <span class="n">dot</span><span class="p">(</span><span class="n">W</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">X</span><span class="p">)</span> <span class="o">+</span> <span class="n">rho</span><span class="o">*</span><span class="n">dot</span><span class="p">(</span><span class="n">P</span><span class="p">,</span><span class="n">X</span><span class="p">)</span> <span class="o">-</span> <span class="n">Lam_H</span> <span class="o">+</span> <span class="n">gam</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">outer</span><span class="p">(</span><span class="n">w</span><span class="p">,</span><span class="n">y</span><span class="p">)</span>
            <span class="n">wtw</span> <span class="o">=</span> <span class="n">gam</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">outer</span><span class="p">(</span><span class="n">w</span><span class="p">,</span><span class="n">w</span><span class="p">)</span>
            <span class="c1">#H = solve(dot(W.T,W) + rho*eye_r + gam*np.outer(w,w),_S)</span>

        <span class="n">H</span><span class="p">[:,</span><span class="n">y</span><span class="o">==+</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">solve</span><span class="p">(</span><span class="n">WtW</span> <span class="o">+</span> <span class="n">weight_pos</span><span class="o">*</span><span class="n">wtw</span><span class="p">,</span> <span class="n">_S</span><span class="p">[:,</span><span class="n">y</span><span class="o">==+</span><span class="mi">1</span><span class="p">])</span>
        <span class="n">H</span><span class="p">[:,</span><span class="n">y</span><span class="o">==-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">solve</span><span class="p">(</span><span class="n">WtW</span> <span class="o">+</span> <span class="n">weight_neg</span><span class="o">*</span><span class="n">wtw</span><span class="p">,</span> <span class="n">_S</span><span class="p">[:,</span><span class="n">y</span><span class="o">==-</span><span class="mi">1</span><span class="p">])</span>

        <span class="k">if</span> <span class="n">add_intercept</span><span class="p">:</span>
            <span class="c1"># H with intercept</span>
            <span class="n">H_</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="n">H</span><span class="p">,</span><span class="n">one_n</span><span class="p">))</span>
            <span class="c1"># for now, ignore gam2 regularizer...i never use them</span>
            <span class="n">w</span> <span class="o">=</span> <span class="n">solve</span><span class="p">(</span> <span class="n">H_</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">J</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">H_</span><span class="o">.</span><span class="n">T</span><span class="p">)),</span> <span class="n">H_</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">J</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">y</span><span class="p">)))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">w</span> <span class="o">=</span> <span class="n">solve</span><span class="p">(</span> <span class="n">H</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">J</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">H</span><span class="o">.</span><span class="n">T</span><span class="p">))</span> <span class="p">,</span> <span class="n">H</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">J</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">y</span><span class="p">)))</span>

        <span class="n">W</span> <span class="o">=</span> <span class="n">solve</span><span class="p">(</span><span class="n">dot</span><span class="p">(</span><span class="n">H</span><span class="p">,</span><span class="n">H</span><span class="o">.</span><span class="n">T</span><span class="p">)</span><span class="o">+</span><span class="n">rho</span><span class="o">*</span><span class="n">eye_r</span><span class="p">,</span> <span class="n">dot</span><span class="p">(</span><span class="n">H</span><span class="p">,</span> <span class="n">X</span><span class="o">.</span><span class="n">T</span><span class="p">)</span> <span class="o">+</span> <span class="n">rho</span><span class="o">*</span><span class="n">Wtil</span><span class="o">.</span><span class="n">T</span> <span class="o">-</span> <span class="n">Lam_W</span><span class="o">.</span><span class="n">T</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>
        <span class="n">Wtil</span> <span class="o">=</span> <span class="p">(</span><span class="n">W</span><span class="o">+</span><span class="n">Lam_W</span><span class="o">/</span><span class="n">rho</span><span class="p">)</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>

        <span class="c1">#====================== dual updates =================================#</span>
        <span class="n">Lam_W</span> <span class="o">=</span> <span class="n">Lam_W</span> <span class="o">+</span> <span class="n">rho</span><span class="o">*</span><span class="p">(</span><span class="n">W</span> <span class="o">-</span> <span class="n">Wtil</span><span class="p">)</span>
        <span class="n">Lam_P</span> <span class="o">=</span> <span class="n">Lam_P</span> <span class="o">+</span> <span class="n">rho</span><span class="o">*</span><span class="p">(</span><span class="n">P</span> <span class="o">-</span> <span class="n">Ptil</span><span class="p">)</span>
        <span class="n">Lam_H</span> <span class="o">=</span> <span class="n">Lam_H</span> <span class="o">+</span> <span class="n">rho</span><span class="o">*</span><span class="p">(</span><span class="n">H</span> <span class="o">-</span> <span class="n">dot</span><span class="p">(</span><span class="n">P</span><span class="p">,</span><span class="n">X</span><span class="p">))</span>

        <span class="c1">#============ comptute objective values ==============================#</span>
        <span class="c1"># main loss function</span>
        <span class="n">PX</span> <span class="o">=</span> <span class="n">Ptil</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>
        <span class="n">cost_nmf</span> <span class="o">=</span> <span class="n">norm</span><span class="p">(</span><span class="n">Wtil</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">PX</span><span class="p">)</span> <span class="o">-</span> <span class="n">X</span><span class="p">,</span><span class="s1">&#39;fro&#39;</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="o">/</span><span class="mi">2</span>
        <span class="k">if</span> <span class="n">add_intercept</span><span class="p">:</span> <span class="c1"># for computing LS loss term</span>
            <span class="n">PX</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="n">PX</span><span class="p">,</span><span class="n">one_n</span><span class="p">))</span>
        <span class="c1"># compute weighted error</span>
        <span class="n">_err</span> <span class="o">=</span> <span class="p">(</span><span class="n">y</span><span class="o">-</span><span class="n">PX</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">w</span><span class="p">))</span>
        <span class="n">_err</span> <span class="o">=</span> <span class="n">_err</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span> <span class="n">J</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">_err</span><span class="p">))</span>
        <span class="n">cost_ls</span>  <span class="o">=</span> <span class="n">gam</span><span class="o">*</span><span class="n">_err</span><span class="o">/</span><span class="mi">2</span>
        <span class="c1">#cost_ls  = gam*norm(y - PX.T.dot(w)) **2/2</span>
        <span class="n">cost</span> <span class="o">=</span> <span class="n">cost_nmf</span> <span class="o">+</span> <span class="n">cost_ls</span>

        <span class="n">cost_nmf_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">cost_nmf</span><span class="p">)</span>
        <span class="n">cost_ls_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">cost_ls</span><span class="p">)</span>
        <span class="n">cost_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">cost</span><span class="p">)</span>

        <span class="c1"># relative change in cost</span>
        <span class="n">diffcost</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">cost_list</span><span class="p">[</span><span class="nb">iter</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">cost_list</span><span class="p">[</span><span class="nb">iter</span><span class="p">])</span><span class="o">/</span><span class="n">cost_list</span><span class="p">[</span><span class="nb">iter</span><span class="p">])</span>

        <span class="c1"># relative primal residuals</span>
        <span class="n">res_W</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">norm</span><span class="p">(</span><span class="n">W</span><span class="o">-</span><span class="n">Wtil</span><span class="p">,</span><span class="s1">&#39;fro&#39;</span><span class="p">)</span><span class="o">/</span><span class="n">norm</span><span class="p">(</span><span class="n">W</span><span class="p">,</span><span class="s1">&#39;fro&#39;</span><span class="p">))</span>
        <span class="n">res_P</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">norm</span><span class="p">(</span><span class="n">P</span><span class="o">-</span><span class="n">Ptil</span><span class="p">,</span><span class="s1">&#39;fro&#39;</span><span class="p">)</span><span class="o">/</span><span class="n">norm</span><span class="p">(</span><span class="n">P</span><span class="p">,</span><span class="s1">&#39;fro&#39;</span><span class="p">))</span>
        <span class="n">res_H</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">norm</span><span class="p">(</span><span class="n">H</span><span class="o">-</span><span class="n">P</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">X</span><span class="p">),</span><span class="s1">&#39;fro&#39;</span><span class="p">)</span><span class="o">/</span><span class="n">norm</span><span class="p">(</span><span class="n">H</span><span class="p">,</span><span class="s1">&#39;fro&#39;</span><span class="p">))</span>

        <span class="c1"># relative change in basis matrix</span>
<span class="c1">#        diffW.append( norm(W-W_old,&#39;fro&#39;)/ norm(W_old, &#39;fro&#39;) )</span>

        <span class="c1">#=== termination check ====#</span>
        <span class="n">check_exit</span>  <span class="o">=</span> <span class="p">(</span><span class="n">diffcost</span><span class="p">[</span><span class="nb">iter</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">tol</span><span class="p">)</span>
        <span class="n">check_exit</span> <span class="o">&amp;=</span> <span class="p">(</span><span class="n">res_W</span><span class="p">[</span><span class="nb">iter</span><span class="p">]</span> <span class="o">&lt;</span>  <span class="n">tol</span><span class="p">)</span>
        <span class="n">check_exit</span> <span class="o">&amp;=</span> <span class="p">(</span><span class="n">res_P</span><span class="p">[</span><span class="nb">iter</span><span class="p">]</span> <span class="o">&lt;</span>  <span class="n">tol</span><span class="p">)</span>
        <span class="n">check_exit</span> <span class="o">&amp;=</span> <span class="p">(</span><span class="n">res_H</span><span class="p">[</span><span class="nb">iter</span><span class="p">]</span> <span class="o">&lt;</span>  <span class="n">tol</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">check_exit</span> <span class="ow">and</span> <span class="nb">iter</span> <span class="o">&gt;</span> <span class="mi">300</span><span class="p">:</span> <span class="c1"># allow 300 iterations of &quot;burn-in&quot;</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">silence</span><span class="p">:</span>
                <span class="k">print</span> <span class="s2">&quot;    Termination condition met.  Exit at iter =&quot;</span><span class="p">,</span><span class="nb">iter</span><span class="p">,</span>
            <span class="k">break</span>
        <span class="c1">#=============== print current progress ==============================#</span>
<span class="c1">#        if iter % disp_freq == 0:</span>
        <span class="k">if</span> <span class="p">(</span><span class="nb">iter</span><span class="o">&gt;</span><span class="mi">1</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="nb">iter</span> <span class="o">%</span> <span class="n">disp_freq</span> <span class="o">==</span> <span class="mi">0</span><span class="p">):</span>
<span class="c1">#            str_ = &quot;iter={:4} cost={:3.3f}&quot;.format(iter,cost_list[iter+1])</span>
            <span class="n">str_</span> <span class="o">=</span> <span class="s2">&quot;iter={:4} cost={:6.5e}&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">iter</span><span class="p">,</span><span class="n">cost_list</span><span class="p">[</span><span class="nb">iter</span><span class="o">+</span><span class="mi">1</span><span class="p">])</span>
            <span class="n">str_</span> <span class="o">+=</span> <span class="s2">&quot; nmf={:.2e}&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">cost_nmf_list</span><span class="p">[</span><span class="nb">iter</span><span class="o">+</span><span class="mi">1</span><span class="p">])</span>
            <span class="n">str_</span> <span class="o">+=</span> <span class="s2">&quot; ls={:.2e}&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">cost_ls_list</span><span class="p">[</span><span class="nb">iter</span><span class="o">+</span><span class="mi">1</span><span class="p">])</span>
            <span class="n">str_</span> <span class="o">+=</span> <span class="s2">&quot; diffcost={:3.2e}&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">diffcost</span><span class="p">[</span><span class="nb">iter</span><span class="p">])</span>
            <span class="n">str_</span> <span class="o">+=</span> <span class="s2">&quot; res_W={:3.2e}&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">res_W</span><span class="p">[</span><span class="nb">iter</span><span class="p">])</span>
            <span class="n">str_</span> <span class="o">+=</span> <span class="s2">&quot; res_P={:3.2e}&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">res_P</span><span class="p">[</span><span class="nb">iter</span><span class="p">])</span>
            <span class="n">str_</span> <span class="o">+=</span> <span class="s2">&quot; res_H={:3.2e}&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">res_H</span><span class="p">[</span><span class="nb">iter</span><span class="p">])</span>
<span class="c1">#            str_ += &quot; diffW={:3.2e}&quot;.format(diffW[iter])</span>
            <span class="k">print</span> <span class="n">str_</span> <span class="o">+</span> <span class="s2">&quot; ({:3.1f} sec)&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span><span class="o">-</span><span class="n">start</span><span class="p">)</span>
    <span class="c1">#%%---- end of admm for loop ---------------------------------------------#</span>
<span class="c1">#    cost_list = np.array(cost_list)</span>

    <span class="c1"># convert residual in pandas dataframe</span>
    <span class="n">cost</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">([</span><span class="n">cost_list</span><span class="p">,</span> <span class="n">cost_nmf_list</span><span class="p">,</span> <span class="n">cost_ls_list</span><span class="p">],</span>
                        <span class="n">index</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;total&#39;</span><span class="p">,</span><span class="s1">&#39;nmf&#39;</span><span class="p">,</span><span class="s1">&#39;ls&#39;</span><span class="p">])</span><span class="o">.</span><span class="n">T</span>
    <span class="n">res</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">([</span><span class="n">res_W</span><span class="p">,</span><span class="n">res_P</span><span class="p">,</span><span class="n">res_H</span><span class="p">,</span><span class="n">diffcost</span><span class="p">],</span>
                       <span class="n">index</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;res_W&#39;</span><span class="p">,</span><span class="s1">&#39;res_P&#39;</span><span class="p">,</span><span class="s1">&#39;res_H&#39;</span><span class="p">,</span><span class="s1">&#39;diffcost&#39;</span><span class="p">])</span><span class="o">.</span><span class="n">T</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">silence</span><span class="p">:</span> <span class="n">print_time</span><span class="p">(</span><span class="n">start</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">W</span><span class="p">,</span><span class="n">P</span><span class="p">,</span><span class="n">H</span><span class="p">,</span><span class="n">w</span><span class="p">,</span><span class="n">Wtil</span><span class="p">,</span><span class="n">Ptil</span><span class="p">,</span><span class="n">cost</span><span class="p">,</span><span class="n">res</span>


<span class="k">def</span> <span class="nf">ls_spnmf_admm</span><span class="p">(</span><span class="n">X</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">r</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span><span class="n">gam</span><span class="o">=</span><span class="mf">1e-1</span><span class="p">,</span><span class="n">rho</span><span class="o">=</span><span class="mf">1e3</span><span class="p">,</span><span class="n">max_iter</span><span class="o">=</span><span class="mi">5000</span><span class="p">,</span><span class="n">tol</span><span class="o">=</span><span class="mf">1e-4</span><span class="p">,</span>
                  <span class="n">W_init</span><span class="o">=</span><span class="s1">&#39;nndsvd&#39;</span><span class="p">,</span><span class="n">disp_freq</span><span class="o">=</span><span class="mi">2000</span><span class="p">,</span><span class="n">silence</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span>
                  <span class="n">constraint</span><span class="o">=</span><span class="s1">&#39;stiefel&#39;</span><span class="p">,</span><span class="n">gam2</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span><span class="n">add_intercept</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Projective NMF using ADMM.  gam2 = regularizer for classifier</span>

<span class="sd">    &gt;&gt;&gt; W,P,H,w,Wtil,Ptil,cost,res = pnmf_admm(X,r,rho=1e2)</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    X : ndarray of shape (n_features, n_samples)=(p,n)</span>
<span class="sd">        Data matrix with columns as data points</span>
<span class="sd">    y : array-like of shape [n_samples,]</span>
<span class="sd">        Label vector</span>
<span class="sd">    r : int</span>
<span class="sd">        Dimension of the embedding space (n_components)</span>
<span class="sd">    rho : float</span>
<span class="sd">        Augmented Lagrangian parameter</span>
<span class="sd">    max_iter : int</span>
<span class="sd">        max number of iterations</span>
<span class="sd">    tol : float</span>
<span class="sd">        convergence tolerance (on relative change in objective value and</span>
<span class="sd">        all primal residuals)</span>
<span class="sd">    W_init : None, rng, or &#39;nndsvd&#39;</span>
<span class="sd">        Way to initialize W (and H).  If ``None`` or ``RandomState object``</span>
<span class="sd">        is supplied, both W and H will be initialized via non-negative</span>
<span class="sd">        random number.  If ``&#39;nndsvd&#39;``, will use deterministic initialization</span>
<span class="sd">        NNDSVD &quot;Non-Negative Double Singular Value Decomposition&quot;, proposed by</span>
<span class="sd">        Boutsidis2008.</span>
<span class="sd">    disp_freq : int</span>
<span class="sd">        Frequency of update display (in iterations)</span>
<span class="sd">    silence : bool</span>
<span class="sd">        If True, don&#39;t print-out convergence detail at the end.</span>
<span class="sd">    add_intercept : bool (default=False)</span>
<span class="sd">        Add intercept term to classifier (added 02/17/2016)</span>

<span class="sd">    Update history</span>
<span class="sd">    --------------</span>
<span class="sd">    **02/02/2016** - created but dirty code</span>

<span class="sd">    **02/03/2016** - Added regularizer    ``gam2``</span>

<span class="sd">    **02/17/2016** - added ``add_intercept`` option</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">p</span><span class="p">,</span><span class="n">n</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">shape</span>
    <span class="n">rho</span> <span class="o">*=</span> <span class="mf">1.</span>
    <span class="n">gam</span> <span class="o">*=</span> <span class="mf">1.</span><span class="c1"># &lt;- ensure float</span>
    <span class="n">gam2</span> <span class="o">*=</span> <span class="mf">1.</span><span class="c1"># &lt;- ensure float</span>
    <span class="c1">#%%=== initialize variables =====</span>
    <span class="c1"># define main primal variable W (basis matrix)</span>
    <span class="k">if</span> <span class="n">W_init</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
        <span class="n">W</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="n">p</span><span class="p">,</span><span class="n">r</span><span class="p">)</span>
        <span class="n">W</span> <span class="o">/=</span> <span class="n">norm</span><span class="p">(</span><span class="n">W</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>

        <span class="n">H</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="n">r</span><span class="p">,</span><span class="n">n</span><span class="p">)</span>
        <span class="n">H</span> <span class="o">/=</span> <span class="n">norm</span><span class="p">(</span><span class="n">H</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">W_init</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">RandomState</span><span class="p">):</span>
        <span class="n">rng</span> <span class="o">=</span> <span class="n">W_init</span>

        <span class="n">W</span> <span class="o">=</span> <span class="n">rng</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="n">p</span><span class="p">,</span><span class="n">r</span><span class="p">)</span>
        <span class="n">W</span> <span class="o">/=</span> <span class="n">norm</span><span class="p">(</span><span class="n">W</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>

        <span class="n">H</span> <span class="o">=</span> <span class="n">rng</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="n">r</span><span class="p">,</span><span class="n">n</span><span class="p">)</span>
        <span class="n">H</span> <span class="o">/=</span> <span class="n">norm</span><span class="p">(</span><span class="n">H</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">W_init</span> <span class="o">==</span> <span class="s1">&#39;nndsvd&#39;</span><span class="p">:</span>
<span class="c1">#        W = nnd_svd(X,r)</span>
        <span class="n">W</span><span class="p">,</span><span class="n">H</span> <span class="o">=</span> <span class="n">nnd_svd</span><span class="p">(</span><span class="n">X</span><span class="p">,</span><span class="n">r</span><span class="p">,</span><span class="n">get_H</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Invalid input for &quot;W_init&quot;&#39;</span><span class="p">)</span>

    <span class="n">P</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">r</span><span class="p">,</span><span class="n">p</span><span class="p">))</span>
<span class="c1">#    P = np.random.rand(r,p)</span>

    <span class="k">if</span> <span class="n">add_intercept</span><span class="p">:</span>
        <span class="n">w</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">r</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="c1"># &lt;- classification vector</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">w</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">r</span><span class="p">)</span> <span class="c1"># &lt;- classification vector</span>

    <span class="c1"># aux. variables</span>
    <span class="n">Wtil</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">W</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
    <span class="n">W2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">W</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
    <span class="n">Ptil</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">P</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>

    <span class="c1"># dual variables</span>
    <span class="n">Lam_W</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">W</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
    <span class="n">Lam_W2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">W</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
    <span class="n">Lam_P</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">P</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
    <span class="n">Lam_H</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">H</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>


    <span class="c1">#%%=== create empty lists for tracking updates ===</span>
    <span class="c1"># keep track of frobenius norm loss</span>
    <span class="n">cost_list</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">cost_nmf_list</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">cost_ls_list</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="n">PX</span> <span class="o">=</span> <span class="n">Ptil</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>
    <span class="n">cost_nmf</span> <span class="o">=</span> <span class="n">norm</span><span class="p">(</span><span class="n">Wtil</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">PX</span><span class="p">)</span> <span class="o">-</span> <span class="n">X</span><span class="p">,</span><span class="s1">&#39;fro&#39;</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="o">/</span><span class="mi">2</span>
    <span class="k">if</span> <span class="n">add_intercept</span><span class="p">:</span>
        <span class="c1"># used for the least-squares term</span>
        <span class="n">one_n</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
        <span class="n">PX</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="n">PX</span><span class="p">,</span><span class="n">one_n</span><span class="p">))</span>
    <span class="n">cost_ls</span>  <span class="o">=</span> <span class="n">gam</span><span class="o">*</span><span class="n">norm</span><span class="p">(</span><span class="n">y</span> <span class="o">-</span> <span class="n">PX</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">w</span><span class="p">))</span> <span class="o">**</span><span class="mi">2</span><span class="o">/</span><span class="mi">2</span> <span class="o">+</span> <span class="n">gam2</span><span class="o">*</span><span class="n">norm</span><span class="p">(</span><span class="n">w</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="o">/</span><span class="mi">2</span>
    <span class="n">cost</span> <span class="o">=</span> <span class="n">cost_nmf</span> <span class="o">+</span> <span class="n">cost_ls</span>

    <span class="n">cost_nmf_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">cost_nmf</span><span class="p">)</span>
    <span class="n">cost_ls_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">cost_ls</span><span class="p">)</span>
    <span class="n">cost_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">cost</span><span class="p">)</span>

    <span class="c1"># relative change in cost</span>
    <span class="n">diffcost</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="c1"># keep track of relative primal residual</span>
    <span class="n">res_W</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">res_W2</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">res_P</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">res_H</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="c1"># also keep track of diffW</span>
<span class="c1">#    diffW = []</span>
    <span class="c1">#%%=== run admm iterations ===</span>
    <span class="n">eye_r</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="n">r</span><span class="p">)</span>

    <span class="c1"># precompute term needed for inversion lemma</span>
    <span class="n">K</span> <span class="o">=</span> <span class="n">solve</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="o">+</span> <span class="n">dot</span><span class="p">(</span><span class="n">X</span><span class="o">.</span><span class="n">T</span><span class="p">,</span><span class="n">X</span><span class="p">),</span> <span class="n">X</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>

    <span class="n">start</span><span class="o">=</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
    <span class="k">for</span> <span class="nb">iter</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">max_iter</span><span class="p">):</span>
<span class="c1">#        W_old = W #&lt;- to keep track of diffW</span>

        <span class="c1">#================ primal updates (P, W, H, Ptil, Wtil) ===============#</span>
        <span class="c1"># update for P involves inversion lemma...</span>
        <span class="n">_R</span> <span class="o">=</span> <span class="n">dot</span><span class="p">(</span><span class="n">X</span><span class="p">,</span><span class="n">Lam_H</span><span class="o">.</span><span class="n">T</span><span class="p">)</span><span class="o">/</span><span class="n">rho</span> <span class="o">-</span> <span class="n">Lam_P</span><span class="o">.</span><span class="n">T</span><span class="o">/</span><span class="n">rho</span> <span class="o">+</span> <span class="n">dot</span><span class="p">(</span><span class="n">X</span><span class="p">,</span><span class="n">H</span><span class="o">.</span><span class="n">T</span><span class="p">)</span> <span class="o">+</span> <span class="n">Ptil</span><span class="o">.</span><span class="n">T</span>
        <span class="n">P</span> <span class="o">=</span> <span class="p">(</span><span class="n">_R</span> <span class="o">-</span> <span class="n">X</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span> <span class="n">dot</span><span class="p">(</span><span class="n">K</span><span class="p">,</span><span class="n">_R</span><span class="p">)</span> <span class="p">))</span><span class="o">.</span><span class="n">T</span>
        <span class="n">Ptil</span> <span class="o">=</span> <span class="p">(</span><span class="n">P</span><span class="o">+</span><span class="n">Lam_P</span><span class="o">/</span><span class="n">rho</span><span class="p">)</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>

        <span class="c1"># (W,H) updates</span>
        <span class="k">if</span> <span class="n">add_intercept</span><span class="p">:</span>
            <span class="n">ytil</span> <span class="o">=</span> <span class="n">y</span> <span class="o">-</span> <span class="n">one_n</span><span class="o">*</span><span class="n">w</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">H</span> <span class="o">=</span> <span class="n">solve</span><span class="p">(</span><span class="n">dot</span><span class="p">(</span><span class="n">W</span><span class="o">.</span><span class="n">T</span><span class="p">,</span><span class="n">W</span><span class="p">)</span> <span class="o">+</span> <span class="n">rho</span><span class="o">*</span><span class="n">eye_r</span> <span class="o">+</span> <span class="n">gam</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">outer</span><span class="p">(</span><span class="n">w</span><span class="p">[:</span><span class="n">r</span><span class="p">],</span><span class="n">w</span><span class="p">[:</span><span class="n">r</span><span class="p">]),</span>
                      <span class="n">dot</span><span class="p">(</span><span class="n">W</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">X</span><span class="p">)</span><span class="o">+</span><span class="n">rho</span><span class="o">*</span><span class="n">dot</span><span class="p">(</span><span class="n">P</span><span class="p">,</span><span class="n">X</span><span class="p">)</span><span class="o">-</span><span class="n">Lam_H</span> <span class="o">+</span> <span class="n">gam</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">outer</span><span class="p">(</span><span class="n">w</span><span class="p">[:</span><span class="n">r</span><span class="p">],</span><span class="n">ytil</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">H</span> <span class="o">=</span> <span class="n">solve</span><span class="p">(</span><span class="n">dot</span><span class="p">(</span><span class="n">W</span><span class="o">.</span><span class="n">T</span><span class="p">,</span><span class="n">W</span><span class="p">)</span> <span class="o">+</span> <span class="n">rho</span><span class="o">*</span><span class="n">eye_r</span> <span class="o">+</span> <span class="n">gam</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">outer</span><span class="p">(</span><span class="n">w</span><span class="p">,</span><span class="n">w</span><span class="p">),</span>
                      <span class="n">dot</span><span class="p">(</span><span class="n">W</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">X</span><span class="p">)</span><span class="o">+</span><span class="n">rho</span><span class="o">*</span><span class="n">dot</span><span class="p">(</span><span class="n">P</span><span class="p">,</span><span class="n">X</span><span class="p">)</span><span class="o">-</span><span class="n">Lam_H</span> <span class="o">+</span> <span class="n">gam</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">outer</span><span class="p">(</span><span class="n">w</span><span class="p">,</span><span class="n">y</span><span class="p">))</span>

        <span class="k">if</span> <span class="n">add_intercept</span><span class="p">:</span>
            <span class="c1"># H with intercept</span>
            <span class="n">H_</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="n">H</span><span class="p">,</span><span class="n">one_n</span><span class="p">))</span>
            <span class="c1"># for now, ignore gam2 regularizer...i never use them</span>
            <span class="n">w</span> <span class="o">=</span> <span class="n">solve</span><span class="p">(</span> <span class="n">H_</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">H_</span><span class="o">.</span><span class="n">T</span><span class="p">),</span> <span class="n">H_</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">y</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">w</span> <span class="o">=</span> <span class="n">solve</span><span class="p">(</span> <span class="n">H</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">H</span><span class="o">.</span><span class="n">T</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="n">gam2</span><span class="o">/</span><span class="n">gam</span><span class="p">)</span><span class="o">*</span><span class="n">eye_r</span><span class="p">,</span> <span class="n">H</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">y</span><span class="p">))</span>

        <span class="n">W</span> <span class="o">=</span> <span class="n">solve</span><span class="p">(</span><span class="n">dot</span><span class="p">(</span><span class="n">H</span><span class="p">,</span><span class="n">H</span><span class="o">.</span><span class="n">T</span><span class="p">)</span><span class="o">+</span><span class="mi">2</span><span class="o">*</span><span class="n">rho</span><span class="o">*</span><span class="n">eye_r</span><span class="p">,</span>
                  <span class="n">dot</span><span class="p">(</span><span class="n">H</span><span class="p">,</span> <span class="n">X</span><span class="o">.</span><span class="n">T</span><span class="p">)</span> <span class="o">+</span> <span class="n">rho</span><span class="o">*</span><span class="p">(</span><span class="n">Wtil</span><span class="o">+</span><span class="n">W2</span><span class="p">)</span><span class="o">.</span><span class="n">T</span> <span class="o">-</span> <span class="n">Lam_W</span><span class="o">.</span><span class="n">T</span> <span class="o">-</span> <span class="n">Lam_W2</span><span class="o">.</span><span class="n">T</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>

        <span class="n">Wtil</span> <span class="o">=</span> <span class="p">(</span><span class="n">W</span><span class="o">+</span><span class="n">Lam_W</span><span class="o">/</span><span class="n">rho</span><span class="p">)</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">W2</span> <span class="o">=</span> <span class="n">projection_spectral</span><span class="p">(</span><span class="n">W</span><span class="o">+</span><span class="n">Lam_W2</span><span class="o">/</span><span class="n">rho</span><span class="p">,</span><span class="n">constraint</span><span class="p">)</span>

        <span class="c1">#====================== dual updates =================================#</span>
        <span class="n">Lam_W</span> <span class="o">=</span> <span class="n">Lam_W</span> <span class="o">+</span> <span class="n">rho</span><span class="o">*</span><span class="p">(</span><span class="n">W</span> <span class="o">-</span> <span class="n">Wtil</span><span class="p">)</span>
        <span class="n">Lam_W2</span> <span class="o">=</span> <span class="n">Lam_W2</span> <span class="o">+</span> <span class="n">rho</span><span class="o">*</span><span class="p">(</span><span class="n">W</span> <span class="o">-</span> <span class="n">W2</span><span class="p">)</span>
        <span class="n">Lam_P</span> <span class="o">=</span> <span class="n">Lam_P</span> <span class="o">+</span> <span class="n">rho</span><span class="o">*</span><span class="p">(</span><span class="n">P</span> <span class="o">-</span> <span class="n">Ptil</span><span class="p">)</span>
        <span class="n">Lam_H</span> <span class="o">=</span> <span class="n">Lam_H</span> <span class="o">+</span> <span class="n">rho</span><span class="o">*</span><span class="p">(</span><span class="n">H</span> <span class="o">-</span> <span class="n">dot</span><span class="p">(</span><span class="n">P</span><span class="p">,</span><span class="n">X</span><span class="p">))</span>

        <span class="c1">#============ comptute objective values ==============================#</span>
        <span class="c1"># main loss function</span>
        <span class="n">PX</span> <span class="o">=</span> <span class="n">Ptil</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>
        <span class="n">cost_nmf</span> <span class="o">=</span> <span class="n">norm</span><span class="p">(</span><span class="n">Wtil</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">PX</span><span class="p">)</span> <span class="o">-</span> <span class="n">X</span><span class="p">,</span><span class="s1">&#39;fro&#39;</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="o">/</span><span class="mi">2</span>
        <span class="k">if</span> <span class="n">add_intercept</span><span class="p">:</span> <span class="c1"># for computing LS loss term</span>
            <span class="n">PX</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="n">PX</span><span class="p">,</span><span class="n">one_n</span><span class="p">))</span>
        <span class="n">cost_ls</span>  <span class="o">=</span> <span class="n">gam</span><span class="o">*</span><span class="n">norm</span><span class="p">(</span><span class="n">y</span> <span class="o">-</span> <span class="n">PX</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">w</span><span class="p">))</span> <span class="o">**</span><span class="mi">2</span><span class="o">/</span><span class="mi">2</span> <span class="o">+</span> <span class="n">gam2</span><span class="o">*</span><span class="n">norm</span><span class="p">(</span><span class="n">w</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="o">/</span><span class="mi">2</span>
        <span class="n">cost</span> <span class="o">=</span> <span class="n">cost_nmf</span> <span class="o">+</span> <span class="n">cost_ls</span>

        <span class="n">cost_nmf_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">cost_nmf</span><span class="p">)</span>
        <span class="n">cost_ls_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">cost_ls</span><span class="p">)</span>
        <span class="n">cost_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">cost</span><span class="p">)</span>

        <span class="c1"># relative change in cost</span>
        <span class="n">diffcost</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">cost_list</span><span class="p">[</span><span class="nb">iter</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">cost_list</span><span class="p">[</span><span class="nb">iter</span><span class="p">])</span><span class="o">/</span><span class="n">cost_list</span><span class="p">[</span><span class="nb">iter</span><span class="p">])</span>

        <span class="c1"># relative primal residuals</span>
        <span class="n">res_W</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">norm</span><span class="p">(</span><span class="n">W</span><span class="o">-</span><span class="n">Wtil</span><span class="p">,</span><span class="s1">&#39;fro&#39;</span><span class="p">)</span><span class="o">/</span><span class="n">norm</span><span class="p">(</span><span class="n">W</span><span class="p">,</span><span class="s1">&#39;fro&#39;</span><span class="p">))</span>
        <span class="n">res_W2</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">norm</span><span class="p">(</span><span class="n">W</span><span class="o">-</span><span class="n">W2</span><span class="p">,</span><span class="s1">&#39;fro&#39;</span><span class="p">)</span><span class="o">/</span><span class="n">norm</span><span class="p">(</span><span class="n">W</span><span class="p">,</span><span class="s1">&#39;fro&#39;</span><span class="p">))</span>
        <span class="n">res_P</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">norm</span><span class="p">(</span><span class="n">P</span><span class="o">-</span><span class="n">Ptil</span><span class="p">,</span><span class="s1">&#39;fro&#39;</span><span class="p">)</span><span class="o">/</span><span class="n">norm</span><span class="p">(</span><span class="n">P</span><span class="p">,</span><span class="s1">&#39;fro&#39;</span><span class="p">))</span>
        <span class="n">res_H</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">norm</span><span class="p">(</span><span class="n">H</span><span class="o">-</span><span class="n">P</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">X</span><span class="p">),</span><span class="s1">&#39;fro&#39;</span><span class="p">)</span><span class="o">/</span><span class="n">norm</span><span class="p">(</span><span class="n">H</span><span class="p">,</span><span class="s1">&#39;fro&#39;</span><span class="p">))</span>

        <span class="c1"># relative change in basis matrix</span>
<span class="c1">#        diffW.append( norm(W-W_old,&#39;fro&#39;)/ norm(W_old, &#39;fro&#39;) )</span>

        <span class="c1">#=== termination check ====#</span>
        <span class="n">check_exit</span>  <span class="o">=</span> <span class="p">(</span><span class="n">diffcost</span><span class="p">[</span><span class="nb">iter</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">tol</span><span class="p">)</span>
        <span class="n">check_exit</span> <span class="o">&amp;=</span> <span class="p">(</span><span class="n">res_W</span><span class="p">[</span><span class="nb">iter</span><span class="p">]</span> <span class="o">&lt;</span>  <span class="n">tol</span><span class="p">)</span>
        <span class="n">check_exit</span> <span class="o">&amp;=</span> <span class="p">(</span><span class="n">res_W2</span><span class="p">[</span><span class="nb">iter</span><span class="p">]</span> <span class="o">&lt;</span>  <span class="n">tol</span><span class="p">)</span>
        <span class="n">check_exit</span> <span class="o">&amp;=</span> <span class="p">(</span><span class="n">res_P</span><span class="p">[</span><span class="nb">iter</span><span class="p">]</span> <span class="o">&lt;</span>  <span class="n">tol</span><span class="p">)</span>
        <span class="n">check_exit</span> <span class="o">&amp;=</span> <span class="p">(</span><span class="n">res_H</span><span class="p">[</span><span class="nb">iter</span><span class="p">]</span> <span class="o">&lt;</span>  <span class="n">tol</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">check_exit</span> <span class="ow">and</span> <span class="nb">iter</span> <span class="o">&gt;</span> <span class="mi">300</span><span class="p">:</span> <span class="c1"># allow 300 iterations of &quot;burn-in&quot;</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">silence</span><span class="p">:</span>
                <span class="k">print</span> <span class="s2">&quot;    Termination condition met.  Exit at iter =&quot;</span><span class="p">,</span><span class="nb">iter</span><span class="p">,</span>
            <span class="k">break</span>
        <span class="c1">#=============== print current progress ==============================#</span>
<span class="c1">#        if iter % disp_freq == 0:</span>
        <span class="k">if</span> <span class="p">(</span><span class="nb">iter</span><span class="o">&gt;</span><span class="mi">1</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="nb">iter</span> <span class="o">%</span> <span class="n">disp_freq</span> <span class="o">==</span> <span class="mi">0</span><span class="p">):</span>
<span class="c1">#            str_ = &quot;iter={:4} cost={:3.3f}&quot;.format(iter,cost_list[iter+1])</span>
            <span class="n">str_</span> <span class="o">=</span> <span class="s2">&quot;iter={:4} cost={:6.5e}&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">iter</span><span class="p">,</span><span class="n">cost_list</span><span class="p">[</span><span class="nb">iter</span><span class="o">+</span><span class="mi">1</span><span class="p">])</span>
            <span class="n">str_</span> <span class="o">+=</span> <span class="s2">&quot; nmf={:.2e}&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">cost_nmf_list</span><span class="p">[</span><span class="nb">iter</span><span class="o">+</span><span class="mi">1</span><span class="p">])</span>
            <span class="n">str_</span> <span class="o">+=</span> <span class="s2">&quot; ls={:.2e}&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">cost_ls_list</span><span class="p">[</span><span class="nb">iter</span><span class="o">+</span><span class="mi">1</span><span class="p">])</span>
            <span class="n">str_</span> <span class="o">+=</span> <span class="s2">&quot; diffcost={:3.2e}&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">diffcost</span><span class="p">[</span><span class="nb">iter</span><span class="p">])</span>
            <span class="n">str_</span> <span class="o">+=</span> <span class="s2">&quot; W={:3.2e}&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">res_W</span><span class="p">[</span><span class="nb">iter</span><span class="p">])</span>
            <span class="n">str_</span> <span class="o">+=</span> <span class="s2">&quot; W2={:3.2e}&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">res_W2</span><span class="p">[</span><span class="nb">iter</span><span class="p">])</span>
            <span class="n">str_</span> <span class="o">+=</span> <span class="s2">&quot; P={:3.2e}&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">res_P</span><span class="p">[</span><span class="nb">iter</span><span class="p">])</span>
            <span class="n">str_</span> <span class="o">+=</span> <span class="s2">&quot; H={:3.2e}&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">res_H</span><span class="p">[</span><span class="nb">iter</span><span class="p">])</span>
<span class="c1">#            str_ += &quot; diffW={:3.2e}&quot;.format(diffW[iter])</span>
            <span class="k">print</span> <span class="n">str_</span> <span class="o">+</span> <span class="s2">&quot; ({:3.1f} sec)&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span><span class="o">-</span><span class="n">start</span><span class="p">)</span>
    <span class="c1">#%%---- end of admm for loop ---------------------------------------------#</span>
<span class="c1">#    cost_list = np.array(cost_list)</span>

    <span class="c1"># convert residual in pandas dataframe</span>
    <span class="n">cost</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">([</span><span class="n">cost_list</span><span class="p">,</span> <span class="n">cost_nmf_list</span><span class="p">,</span> <span class="n">cost_ls_list</span><span class="p">],</span>
                        <span class="n">index</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;total&#39;</span><span class="p">,</span><span class="s1">&#39;nmf&#39;</span><span class="p">,</span><span class="s1">&#39;ls&#39;</span><span class="p">])</span><span class="o">.</span><span class="n">T</span>
    <span class="n">res</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">([</span><span class="n">res_W</span><span class="p">,</span><span class="n">res_W2</span><span class="p">,</span><span class="n">res_P</span><span class="p">,</span><span class="n">res_H</span><span class="p">,</span><span class="n">diffcost</span><span class="p">],</span>
                       <span class="n">index</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;res_W&#39;</span><span class="p">,</span><span class="s1">&#39;res_W2&#39;</span><span class="p">,</span><span class="s1">&#39;res_P&#39;</span><span class="p">,</span><span class="s1">&#39;res_H&#39;</span><span class="p">,</span><span class="s1">&#39;diffcost&#39;</span><span class="p">])</span><span class="o">.</span><span class="n">T</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">silence</span><span class="p">:</span> <span class="n">print_time</span><span class="p">(</span><span class="n">start</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">W</span><span class="p">,</span><span class="n">P</span><span class="p">,</span><span class="n">H</span><span class="p">,</span><span class="n">w</span><span class="p">,</span><span class="n">Wtil</span><span class="p">,</span><span class="n">Ptil</span><span class="p">,</span><span class="n">cost</span><span class="p">,</span><span class="n">res</span>



<span class="k">def</span> <span class="nf">ls_spnmf_admm_bal</span><span class="p">(</span><span class="n">X</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">r</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span><span class="n">gam</span><span class="o">=</span><span class="mf">1e-1</span><span class="p">,</span><span class="n">rho</span><span class="o">=</span><span class="mf">1e3</span><span class="p">,</span><span class="n">max_iter</span><span class="o">=</span><span class="mi">5000</span><span class="p">,</span><span class="n">tol</span><span class="o">=</span><span class="mf">1e-4</span><span class="p">,</span>
                  <span class="n">W_init</span><span class="o">=</span><span class="s1">&#39;nndsvd&#39;</span><span class="p">,</span><span class="n">disp_freq</span><span class="o">=</span><span class="mi">2000</span><span class="p">,</span><span class="n">silence</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span>
                  <span class="n">constraint</span><span class="o">=</span><span class="s1">&#39;stiefel&#39;</span><span class="p">,</span><span class="n">gam2</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span><span class="n">add_intercept</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; PSame as ``ls_spnmf_admm``, but with class-weighted loss</span>

<span class="sd">    &gt;&gt;&gt; W,P,H,w,Wtil,Ptil,cost,res = ls_spnmf_admm_bal(X,y,r,rho=1e2)</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    X : ndarray of shape (n_features, n_samples)=(p,n)</span>
<span class="sd">        Data matrix with columns as data points</span>
<span class="sd">    y : array-like of shape [n_samples,]</span>
<span class="sd">        Label vector</span>
<span class="sd">    r : int</span>
<span class="sd">        Dimension of the embedding space (n_components)</span>
<span class="sd">    rho : float</span>
<span class="sd">        Augmented Lagrangian parameter</span>
<span class="sd">    max_iter : int</span>
<span class="sd">        max number of iterations</span>
<span class="sd">    tol : float</span>
<span class="sd">        convergence tolerance (on relative change in objective value and</span>
<span class="sd">        all primal residuals)</span>
<span class="sd">    W_init : None, rng, or &#39;nndsvd&#39;</span>
<span class="sd">        Way to initialize W (and H).  If ``None`` or ``RandomState object``</span>
<span class="sd">        is supplied, both W and H will be initialized via non-negative</span>
<span class="sd">        random number.  If ``&#39;nndsvd&#39;``, will use deterministic initialization</span>
<span class="sd">        NNDSVD &quot;Non-Negative Double Singular Value Decomposition&quot;, proposed by</span>
<span class="sd">        Boutsidis2008.</span>
<span class="sd">    disp_freq : int</span>
<span class="sd">        Frequency of update display (in iterations)</span>
<span class="sd">    silence : bool</span>
<span class="sd">        If True, don&#39;t print-out convergence detail at the end.</span>
<span class="sd">    add_intercept : bool (default=False)</span>
<span class="sd">        Add intercept term to classifier (added 02/17/2016)</span>

<span class="sd">    Update history</span>
<span class="sd">    --------------</span>
<span class="sd">    **02/17/2016** - function created</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">p</span><span class="p">,</span><span class="n">n</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">shape</span>
    <span class="n">rho</span> <span class="o">*=</span> <span class="mf">1.</span>
    <span class="n">gam</span> <span class="o">*=</span> <span class="mf">1.</span><span class="c1"># &lt;- ensure float</span>
    <span class="n">gam2</span> <span class="o">*=</span> <span class="mf">1.</span><span class="c1"># &lt;- ensure float</span>
    <span class="c1">#%% get class balance info</span>
    <span class="n">weight_pos</span> <span class="o">=</span> <span class="mf">1.</span><span class="o">*</span><span class="p">(</span><span class="n">y</span><span class="o">==-</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span><span class="o">/</span><span class="n">n</span>
    <span class="n">weight_neg</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">weight_pos</span>
    <span class="n">weight_vec</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
    <span class="n">weight_vec</span><span class="p">[</span><span class="n">y</span><span class="o">==+</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">weight_pos</span>
    <span class="n">weight_vec</span><span class="p">[</span><span class="n">y</span><span class="o">==-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">weight_neg</span>
    <span class="n">J</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span> <span class="n">weight_vec</span> <span class="p">)</span>
    <span class="c1">#%%=== initialize variables =====</span>
    <span class="c1"># define main primal variable W (basis matrix)</span>
    <span class="k">if</span> <span class="n">W_init</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
        <span class="n">W</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="n">p</span><span class="p">,</span><span class="n">r</span><span class="p">)</span>
        <span class="n">W</span> <span class="o">/=</span> <span class="n">norm</span><span class="p">(</span><span class="n">W</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>

        <span class="n">H</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="n">r</span><span class="p">,</span><span class="n">n</span><span class="p">)</span>
        <span class="n">H</span> <span class="o">/=</span> <span class="n">norm</span><span class="p">(</span><span class="n">H</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">W_init</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">RandomState</span><span class="p">):</span>
        <span class="n">rng</span> <span class="o">=</span> <span class="n">W_init</span>

        <span class="n">W</span> <span class="o">=</span> <span class="n">rng</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="n">p</span><span class="p">,</span><span class="n">r</span><span class="p">)</span>
        <span class="n">W</span> <span class="o">/=</span> <span class="n">norm</span><span class="p">(</span><span class="n">W</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>

        <span class="n">H</span> <span class="o">=</span> <span class="n">rng</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="n">r</span><span class="p">,</span><span class="n">n</span><span class="p">)</span>
        <span class="n">H</span> <span class="o">/=</span> <span class="n">norm</span><span class="p">(</span><span class="n">H</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">W_init</span> <span class="o">==</span> <span class="s1">&#39;nndsvd&#39;</span><span class="p">:</span>
<span class="c1">#        W = nnd_svd(X,r)</span>
        <span class="n">W</span><span class="p">,</span><span class="n">H</span> <span class="o">=</span> <span class="n">nnd_svd</span><span class="p">(</span><span class="n">X</span><span class="p">,</span><span class="n">r</span><span class="p">,</span><span class="n">get_H</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Invalid input for &quot;W_init&quot;&#39;</span><span class="p">)</span>

    <span class="n">P</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">r</span><span class="p">,</span><span class="n">p</span><span class="p">))</span>
<span class="c1">#    P = np.random.rand(r,p)</span>

    <span class="k">if</span> <span class="n">add_intercept</span><span class="p">:</span>
        <span class="n">w</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">r</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="c1"># &lt;- classification vector</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">w</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">r</span><span class="p">)</span> <span class="c1"># &lt;- classification vector</span>

    <span class="c1"># aux. variables</span>
    <span class="n">Wtil</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">W</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
    <span class="n">W2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">W</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
    <span class="n">Ptil</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">P</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>

    <span class="c1"># dual variables</span>
    <span class="n">Lam_W</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">W</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
    <span class="n">Lam_W2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">W</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
    <span class="n">Lam_P</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">P</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
    <span class="n">Lam_H</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">H</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>


    <span class="c1">#%%=== create empty lists for tracking updates ===</span>
    <span class="c1"># keep track of frobenius norm loss</span>
    <span class="n">cost_list</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">cost_nmf_list</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">cost_ls_list</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="n">PX</span> <span class="o">=</span> <span class="n">Ptil</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>
    <span class="n">cost_nmf</span> <span class="o">=</span> <span class="n">norm</span><span class="p">(</span><span class="n">Wtil</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">PX</span><span class="p">)</span> <span class="o">-</span> <span class="n">X</span><span class="p">,</span><span class="s1">&#39;fro&#39;</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="o">/</span><span class="mi">2</span>
    <span class="k">if</span> <span class="n">add_intercept</span><span class="p">:</span>
        <span class="c1"># used for the least-squares term</span>
        <span class="n">one_n</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
        <span class="n">PX</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="n">PX</span><span class="p">,</span><span class="n">one_n</span><span class="p">))</span>
    <span class="c1"># compute weighted error</span>
    <span class="n">_err</span> <span class="o">=</span> <span class="p">(</span><span class="n">y</span><span class="o">-</span><span class="n">PX</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">w</span><span class="p">))</span>
    <span class="n">_err</span> <span class="o">=</span> <span class="n">_err</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span> <span class="n">J</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">_err</span><span class="p">))</span>
    <span class="n">cost_ls</span>  <span class="o">=</span> <span class="n">gam</span><span class="o">*</span><span class="n">_err</span><span class="o">/</span><span class="mi">2</span> <span class="o">+</span> <span class="n">gam2</span><span class="o">*</span><span class="n">norm</span><span class="p">(</span><span class="n">w</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="o">/</span><span class="mi">2</span>
    <span class="c1">#cost_ls  = gam*norm(y - PX.T.dot(w)) **2/2 + gam2*norm(w)**2/2</span>
    <span class="n">cost</span> <span class="o">=</span> <span class="n">cost_nmf</span> <span class="o">+</span> <span class="n">cost_ls</span>

    <span class="n">cost_nmf_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">cost_nmf</span><span class="p">)</span>
    <span class="n">cost_ls_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">cost_ls</span><span class="p">)</span>
    <span class="n">cost_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">cost</span><span class="p">)</span>

    <span class="c1"># relative change in cost</span>
    <span class="n">diffcost</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="c1"># keep track of relative primal residual</span>
    <span class="n">res_W</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">res_W2</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">res_P</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">res_H</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="c1"># also keep track of diffW</span>
<span class="c1">#    diffW = []</span>
    <span class="c1">#%%=== run admm iterations ===</span>
    <span class="n">eye_r</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="n">r</span><span class="p">)</span>

    <span class="c1"># precompute term needed for inversion lemma</span>
    <span class="n">K</span> <span class="o">=</span> <span class="n">solve</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="o">+</span> <span class="n">dot</span><span class="p">(</span><span class="n">X</span><span class="o">.</span><span class="n">T</span><span class="p">,</span><span class="n">X</span><span class="p">),</span> <span class="n">X</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>

    <span class="n">start</span><span class="o">=</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
    <span class="k">for</span> <span class="nb">iter</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">max_iter</span><span class="p">):</span>
<span class="c1">#        W_old = W #&lt;- to keep track of diffW</span>

        <span class="c1">#================ primal updates (P, W, H, Ptil, Wtil) ===============#</span>
        <span class="c1"># update for P involves inversion lemma...</span>
        <span class="n">_R</span> <span class="o">=</span> <span class="n">dot</span><span class="p">(</span><span class="n">X</span><span class="p">,</span><span class="n">Lam_H</span><span class="o">.</span><span class="n">T</span><span class="p">)</span><span class="o">/</span><span class="n">rho</span> <span class="o">-</span> <span class="n">Lam_P</span><span class="o">.</span><span class="n">T</span><span class="o">/</span><span class="n">rho</span> <span class="o">+</span> <span class="n">dot</span><span class="p">(</span><span class="n">X</span><span class="p">,</span><span class="n">H</span><span class="o">.</span><span class="n">T</span><span class="p">)</span> <span class="o">+</span> <span class="n">Ptil</span><span class="o">.</span><span class="n">T</span>
        <span class="n">P</span> <span class="o">=</span> <span class="p">(</span><span class="n">_R</span> <span class="o">-</span> <span class="n">X</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span> <span class="n">dot</span><span class="p">(</span><span class="n">K</span><span class="p">,</span><span class="n">_R</span><span class="p">)</span> <span class="p">))</span><span class="o">.</span><span class="n">T</span>
        <span class="n">Ptil</span> <span class="o">=</span> <span class="p">(</span><span class="n">P</span><span class="o">+</span><span class="n">Lam_P</span><span class="o">/</span><span class="n">rho</span><span class="p">)</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>

        <span class="c1"># (W,H) updates</span>
        <span class="n">WtW</span> <span class="o">=</span> <span class="n">dot</span><span class="p">(</span><span class="n">W</span><span class="o">.</span><span class="n">T</span><span class="p">,</span><span class="n">W</span><span class="p">)</span> <span class="o">+</span> <span class="n">rho</span><span class="o">*</span><span class="n">eye_r</span>
        <span class="k">if</span> <span class="n">add_intercept</span><span class="p">:</span>
            <span class="n">ytil</span> <span class="o">=</span> <span class="n">y</span> <span class="o">-</span> <span class="n">one_n</span><span class="o">*</span><span class="n">w</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">_S</span> <span class="o">=</span> <span class="n">dot</span><span class="p">(</span><span class="n">W</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">X</span><span class="p">)</span><span class="o">+</span><span class="n">rho</span><span class="o">*</span><span class="n">dot</span><span class="p">(</span><span class="n">P</span><span class="p">,</span><span class="n">X</span><span class="p">)</span><span class="o">-</span><span class="n">Lam_H</span> <span class="o">+</span> <span class="n">gam</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">outer</span><span class="p">(</span><span class="n">w</span><span class="p">[:</span><span class="n">r</span><span class="p">],</span><span class="n">ytil</span><span class="p">)</span>
            <span class="n">wtw</span> <span class="o">=</span> <span class="n">gam</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">outer</span><span class="p">(</span><span class="n">w</span><span class="p">[:</span><span class="n">r</span><span class="p">],</span><span class="n">w</span><span class="p">[:</span><span class="n">r</span><span class="p">])</span>
            <span class="c1">#H = solve(dot(W.T,W) + rho*eye_r + gam*np.outer(w[:r],w[:r]),</span>
            <span class="c1">#          dot(W.T, X)+rho*dot(P,X)-Lam_H + gam*np.outer(w[:r],ytil))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">_S</span> <span class="o">=</span> <span class="n">dot</span><span class="p">(</span><span class="n">W</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">X</span><span class="p">)</span><span class="o">+</span><span class="n">rho</span><span class="o">*</span><span class="n">dot</span><span class="p">(</span><span class="n">P</span><span class="p">,</span><span class="n">X</span><span class="p">)</span><span class="o">-</span><span class="n">Lam_H</span> <span class="o">+</span> <span class="n">gam</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">outer</span><span class="p">(</span><span class="n">w</span><span class="p">,</span><span class="n">y</span><span class="p">)</span>
            <span class="n">wtw</span> <span class="o">=</span> <span class="n">gam</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">outer</span><span class="p">(</span><span class="n">w</span><span class="p">,</span><span class="n">w</span><span class="p">)</span>
            <span class="c1">#H = solve(dot(W.T,W) + rho*eye_r + gam*np.outer(w,w),</span>
            <span class="c1">#          dot(W.T, X)+rho*dot(P,X)-Lam_H + gam*np.outer(w,y))</span>
        <span class="n">H</span><span class="p">[:,</span><span class="n">y</span><span class="o">==+</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">solve</span><span class="p">(</span><span class="n">WtW</span> <span class="o">+</span> <span class="n">weight_pos</span><span class="o">*</span><span class="n">wtw</span><span class="p">,</span> <span class="n">_S</span><span class="p">[:,</span><span class="n">y</span><span class="o">==+</span><span class="mi">1</span><span class="p">])</span>
        <span class="n">H</span><span class="p">[:,</span><span class="n">y</span><span class="o">==-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">solve</span><span class="p">(</span><span class="n">WtW</span> <span class="o">+</span> <span class="n">weight_neg</span><span class="o">*</span><span class="n">wtw</span><span class="p">,</span> <span class="n">_S</span><span class="p">[:,</span><span class="n">y</span><span class="o">==-</span><span class="mi">1</span><span class="p">])</span>


        <span class="k">if</span> <span class="n">add_intercept</span><span class="p">:</span>
            <span class="c1"># H with intercept</span>
            <span class="n">H_</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="n">H</span><span class="p">,</span><span class="n">one_n</span><span class="p">))</span>
            <span class="c1"># for now, ignore gam2 regularizer...i never use them</span>
            <span class="n">w</span> <span class="o">=</span> <span class="n">solve</span><span class="p">(</span> <span class="n">H_</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">J</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">H_</span><span class="o">.</span><span class="n">T</span><span class="p">)),</span> <span class="n">H_</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">J</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">y</span><span class="p">)))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">w</span> <span class="o">=</span> <span class="n">solve</span><span class="p">(</span> <span class="n">H</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">J</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">H</span><span class="o">.</span><span class="n">T</span><span class="p">))</span> <span class="o">+</span> <span class="p">(</span><span class="n">gam2</span><span class="o">/</span><span class="n">gam</span><span class="p">)</span><span class="o">*</span><span class="n">eye_r</span><span class="p">,</span> <span class="n">H</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">J</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">y</span><span class="p">)))</span>

        <span class="n">W</span> <span class="o">=</span> <span class="n">solve</span><span class="p">(</span><span class="n">dot</span><span class="p">(</span><span class="n">H</span><span class="p">,</span><span class="n">H</span><span class="o">.</span><span class="n">T</span><span class="p">)</span><span class="o">+</span><span class="mi">2</span><span class="o">*</span><span class="n">rho</span><span class="o">*</span><span class="n">eye_r</span><span class="p">,</span>
                  <span class="n">dot</span><span class="p">(</span><span class="n">H</span><span class="p">,</span> <span class="n">X</span><span class="o">.</span><span class="n">T</span><span class="p">)</span> <span class="o">+</span> <span class="n">rho</span><span class="o">*</span><span class="p">(</span><span class="n">Wtil</span><span class="o">+</span><span class="n">W2</span><span class="p">)</span><span class="o">.</span><span class="n">T</span> <span class="o">-</span> <span class="n">Lam_W</span><span class="o">.</span><span class="n">T</span> <span class="o">-</span> <span class="n">Lam_W2</span><span class="o">.</span><span class="n">T</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>

        <span class="n">Wtil</span> <span class="o">=</span> <span class="p">(</span><span class="n">W</span><span class="o">+</span><span class="n">Lam_W</span><span class="o">/</span><span class="n">rho</span><span class="p">)</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">W2</span> <span class="o">=</span> <span class="n">projection_spectral</span><span class="p">(</span><span class="n">W</span><span class="o">+</span><span class="n">Lam_W2</span><span class="o">/</span><span class="n">rho</span><span class="p">,</span><span class="n">constraint</span><span class="p">)</span>

        <span class="c1">#====================== dual updates =================================#</span>
        <span class="n">Lam_W</span> <span class="o">=</span> <span class="n">Lam_W</span> <span class="o">+</span> <span class="n">rho</span><span class="o">*</span><span class="p">(</span><span class="n">W</span> <span class="o">-</span> <span class="n">Wtil</span><span class="p">)</span>
        <span class="n">Lam_W2</span> <span class="o">=</span> <span class="n">Lam_W2</span> <span class="o">+</span> <span class="n">rho</span><span class="o">*</span><span class="p">(</span><span class="n">W</span> <span class="o">-</span> <span class="n">W2</span><span class="p">)</span>
        <span class="n">Lam_P</span> <span class="o">=</span> <span class="n">Lam_P</span> <span class="o">+</span> <span class="n">rho</span><span class="o">*</span><span class="p">(</span><span class="n">P</span> <span class="o">-</span> <span class="n">Ptil</span><span class="p">)</span>
        <span class="n">Lam_H</span> <span class="o">=</span> <span class="n">Lam_H</span> <span class="o">+</span> <span class="n">rho</span><span class="o">*</span><span class="p">(</span><span class="n">H</span> <span class="o">-</span> <span class="n">dot</span><span class="p">(</span><span class="n">P</span><span class="p">,</span><span class="n">X</span><span class="p">))</span>

        <span class="c1">#============ comptute objective values ==============================#</span>
        <span class="c1"># main loss function</span>
        <span class="n">PX</span> <span class="o">=</span> <span class="n">Ptil</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>
        <span class="n">cost_nmf</span> <span class="o">=</span> <span class="n">norm</span><span class="p">(</span><span class="n">Wtil</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">PX</span><span class="p">)</span> <span class="o">-</span> <span class="n">X</span><span class="p">,</span><span class="s1">&#39;fro&#39;</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="o">/</span><span class="mi">2</span>
        <span class="k">if</span> <span class="n">add_intercept</span><span class="p">:</span> <span class="c1"># for computing LS loss term</span>
            <span class="n">PX</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="n">PX</span><span class="p">,</span><span class="n">one_n</span><span class="p">))</span>
        <span class="c1"># compute weighted error</span>
        <span class="n">_err</span> <span class="o">=</span> <span class="p">(</span><span class="n">y</span><span class="o">-</span><span class="n">PX</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">w</span><span class="p">))</span>
        <span class="n">_err</span> <span class="o">=</span> <span class="n">_err</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span> <span class="n">J</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">_err</span><span class="p">))</span>
        <span class="n">cost_ls</span>  <span class="o">=</span> <span class="n">gam</span><span class="o">*</span><span class="n">_err</span><span class="o">/</span><span class="mi">2</span> <span class="o">+</span> <span class="n">gam2</span><span class="o">*</span><span class="n">norm</span><span class="p">(</span><span class="n">w</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="o">/</span><span class="mi">2</span>
        <span class="c1">#cost_ls  = gam*norm(y - PX.T.dot(w)) **2/2 + gam2*norm(w)**2/2</span>
        <span class="n">cost</span> <span class="o">=</span> <span class="n">cost_nmf</span> <span class="o">+</span> <span class="n">cost_ls</span>

        <span class="n">cost_nmf_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">cost_nmf</span><span class="p">)</span>
        <span class="n">cost_ls_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">cost_ls</span><span class="p">)</span>
        <span class="n">cost_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">cost</span><span class="p">)</span>

        <span class="c1"># relative change in cost</span>
        <span class="n">diffcost</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">cost_list</span><span class="p">[</span><span class="nb">iter</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">cost_list</span><span class="p">[</span><span class="nb">iter</span><span class="p">])</span><span class="o">/</span><span class="n">cost_list</span><span class="p">[</span><span class="nb">iter</span><span class="p">])</span>

        <span class="c1"># relative primal residuals</span>
        <span class="n">res_W</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">norm</span><span class="p">(</span><span class="n">W</span><span class="o">-</span><span class="n">Wtil</span><span class="p">,</span><span class="s1">&#39;fro&#39;</span><span class="p">)</span><span class="o">/</span><span class="n">norm</span><span class="p">(</span><span class="n">W</span><span class="p">,</span><span class="s1">&#39;fro&#39;</span><span class="p">))</span>
        <span class="n">res_W2</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">norm</span><span class="p">(</span><span class="n">W</span><span class="o">-</span><span class="n">W2</span><span class="p">,</span><span class="s1">&#39;fro&#39;</span><span class="p">)</span><span class="o">/</span><span class="n">norm</span><span class="p">(</span><span class="n">W</span><span class="p">,</span><span class="s1">&#39;fro&#39;</span><span class="p">))</span>
        <span class="n">res_P</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">norm</span><span class="p">(</span><span class="n">P</span><span class="o">-</span><span class="n">Ptil</span><span class="p">,</span><span class="s1">&#39;fro&#39;</span><span class="p">)</span><span class="o">/</span><span class="n">norm</span><span class="p">(</span><span class="n">P</span><span class="p">,</span><span class="s1">&#39;fro&#39;</span><span class="p">))</span>
        <span class="n">res_H</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">norm</span><span class="p">(</span><span class="n">H</span><span class="o">-</span><span class="n">P</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">X</span><span class="p">),</span><span class="s1">&#39;fro&#39;</span><span class="p">)</span><span class="o">/</span><span class="n">norm</span><span class="p">(</span><span class="n">H</span><span class="p">,</span><span class="s1">&#39;fro&#39;</span><span class="p">))</span>

        <span class="c1"># relative change in basis matrix</span>
<span class="c1">#        diffW.append( norm(W-W_old,&#39;fro&#39;)/ norm(W_old, &#39;fro&#39;) )</span>

        <span class="c1">#=== termination check ====#</span>
        <span class="n">check_exit</span>  <span class="o">=</span> <span class="p">(</span><span class="n">diffcost</span><span class="p">[</span><span class="nb">iter</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">tol</span><span class="p">)</span>
        <span class="n">check_exit</span> <span class="o">&amp;=</span> <span class="p">(</span><span class="n">res_W</span><span class="p">[</span><span class="nb">iter</span><span class="p">]</span> <span class="o">&lt;</span>  <span class="n">tol</span><span class="p">)</span>
        <span class="n">check_exit</span> <span class="o">&amp;=</span> <span class="p">(</span><span class="n">res_W2</span><span class="p">[</span><span class="nb">iter</span><span class="p">]</span> <span class="o">&lt;</span>  <span class="n">tol</span><span class="p">)</span>
        <span class="n">check_exit</span> <span class="o">&amp;=</span> <span class="p">(</span><span class="n">res_P</span><span class="p">[</span><span class="nb">iter</span><span class="p">]</span> <span class="o">&lt;</span>  <span class="n">tol</span><span class="p">)</span>
        <span class="n">check_exit</span> <span class="o">&amp;=</span> <span class="p">(</span><span class="n">res_H</span><span class="p">[</span><span class="nb">iter</span><span class="p">]</span> <span class="o">&lt;</span>  <span class="n">tol</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">check_exit</span> <span class="ow">and</span> <span class="nb">iter</span> <span class="o">&gt;</span> <span class="mi">300</span><span class="p">:</span> <span class="c1"># allow 300 iterations of &quot;burn-in&quot;</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">silence</span><span class="p">:</span>
                <span class="k">print</span> <span class="s2">&quot;    Termination condition met.  Exit at iter =&quot;</span><span class="p">,</span><span class="nb">iter</span><span class="p">,</span>
            <span class="k">break</span>
        <span class="c1">#=============== print current progress ==============================#</span>
<span class="c1">#        if iter % disp_freq == 0:</span>
        <span class="k">if</span> <span class="p">(</span><span class="nb">iter</span><span class="o">&gt;</span><span class="mi">1</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="nb">iter</span> <span class="o">%</span> <span class="n">disp_freq</span> <span class="o">==</span> <span class="mi">0</span><span class="p">):</span>
<span class="c1">#            str_ = &quot;iter={:4} cost={:3.3f}&quot;.format(iter,cost_list[iter+1])</span>
            <span class="n">str_</span> <span class="o">=</span> <span class="s2">&quot;iter={:4} cost={:6.5e}&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">iter</span><span class="p">,</span><span class="n">cost_list</span><span class="p">[</span><span class="nb">iter</span><span class="o">+</span><span class="mi">1</span><span class="p">])</span>
            <span class="n">str_</span> <span class="o">+=</span> <span class="s2">&quot; nmf={:.2e}&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">cost_nmf_list</span><span class="p">[</span><span class="nb">iter</span><span class="o">+</span><span class="mi">1</span><span class="p">])</span>
            <span class="n">str_</span> <span class="o">+=</span> <span class="s2">&quot; ls={:.2e}&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">cost_ls_list</span><span class="p">[</span><span class="nb">iter</span><span class="o">+</span><span class="mi">1</span><span class="p">])</span>
            <span class="n">str_</span> <span class="o">+=</span> <span class="s2">&quot; diffcost={:3.2e}&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">diffcost</span><span class="p">[</span><span class="nb">iter</span><span class="p">])</span>
            <span class="n">str_</span> <span class="o">+=</span> <span class="s2">&quot; W={:3.2e}&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">res_W</span><span class="p">[</span><span class="nb">iter</span><span class="p">])</span>
            <span class="n">str_</span> <span class="o">+=</span> <span class="s2">&quot; W2={:3.2e}&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">res_W2</span><span class="p">[</span><span class="nb">iter</span><span class="p">])</span>
            <span class="n">str_</span> <span class="o">+=</span> <span class="s2">&quot; P={:3.2e}&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">res_P</span><span class="p">[</span><span class="nb">iter</span><span class="p">])</span>
            <span class="n">str_</span> <span class="o">+=</span> <span class="s2">&quot; H={:3.2e}&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">res_H</span><span class="p">[</span><span class="nb">iter</span><span class="p">])</span>
<span class="c1">#            str_ += &quot; diffW={:3.2e}&quot;.format(diffW[iter])</span>
            <span class="k">print</span> <span class="n">str_</span> <span class="o">+</span> <span class="s2">&quot; ({:3.1f} sec)&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span><span class="o">-</span><span class="n">start</span><span class="p">)</span>
    <span class="c1">#%%---- end of admm for loop ---------------------------------------------#</span>
<span class="c1">#    cost_list = np.array(cost_list)</span>

    <span class="c1"># convert residual in pandas dataframe</span>
    <span class="n">cost</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">([</span><span class="n">cost_list</span><span class="p">,</span> <span class="n">cost_nmf_list</span><span class="p">,</span> <span class="n">cost_ls_list</span><span class="p">],</span>
                        <span class="n">index</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;total&#39;</span><span class="p">,</span><span class="s1">&#39;nmf&#39;</span><span class="p">,</span><span class="s1">&#39;ls&#39;</span><span class="p">])</span><span class="o">.</span><span class="n">T</span>
    <span class="n">res</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">([</span><span class="n">res_W</span><span class="p">,</span><span class="n">res_W2</span><span class="p">,</span><span class="n">res_P</span><span class="p">,</span><span class="n">res_H</span><span class="p">,</span><span class="n">diffcost</span><span class="p">],</span>
                       <span class="n">index</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;res_W&#39;</span><span class="p">,</span><span class="s1">&#39;res_W2&#39;</span><span class="p">,</span><span class="s1">&#39;res_P&#39;</span><span class="p">,</span><span class="s1">&#39;res_H&#39;</span><span class="p">,</span><span class="s1">&#39;diffcost&#39;</span><span class="p">])</span><span class="o">.</span><span class="n">T</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">silence</span><span class="p">:</span> <span class="n">print_time</span><span class="p">(</span><span class="n">start</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">W</span><span class="p">,</span><span class="n">P</span><span class="p">,</span><span class="n">H</span><span class="p">,</span><span class="n">w</span><span class="p">,</span><span class="n">Wtil</span><span class="p">,</span><span class="n">Ptil</span><span class="p">,</span><span class="n">cost</span><span class="p">,</span><span class="n">res</span>



<span class="c1">#%% === graph regularized methods</span>
<span class="k">def</span> <span class="nf">gpnmf_admm</span><span class="p">(</span><span class="n">X</span><span class="p">,</span><span class="n">r</span><span class="p">,</span><span class="n">L</span><span class="p">,</span><span class="n">tau</span><span class="o">=</span><span class="mf">1e-1</span><span class="p">,</span><span class="n">rho</span><span class="o">=</span><span class="mf">1e3</span><span class="p">,</span><span class="n">max_iter</span><span class="o">=</span><span class="mi">5000</span><span class="p">,</span><span class="n">tol</span><span class="o">=</span><span class="mf">1e-4</span><span class="p">,</span><span class="n">W_init</span><span class="o">=</span><span class="s1">&#39;nndsvd&#39;</span><span class="p">,</span>
               <span class="n">disp_freq</span><span class="o">=</span><span class="mi">1000</span><span class="p">,</span><span class="n">silence</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Graph regularized Projective NMF using ADMM.</span>

<span class="sd">    &gt;&gt;&gt; W,P,H,Wtil,Ptil,cost_list,res = gpnmf_admm(X,r,rho=5e2)</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    X : ndarray of shape (n_features, n_samples)=(p,n)</span>
<span class="sd">        Data matrix with columns as data points</span>
<span class="sd">    r : int</span>
<span class="sd">        Dimension of the embedding space (n_components)</span>
<span class="sd">    L : ndarray of shape = [n_samples, n_samples]</span>
<span class="sd">        Laplacian matrix.</span>
<span class="sd">    tau : float</span>
<span class="sd">        Amount of graph regularization to apply</span>
<span class="sd">    rho : float</span>
<span class="sd">        Augmented Lagrangian parameter</span>
<span class="sd">    max_iter : int</span>
<span class="sd">        max number of iterations</span>
<span class="sd">    tol : float</span>
<span class="sd">        convergence tolerance (on relative change in objective value and</span>
<span class="sd">        all primal residuals)</span>
<span class="sd">    W_init : None (default), rng, or &#39;nndsvd&#39;</span>
<span class="sd">        Way to initialize W (and H).  If ``None`` or ``RandomState object``</span>
<span class="sd">        is supplied, both W and H will be initialized via non-negative</span>
<span class="sd">        random number.  If ``&#39;nndsvd&#39;``, will use deterministic initialization</span>
<span class="sd">        NNDSVD &quot;Non-Negative Double Singular Value Decomposition&quot;, proposed by</span>
<span class="sd">        Boutsidis2008.</span>
<span class="sd">    disp_freq : int</span>
<span class="sd">        Frequency of update display (in iterations)</span>
<span class="sd">    silence : bool</span>
<span class="sd">        If True, don&#39;t print-out convergence detail at the end.</span>

<span class="sd">    Update history</span>
<span class="sd">    --------------</span>
<span class="sd">    **02/03/2016** - function created</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">rho</span> <span class="o">*=</span> <span class="mf">1.</span>
    <span class="n">tau</span> <span class="o">*=</span> <span class="mf">1.</span>
    <span class="n">p</span><span class="p">,</span><span class="n">n</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">shape</span>
    <span class="c1">#%%=== initialize variables =====</span>
    <span class="c1"># define main primal variable W (basis matrix)</span>
    <span class="k">if</span> <span class="n">W_init</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
        <span class="n">W</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="n">p</span><span class="p">,</span><span class="n">r</span><span class="p">)</span>
        <span class="n">W</span> <span class="o">/=</span> <span class="n">norm</span><span class="p">(</span><span class="n">W</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>

        <span class="n">H</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="n">r</span><span class="p">,</span><span class="n">n</span><span class="p">)</span>
        <span class="n">H</span> <span class="o">/=</span> <span class="n">norm</span><span class="p">(</span><span class="n">H</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">W_init</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">RandomState</span><span class="p">):</span>
        <span class="n">rng</span> <span class="o">=</span> <span class="n">W_init</span>

        <span class="n">W</span> <span class="o">=</span> <span class="n">rng</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="n">p</span><span class="p">,</span><span class="n">r</span><span class="p">)</span>
        <span class="n">W</span> <span class="o">/=</span> <span class="n">norm</span><span class="p">(</span><span class="n">W</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>

        <span class="n">H</span> <span class="o">=</span> <span class="n">rng</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="n">r</span><span class="p">,</span><span class="n">n</span><span class="p">)</span>
        <span class="n">H</span> <span class="o">/=</span> <span class="n">norm</span><span class="p">(</span><span class="n">H</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">W_init</span> <span class="o">==</span> <span class="s1">&#39;nndsvd&#39;</span><span class="p">:</span>
<span class="c1">#        W = nnd_svd(X,r)</span>
        <span class="n">W</span><span class="p">,</span><span class="n">H</span> <span class="o">=</span> <span class="n">nnd_svd</span><span class="p">(</span><span class="n">X</span><span class="p">,</span><span class="n">r</span><span class="p">,</span><span class="n">get_H</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Invalid input for &quot;W_init&quot;&#39;</span><span class="p">)</span>

    <span class="n">P</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">r</span><span class="p">,</span><span class="n">p</span><span class="p">))</span>
<span class="c1">#    P = np.random.rand(r,p)</span>

    <span class="c1"># aux. variables</span>
    <span class="n">Wtil</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">W</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
    <span class="n">Ptil</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">P</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
    <span class="n">Htil</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">H</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="c1"># &lt;- for graph regularization</span>

    <span class="c1"># dual variables</span>
    <span class="n">Lam_W</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">W</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
    <span class="n">Lam_P</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">P</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
    <span class="n">Lam_H</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">H</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
    <span class="n">Lam_Htil</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">H</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="c1"># &lt;- for graph regularization</span>
    <span class="c1">#%%=== create empty lists for tracking updates ===</span>
    <span class="c1"># keep track of frobenius norm loss</span>
    <span class="n">cost_list</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">cost_nmf_list</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">cost_graph_list</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="n">cost_nmf</span> <span class="o">=</span> <span class="n">norm</span><span class="p">(</span><span class="n">Wtil</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">Ptil</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">X</span><span class="p">))</span> <span class="o">-</span> <span class="n">X</span><span class="p">,</span><span class="s1">&#39;fro&#39;</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="o">/</span><span class="mi">2</span>
    <span class="n">cost_graph</span> <span class="o">=</span> <span class="n">tau</span><span class="o">*</span><span class="n">trace</span><span class="p">(</span> <span class="n">L</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span> <span class="n">dot</span><span class="p">(</span><span class="n">Htil</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">Htil</span><span class="p">)))</span>
    <span class="n">cost</span> <span class="o">=</span> <span class="n">cost_nmf</span> <span class="o">+</span> <span class="n">cost_graph</span>

    <span class="n">cost_nmf_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">cost_nmf</span><span class="p">)</span>
    <span class="n">cost_graph_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">cost_graph</span><span class="p">)</span>
    <span class="n">cost_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">cost</span><span class="p">)</span>

    <span class="c1"># relative change in cost</span>
    <span class="n">diffcost</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="c1"># keep track of relative primal residual</span>
    <span class="n">res_W</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">res_P</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">res_H</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">res_Htil</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="c1"># also keep track of diffW</span>
<span class="c1">#    diffW = []</span>
    <span class="c1">#%%=== run admm iterations ===</span>
    <span class="n">eye_r</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="n">r</span><span class="p">)</span>
    <span class="n">eye_n</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>

    <span class="c1"># precompute term needed for inversion lemma</span>
    <span class="n">K</span> <span class="o">=</span> <span class="n">solve</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="o">+</span> <span class="n">dot</span><span class="p">(</span><span class="n">X</span><span class="o">.</span><span class="n">T</span><span class="p">,</span><span class="n">X</span><span class="p">),</span> <span class="n">X</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>

    <span class="n">start</span><span class="o">=</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
    <span class="k">for</span> <span class="nb">iter</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">max_iter</span><span class="p">):</span>
<span class="c1">#        W_old = W #&lt;- to keep track of diffW</span>

        <span class="c1">#================ primal updates (P, W, H, Ptil, Wtil) ===============#</span>
        <span class="c1"># update for P involves inversion lemma...</span>
        <span class="n">_R</span> <span class="o">=</span> <span class="n">dot</span><span class="p">(</span><span class="n">X</span><span class="p">,</span><span class="n">Lam_H</span><span class="o">.</span><span class="n">T</span><span class="p">)</span><span class="o">/</span><span class="n">rho</span> <span class="o">-</span> <span class="n">Lam_P</span><span class="o">.</span><span class="n">T</span><span class="o">/</span><span class="n">rho</span> <span class="o">+</span> <span class="n">dot</span><span class="p">(</span><span class="n">X</span><span class="p">,</span><span class="n">H</span><span class="o">.</span><span class="n">T</span><span class="p">)</span> <span class="o">+</span> <span class="n">Ptil</span><span class="o">.</span><span class="n">T</span>
        <span class="n">P</span> <span class="o">=</span> <span class="p">(</span><span class="n">_R</span> <span class="o">-</span> <span class="n">X</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span> <span class="n">dot</span><span class="p">(</span><span class="n">K</span><span class="p">,</span><span class="n">_R</span><span class="p">)</span> <span class="p">))</span><span class="o">.</span><span class="n">T</span>
        <span class="n">Ptil</span> <span class="o">=</span> <span class="p">(</span><span class="n">P</span><span class="o">+</span><span class="n">Lam_P</span><span class="o">/</span><span class="n">rho</span><span class="p">)</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>

        <span class="c1"># (W,H) updates</span>
        <span class="n">H</span> <span class="o">=</span> <span class="n">solve</span><span class="p">(</span><span class="n">dot</span><span class="p">(</span><span class="n">W</span><span class="o">.</span><span class="n">T</span><span class="p">,</span><span class="n">W</span><span class="p">)</span><span class="o">+</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">rho</span><span class="p">)</span><span class="o">*</span><span class="n">eye_r</span><span class="p">,</span>
                  <span class="n">dot</span><span class="p">(</span><span class="n">W</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">X</span><span class="p">)</span> <span class="o">+</span> <span class="n">rho</span><span class="o">*</span><span class="n">dot</span><span class="p">(</span><span class="n">P</span><span class="p">,</span><span class="n">X</span><span class="p">)</span> <span class="o">-</span> <span class="n">Lam_H</span> <span class="o">+</span> <span class="n">rho</span><span class="o">*</span><span class="n">Htil</span> <span class="o">-</span> <span class="n">Lam_Htil</span> <span class="p">)</span>
        <span class="n">W</span> <span class="o">=</span> <span class="n">solve</span><span class="p">(</span><span class="n">dot</span><span class="p">(</span><span class="n">H</span><span class="p">,</span><span class="n">H</span><span class="o">.</span><span class="n">T</span><span class="p">)</span><span class="o">+</span><span class="n">rho</span><span class="o">*</span><span class="n">eye_r</span><span class="p">,</span> <span class="n">dot</span><span class="p">(</span><span class="n">H</span><span class="p">,</span> <span class="n">X</span><span class="o">.</span><span class="n">T</span><span class="p">)</span> <span class="o">+</span> <span class="n">rho</span><span class="o">*</span><span class="n">Wtil</span><span class="o">.</span><span class="n">T</span> <span class="o">-</span> <span class="n">Lam_W</span><span class="o">.</span><span class="n">T</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>
        <span class="n">Wtil</span> <span class="o">=</span> <span class="p">(</span><span class="n">W</span><span class="o">+</span><span class="n">Lam_W</span><span class="o">/</span><span class="n">rho</span><span class="p">)</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>

        <span class="n">Htil</span> <span class="o">=</span> <span class="n">solve</span><span class="p">(</span><span class="n">tau</span><span class="o">*</span><span class="n">L</span> <span class="o">+</span> <span class="n">rho</span><span class="o">*</span><span class="n">eye_n</span><span class="p">,</span> <span class="n">rho</span><span class="o">*</span><span class="n">H</span><span class="o">.</span><span class="n">T</span><span class="o">+</span><span class="n">Lam_Htil</span><span class="o">.</span><span class="n">T</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>

        <span class="c1">#====================== dual updates =================================#</span>
        <span class="n">Lam_W</span> <span class="o">=</span> <span class="n">Lam_W</span> <span class="o">+</span> <span class="n">rho</span><span class="o">*</span><span class="p">(</span><span class="n">W</span> <span class="o">-</span> <span class="n">Wtil</span><span class="p">)</span>
        <span class="n">Lam_P</span> <span class="o">=</span> <span class="n">Lam_P</span> <span class="o">+</span> <span class="n">rho</span><span class="o">*</span><span class="p">(</span><span class="n">P</span> <span class="o">-</span> <span class="n">Ptil</span><span class="p">)</span>
        <span class="n">Lam_H</span> <span class="o">=</span> <span class="n">Lam_H</span> <span class="o">+</span> <span class="n">rho</span><span class="o">*</span><span class="p">(</span><span class="n">H</span> <span class="o">-</span> <span class="n">dot</span><span class="p">(</span><span class="n">P</span><span class="p">,</span><span class="n">X</span><span class="p">))</span>
        <span class="n">Lam_Htil</span> <span class="o">=</span> <span class="n">Lam_Htil</span> <span class="o">+</span> <span class="n">rho</span><span class="o">*</span><span class="p">(</span><span class="n">H</span><span class="o">-</span><span class="n">Htil</span><span class="p">)</span>

        <span class="c1">#============ comptute objective values ==============================#</span>
        <span class="c1"># main loss function</span>
        <span class="n">cost_nmf</span> <span class="o">=</span> <span class="n">norm</span><span class="p">(</span><span class="n">Wtil</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">Ptil</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">X</span><span class="p">))</span> <span class="o">-</span> <span class="n">X</span><span class="p">,</span><span class="s1">&#39;fro&#39;</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="o">/</span><span class="mi">2</span>
        <span class="n">cost_graph</span> <span class="o">=</span> <span class="n">tau</span><span class="o">*</span><span class="n">trace</span><span class="p">(</span> <span class="n">L</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span> <span class="n">dot</span><span class="p">(</span><span class="n">Htil</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">Htil</span><span class="p">)))</span>
        <span class="n">cost</span> <span class="o">=</span> <span class="n">cost_nmf</span> <span class="o">+</span> <span class="n">cost_graph</span>

        <span class="n">cost_nmf_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">cost_nmf</span><span class="p">)</span>
        <span class="n">cost_graph_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">cost_graph</span><span class="p">)</span>
        <span class="n">cost_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">cost</span><span class="p">)</span>

        <span class="c1"># relative change in cost</span>
        <span class="n">diffcost</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">cost_list</span><span class="p">[</span><span class="nb">iter</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">cost_list</span><span class="p">[</span><span class="nb">iter</span><span class="p">])</span><span class="o">/</span><span class="n">cost_list</span><span class="p">[</span><span class="nb">iter</span><span class="p">])</span>

        <span class="c1"># relative primal residuals</span>
        <span class="n">res_W</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">norm</span><span class="p">(</span><span class="n">W</span><span class="o">-</span><span class="n">Wtil</span><span class="p">,</span><span class="s1">&#39;fro&#39;</span><span class="p">)</span><span class="o">/</span><span class="n">norm</span><span class="p">(</span><span class="n">W</span><span class="p">,</span><span class="s1">&#39;fro&#39;</span><span class="p">))</span>
        <span class="n">res_P</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">norm</span><span class="p">(</span><span class="n">P</span><span class="o">-</span><span class="n">Ptil</span><span class="p">,</span><span class="s1">&#39;fro&#39;</span><span class="p">)</span><span class="o">/</span><span class="n">norm</span><span class="p">(</span><span class="n">P</span><span class="p">,</span><span class="s1">&#39;fro&#39;</span><span class="p">))</span>
        <span class="n">res_H</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">norm</span><span class="p">(</span><span class="n">H</span><span class="o">-</span><span class="n">P</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">X</span><span class="p">),</span><span class="s1">&#39;fro&#39;</span><span class="p">)</span><span class="o">/</span><span class="n">norm</span><span class="p">(</span><span class="n">H</span><span class="p">,</span><span class="s1">&#39;fro&#39;</span><span class="p">))</span>
        <span class="n">res_Htil</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">norm</span><span class="p">(</span><span class="n">H</span><span class="o">-</span><span class="n">Htil</span><span class="p">,</span><span class="s1">&#39;fro&#39;</span><span class="p">)</span><span class="o">/</span><span class="n">norm</span><span class="p">(</span><span class="n">H</span><span class="p">,</span><span class="s1">&#39;fro&#39;</span><span class="p">))</span>

        <span class="c1"># relative change in basis matrix</span>
<span class="c1">#        diffW.append( norm(W-W_old,&#39;fro&#39;)/ norm(W_old, &#39;fro&#39;) )</span>

        <span class="c1">#=== termination check ====#</span>
        <span class="n">check_exit</span>  <span class="o">=</span> <span class="p">(</span><span class="n">diffcost</span><span class="p">[</span><span class="nb">iter</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">tol</span><span class="p">)</span>
        <span class="n">check_exit</span> <span class="o">&amp;=</span> <span class="p">(</span><span class="n">res_W</span><span class="p">[</span><span class="nb">iter</span><span class="p">]</span> <span class="o">&lt;</span>  <span class="n">tol</span><span class="p">)</span>
        <span class="n">check_exit</span> <span class="o">&amp;=</span> <span class="p">(</span><span class="n">res_P</span><span class="p">[</span><span class="nb">iter</span><span class="p">]</span> <span class="o">&lt;</span>  <span class="n">tol</span><span class="p">)</span>
        <span class="n">check_exit</span> <span class="o">&amp;=</span> <span class="p">(</span><span class="n">res_H</span><span class="p">[</span><span class="nb">iter</span><span class="p">]</span> <span class="o">&lt;</span>  <span class="n">tol</span><span class="p">)</span>
        <span class="n">check_exit</span> <span class="o">&amp;=</span> <span class="p">(</span><span class="n">res_Htil</span><span class="p">[</span><span class="nb">iter</span><span class="p">]</span> <span class="o">&lt;</span>  <span class="n">tol</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">check_exit</span> <span class="ow">and</span> <span class="nb">iter</span> <span class="o">&gt;</span> <span class="mi">300</span><span class="p">:</span> <span class="c1"># allow 300 iterations of &quot;burn-in&quot;</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">silence</span><span class="p">:</span>
                <span class="k">print</span> <span class="s2">&quot;Termination condition met.  Exit at iter =&quot;</span><span class="p">,</span><span class="nb">iter</span><span class="p">,</span>
            <span class="k">break</span>
        <span class="c1">#=============== print current progress ==============================#</span>
<span class="c1">#        if iter % disp_freq == 0:</span>
        <span class="k">if</span> <span class="p">(</span><span class="nb">iter</span><span class="o">&gt;</span><span class="mi">1</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="nb">iter</span> <span class="o">%</span> <span class="n">disp_freq</span> <span class="o">==</span> <span class="mi">0</span><span class="p">):</span>
<span class="c1">#            str_ = &quot;iter={:4} cost={:3.3f}&quot;.format(iter,cost_list[iter+1])</span>
            <span class="n">str_</span> <span class="o">=</span> <span class="s2">&quot;iter={:4} cost={:6.5e}&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">iter</span><span class="p">,</span><span class="n">cost</span><span class="p">)</span>
            <span class="n">str_</span> <span class="o">+=</span> <span class="s2">&quot; nmf={:3.2e}&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">cost_nmf</span><span class="p">)</span>
            <span class="n">str_</span> <span class="o">+=</span> <span class="s2">&quot; graph={:3.2e}&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">cost_graph</span><span class="p">)</span>
            <span class="n">str_</span> <span class="o">+=</span> <span class="s2">&quot; diffcost={:3.2e}&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">diffcost</span><span class="p">[</span><span class="nb">iter</span><span class="p">])</span>
            <span class="n">str_</span> <span class="o">+=</span> <span class="s2">&quot; W={:3.2e}&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">res_W</span><span class="p">[</span><span class="nb">iter</span><span class="p">])</span>
            <span class="n">str_</span> <span class="o">+=</span> <span class="s2">&quot; P={:3.2e}&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">res_P</span><span class="p">[</span><span class="nb">iter</span><span class="p">])</span>
            <span class="n">str_</span> <span class="o">+=</span> <span class="s2">&quot; H={:3.2e}&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">res_H</span><span class="p">[</span><span class="nb">iter</span><span class="p">])</span>
            <span class="n">str_</span> <span class="o">+=</span> <span class="s2">&quot; Htil={:3.2e}&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">res_Htil</span><span class="p">[</span><span class="nb">iter</span><span class="p">])</span>
<span class="c1">#            str_ += &quot; diffW={:3.2e}&quot;.format(diffW[iter])</span>
            <span class="k">print</span> <span class="n">str_</span> <span class="o">+</span> <span class="s2">&quot; ({:3.1f} sec)&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span><span class="o">-</span><span class="n">start</span><span class="p">)</span>
    <span class="c1">#%%---- end of admm for loop ---------------------------------------------#</span>
    <span class="n">cost_list</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">cost_list</span><span class="p">)</span>

    <span class="c1"># convert to pandas dataframe</span>
    <span class="n">cost</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">([</span><span class="n">cost_list</span><span class="p">,</span> <span class="n">cost_nmf_list</span><span class="p">,</span> <span class="n">cost_graph_list</span><span class="p">],</span>
                        <span class="n">index</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;total&#39;</span><span class="p">,</span><span class="s1">&#39;nmf&#39;</span><span class="p">,</span><span class="s1">&#39;graph&#39;</span><span class="p">])</span><span class="o">.</span><span class="n">T</span>

    <span class="n">res</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">([</span><span class="n">res_W</span><span class="p">,</span><span class="n">res_P</span><span class="p">,</span><span class="n">res_H</span><span class="p">,</span><span class="n">diffcost</span><span class="p">],</span>
                       <span class="n">index</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;res_W&#39;</span><span class="p">,</span><span class="s1">&#39;res_P&#39;</span><span class="p">,</span><span class="s1">&#39;res_H&#39;</span><span class="p">,</span><span class="s1">&#39;diffcost&#39;</span><span class="p">])</span><span class="o">.</span><span class="n">T</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">silence</span><span class="p">:</span> <span class="n">print_time</span><span class="p">(</span><span class="n">start</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">W</span><span class="p">,</span><span class="n">P</span><span class="p">,</span><span class="n">H</span><span class="p">,</span><span class="n">Wtil</span><span class="p">,</span><span class="n">Ptil</span><span class="p">,</span><span class="n">cost</span><span class="p">,</span><span class="n">res</span>


<span class="k">def</span> <span class="nf">sgpnmf_admm</span><span class="p">(</span><span class="n">X</span><span class="p">,</span><span class="n">r</span><span class="p">,</span><span class="n">L</span><span class="p">,</span><span class="n">tau</span><span class="o">=</span><span class="mf">1e-1</span><span class="p">,</span><span class="n">rho</span><span class="o">=</span><span class="mf">1e3</span><span class="p">,</span><span class="n">max_iter</span><span class="o">=</span><span class="mi">5000</span><span class="p">,</span><span class="n">tol</span><span class="o">=</span><span class="mf">1e-4</span><span class="p">,</span><span class="n">W_init</span><span class="o">=</span><span class="s1">&#39;nndsvd&#39;</span><span class="p">,</span>
               <span class="n">disp_freq</span><span class="o">=</span><span class="mi">1000</span><span class="p">,</span><span class="n">silence</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Spectral Graph regularized Spectral Projective NMF using ADMM.</span>

<span class="sd">    &gt;&gt;&gt; W,P,H,Wtil,Ptil,cost_list,res = gpnmf_admm(X,r,rho=5e2)</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    X : ndarray of shape (n_features, n_samples)=(p,n)</span>
<span class="sd">        Data matrix with columns as data points</span>
<span class="sd">    r : int</span>
<span class="sd">        Dimension of the embedding space (n_components)</span>
<span class="sd">    L : ndarray of shape = [n_samples, n_samples]</span>
<span class="sd">        Laplacian matrix.</span>
<span class="sd">    tau : float</span>
<span class="sd">        Amount of graph regularization to apply</span>
<span class="sd">    rho : float</span>
<span class="sd">        Augmented Lagrangian parameter</span>
<span class="sd">    max_iter : int</span>
<span class="sd">        max number of iterations</span>
<span class="sd">    tol : float</span>
<span class="sd">        convergence tolerance (on relative change in objective value and</span>
<span class="sd">        all primal residuals)</span>
<span class="sd">    W_init : None (default), rng, or &#39;nndsvd&#39;</span>
<span class="sd">        Way to initialize W (and H).  If ``None`` or ``RandomState object``</span>
<span class="sd">        is supplied, both W and H will be initialized via non-negative</span>
<span class="sd">        random number.  If ``&#39;nndsvd&#39;``, will use deterministic initialization</span>
<span class="sd">        NNDSVD &quot;Non-Negative Double Singular Value Decomposition&quot;, proposed by</span>
<span class="sd">        Boutsidis2008.</span>
<span class="sd">    disp_freq : int</span>
<span class="sd">        Frequency of update display (in iterations)</span>
<span class="sd">    silence : bool</span>
<span class="sd">        If True, don&#39;t print-out convergence detail at the end.</span>

<span class="sd">    Update history</span>
<span class="sd">    --------------</span>
<span class="sd">    **02/03/2016** - function created</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">rho</span> <span class="o">*=</span> <span class="mf">1.</span>
    <span class="n">tau</span> <span class="o">*=</span> <span class="mf">1.</span>
    <span class="n">p</span><span class="p">,</span><span class="n">n</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">shape</span>
    <span class="c1">#%%=== initialize variables =====</span>
    <span class="c1"># define main primal variable W (basis matrix)</span>
    <span class="k">if</span> <span class="n">W_init</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
        <span class="n">W</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="n">p</span><span class="p">,</span><span class="n">r</span><span class="p">)</span>
        <span class="n">W</span> <span class="o">/=</span> <span class="n">norm</span><span class="p">(</span><span class="n">W</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>

        <span class="n">H</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="n">r</span><span class="p">,</span><span class="n">n</span><span class="p">)</span>
        <span class="n">H</span> <span class="o">/=</span> <span class="n">norm</span><span class="p">(</span><span class="n">H</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">W_init</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">RandomState</span><span class="p">):</span>
        <span class="n">rng</span> <span class="o">=</span> <span class="n">W_init</span>

        <span class="n">W</span> <span class="o">=</span> <span class="n">rng</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="n">p</span><span class="p">,</span><span class="n">r</span><span class="p">)</span>
        <span class="n">W</span> <span class="o">/=</span> <span class="n">norm</span><span class="p">(</span><span class="n">W</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>

        <span class="n">H</span> <span class="o">=</span> <span class="n">rng</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="n">r</span><span class="p">,</span><span class="n">n</span><span class="p">)</span>
        <span class="n">H</span> <span class="o">/=</span> <span class="n">norm</span><span class="p">(</span><span class="n">H</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">W_init</span> <span class="o">==</span> <span class="s1">&#39;nndsvd&#39;</span><span class="p">:</span>
<span class="c1">#        W = nnd_svd(X,r)</span>
        <span class="n">W</span><span class="p">,</span><span class="n">H</span> <span class="o">=</span> <span class="n">nnd_svd</span><span class="p">(</span><span class="n">X</span><span class="p">,</span><span class="n">r</span><span class="p">,</span><span class="n">get_H</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Invalid input for &quot;W_init&quot;&#39;</span><span class="p">)</span>

    <span class="n">P</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">r</span><span class="p">,</span><span class="n">p</span><span class="p">))</span>
<span class="c1">#    P = np.random.rand(r,p)</span>

    <span class="c1"># aux. variables</span>
    <span class="n">Wtil</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">W</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
    <span class="n">W2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">W</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>  <span class="c1"># &lt;- for spectral projection</span>
    <span class="n">Ptil</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">P</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
    <span class="n">Htil</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">H</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="c1"># &lt;- for graph regularization</span>

    <span class="c1"># dual variables</span>
    <span class="n">Lam_W</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">W</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
    <span class="n">Lam_W2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">W</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="c1"># &lt;- for spectral projection</span>
    <span class="n">Lam_P</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">P</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
    <span class="n">Lam_H</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">H</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
    <span class="n">Lam_Htil</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">H</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="c1"># &lt;- for graph regularization</span>
    <span class="c1">#%%=== create empty lists for tracking updates ===</span>
    <span class="c1"># keep track of frobenius norm loss</span>
    <span class="n">cost_list</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">cost_nmf_list</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">cost_graph_list</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="n">cost_nmf</span> <span class="o">=</span> <span class="n">norm</span><span class="p">(</span><span class="n">Wtil</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">Ptil</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">X</span><span class="p">))</span> <span class="o">-</span> <span class="n">X</span><span class="p">,</span><span class="s1">&#39;fro&#39;</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="o">/</span><span class="mi">2</span>
    <span class="n">cost_graph</span> <span class="o">=</span> <span class="n">tau</span><span class="o">*</span><span class="n">trace</span><span class="p">(</span> <span class="n">L</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span> <span class="n">dot</span><span class="p">(</span><span class="n">Htil</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">Htil</span><span class="p">)))</span>
    <span class="n">cost</span> <span class="o">=</span> <span class="n">cost_nmf</span> <span class="o">+</span> <span class="n">cost_graph</span>

    <span class="n">cost_nmf_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">cost_nmf</span><span class="p">)</span>
    <span class="n">cost_graph_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">cost_graph</span><span class="p">)</span>
    <span class="n">cost_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">cost</span><span class="p">)</span>

    <span class="c1"># relative change in cost</span>
    <span class="n">diffcost</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="c1"># keep track of relative primal residual</span>
    <span class="n">res_W</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">res_W2</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">res_P</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">res_H</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">res_Htil</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="c1"># also keep track of diffW</span>
<span class="c1">#    diffW = []</span>
    <span class="c1">#%%=== run admm iterations ===</span>
    <span class="n">eye_r</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="n">r</span><span class="p">)</span>
    <span class="n">eye_n</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>

    <span class="c1"># precompute term needed for inversion lemma</span>
    <span class="n">K</span> <span class="o">=</span> <span class="n">solve</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="o">+</span> <span class="n">dot</span><span class="p">(</span><span class="n">X</span><span class="o">.</span><span class="n">T</span><span class="p">,</span><span class="n">X</span><span class="p">),</span> <span class="n">X</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>

    <span class="n">start</span><span class="o">=</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
    <span class="k">for</span> <span class="nb">iter</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">max_iter</span><span class="p">):</span>
<span class="c1">#        W_old = W #&lt;- to keep track of diffW</span>

        <span class="c1">#================ primal updates (P, W, H, Ptil, Wtil) ===============#</span>
        <span class="c1"># update for P involves inversion lemma...</span>
        <span class="n">_R</span> <span class="o">=</span> <span class="n">dot</span><span class="p">(</span><span class="n">X</span><span class="p">,</span><span class="n">Lam_H</span><span class="o">.</span><span class="n">T</span><span class="p">)</span><span class="o">/</span><span class="n">rho</span> <span class="o">-</span> <span class="n">Lam_P</span><span class="o">.</span><span class="n">T</span><span class="o">/</span><span class="n">rho</span> <span class="o">+</span> <span class="n">dot</span><span class="p">(</span><span class="n">X</span><span class="p">,</span><span class="n">H</span><span class="o">.</span><span class="n">T</span><span class="p">)</span> <span class="o">+</span> <span class="n">Ptil</span><span class="o">.</span><span class="n">T</span>
        <span class="n">P</span> <span class="o">=</span> <span class="p">(</span><span class="n">_R</span> <span class="o">-</span> <span class="n">X</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span> <span class="n">dot</span><span class="p">(</span><span class="n">K</span><span class="p">,</span><span class="n">_R</span><span class="p">)</span> <span class="p">))</span><span class="o">.</span><span class="n">T</span>
        <span class="n">Ptil</span> <span class="o">=</span> <span class="p">(</span><span class="n">P</span><span class="o">+</span><span class="n">Lam_P</span><span class="o">/</span><span class="n">rho</span><span class="p">)</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>

        <span class="c1"># (W,H) updates</span>
        <span class="n">H</span> <span class="o">=</span> <span class="n">solve</span><span class="p">(</span><span class="n">dot</span><span class="p">(</span><span class="n">W</span><span class="o">.</span><span class="n">T</span><span class="p">,</span><span class="n">W</span><span class="p">)</span><span class="o">+</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">rho</span><span class="p">)</span><span class="o">*</span><span class="n">eye_r</span><span class="p">,</span>
                  <span class="n">dot</span><span class="p">(</span><span class="n">W</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">X</span><span class="p">)</span> <span class="o">+</span> <span class="n">rho</span><span class="o">*</span><span class="n">dot</span><span class="p">(</span><span class="n">P</span><span class="p">,</span><span class="n">X</span><span class="p">)</span> <span class="o">-</span> <span class="n">Lam_H</span> <span class="o">+</span> <span class="n">rho</span><span class="o">*</span><span class="n">Htil</span> <span class="o">-</span> <span class="n">Lam_Htil</span> <span class="p">)</span>
        <span class="n">W</span> <span class="o">=</span> <span class="n">solve</span><span class="p">(</span><span class="n">dot</span><span class="p">(</span><span class="n">H</span><span class="p">,</span><span class="n">H</span><span class="o">.</span><span class="n">T</span><span class="p">)</span><span class="o">+</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">rho</span><span class="p">)</span><span class="o">*</span><span class="n">eye_r</span><span class="p">,</span>
                  <span class="n">dot</span><span class="p">(</span><span class="n">H</span><span class="p">,</span> <span class="n">X</span><span class="o">.</span><span class="n">T</span><span class="p">)</span> <span class="o">+</span> <span class="n">rho</span><span class="o">*</span><span class="n">Wtil</span><span class="o">.</span><span class="n">T</span> <span class="o">-</span> <span class="n">Lam_W</span><span class="o">.</span><span class="n">T</span> <span class="o">+</span> <span class="n">rho</span><span class="o">*</span><span class="n">W2</span><span class="o">.</span><span class="n">T</span> <span class="o">-</span> <span class="n">Lam_W2</span><span class="o">.</span><span class="n">T</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>
        <span class="n">Wtil</span> <span class="o">=</span> <span class="p">(</span><span class="n">W</span><span class="o">+</span><span class="n">Lam_W</span><span class="o">/</span><span class="n">rho</span><span class="p">)</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>

        <span class="n">W2</span> <span class="o">=</span> <span class="n">projection_spectral</span><span class="p">(</span><span class="n">W</span> <span class="o">+</span> <span class="n">Lam_W2</span><span class="o">/</span><span class="n">rho</span><span class="p">)</span>

        <span class="n">Htil</span> <span class="o">=</span> <span class="n">solve</span><span class="p">(</span><span class="n">tau</span><span class="o">*</span><span class="n">L</span> <span class="o">+</span> <span class="n">rho</span><span class="o">*</span><span class="n">eye_n</span><span class="p">,</span> <span class="n">rho</span><span class="o">*</span><span class="n">H</span><span class="o">.</span><span class="n">T</span><span class="o">+</span><span class="n">Lam_Htil</span><span class="o">.</span><span class="n">T</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>

        <span class="c1">#====================== dual updates =================================#</span>
        <span class="n">Lam_W</span> <span class="o">=</span> <span class="n">Lam_W</span> <span class="o">+</span> <span class="n">rho</span><span class="o">*</span><span class="p">(</span><span class="n">W</span> <span class="o">-</span> <span class="n">Wtil</span><span class="p">)</span>
        <span class="n">Lam_W2</span> <span class="o">=</span> <span class="n">Lam_W2</span> <span class="o">+</span> <span class="n">rho</span><span class="o">*</span><span class="p">(</span><span class="n">W</span> <span class="o">-</span> <span class="n">W2</span><span class="p">)</span>
        <span class="n">Lam_P</span> <span class="o">=</span> <span class="n">Lam_P</span> <span class="o">+</span> <span class="n">rho</span><span class="o">*</span><span class="p">(</span><span class="n">P</span> <span class="o">-</span> <span class="n">Ptil</span><span class="p">)</span>
        <span class="n">Lam_H</span> <span class="o">=</span> <span class="n">Lam_H</span> <span class="o">+</span> <span class="n">rho</span><span class="o">*</span><span class="p">(</span><span class="n">H</span> <span class="o">-</span> <span class="n">dot</span><span class="p">(</span><span class="n">P</span><span class="p">,</span><span class="n">X</span><span class="p">))</span>
        <span class="n">Lam_Htil</span> <span class="o">=</span> <span class="n">Lam_Htil</span> <span class="o">+</span> <span class="n">rho</span><span class="o">*</span><span class="p">(</span><span class="n">H</span><span class="o">-</span><span class="n">Htil</span><span class="p">)</span>

        <span class="c1">#============ comptute objective values ==============================#</span>
        <span class="c1"># main loss function</span>
        <span class="n">cost_nmf</span> <span class="o">=</span> <span class="n">norm</span><span class="p">(</span><span class="n">Wtil</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">Ptil</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">X</span><span class="p">))</span> <span class="o">-</span> <span class="n">X</span><span class="p">,</span><span class="s1">&#39;fro&#39;</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="o">/</span><span class="mi">2</span>
        <span class="n">cost_graph</span> <span class="o">=</span> <span class="n">tau</span><span class="o">*</span><span class="n">trace</span><span class="p">(</span> <span class="n">L</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span> <span class="n">dot</span><span class="p">(</span><span class="n">Htil</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">Htil</span><span class="p">)))</span>
        <span class="n">cost</span> <span class="o">=</span> <span class="n">cost_nmf</span> <span class="o">+</span> <span class="n">cost_graph</span>

        <span class="n">cost_nmf_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">cost_nmf</span><span class="p">)</span>
        <span class="n">cost_graph_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">cost_graph</span><span class="p">)</span>
        <span class="n">cost_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">cost</span><span class="p">)</span>

        <span class="c1"># relative change in cost</span>
        <span class="n">diffcost</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">cost_list</span><span class="p">[</span><span class="nb">iter</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">cost_list</span><span class="p">[</span><span class="nb">iter</span><span class="p">])</span><span class="o">/</span><span class="n">cost_list</span><span class="p">[</span><span class="nb">iter</span><span class="p">])</span>

        <span class="c1"># relative primal residuals</span>
        <span class="n">res_W</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">norm</span><span class="p">(</span><span class="n">W</span><span class="o">-</span><span class="n">Wtil</span><span class="p">,</span><span class="s1">&#39;fro&#39;</span><span class="p">)</span><span class="o">/</span><span class="n">norm</span><span class="p">(</span><span class="n">W</span><span class="p">,</span><span class="s1">&#39;fro&#39;</span><span class="p">))</span>
        <span class="n">res_W2</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">norm</span><span class="p">(</span><span class="n">W</span><span class="o">-</span><span class="n">W2</span><span class="p">,</span><span class="s1">&#39;fro&#39;</span><span class="p">)</span><span class="o">/</span><span class="n">norm</span><span class="p">(</span><span class="n">W</span><span class="p">,</span><span class="s1">&#39;fro&#39;</span><span class="p">))</span>
        <span class="n">res_P</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">norm</span><span class="p">(</span><span class="n">P</span><span class="o">-</span><span class="n">Ptil</span><span class="p">,</span><span class="s1">&#39;fro&#39;</span><span class="p">)</span><span class="o">/</span><span class="n">norm</span><span class="p">(</span><span class="n">P</span><span class="p">,</span><span class="s1">&#39;fro&#39;</span><span class="p">))</span>
        <span class="n">res_H</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">norm</span><span class="p">(</span><span class="n">H</span><span class="o">-</span><span class="n">P</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">X</span><span class="p">),</span><span class="s1">&#39;fro&#39;</span><span class="p">)</span><span class="o">/</span><span class="n">norm</span><span class="p">(</span><span class="n">H</span><span class="p">,</span><span class="s1">&#39;fro&#39;</span><span class="p">))</span>
        <span class="n">res_Htil</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">norm</span><span class="p">(</span><span class="n">H</span><span class="o">-</span><span class="n">Htil</span><span class="p">,</span><span class="s1">&#39;fro&#39;</span><span class="p">)</span><span class="o">/</span><span class="n">norm</span><span class="p">(</span><span class="n">H</span><span class="p">,</span><span class="s1">&#39;fro&#39;</span><span class="p">))</span>

        <span class="c1"># relative change in basis matrix</span>
<span class="c1">#        diffW.append( norm(W-W_old,&#39;fro&#39;)/ norm(W_old, &#39;fro&#39;) )</span>

        <span class="c1">#=== termination check ====#</span>
        <span class="n">check_exit</span>  <span class="o">=</span> <span class="p">(</span><span class="n">diffcost</span><span class="p">[</span><span class="nb">iter</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">tol</span><span class="p">)</span>
        <span class="n">check_exit</span> <span class="o">&amp;=</span> <span class="p">(</span><span class="n">res_W</span><span class="p">[</span><span class="nb">iter</span><span class="p">]</span> <span class="o">&lt;</span>  <span class="n">tol</span><span class="p">)</span>
        <span class="n">check_exit</span> <span class="o">&amp;=</span> <span class="p">(</span><span class="n">res_W2</span><span class="p">[</span><span class="nb">iter</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">tol</span><span class="p">)</span>
        <span class="n">check_exit</span> <span class="o">&amp;=</span> <span class="p">(</span><span class="n">res_P</span><span class="p">[</span><span class="nb">iter</span><span class="p">]</span> <span class="o">&lt;</span>  <span class="n">tol</span><span class="p">)</span>
        <span class="n">check_exit</span> <span class="o">&amp;=</span> <span class="p">(</span><span class="n">res_H</span><span class="p">[</span><span class="nb">iter</span><span class="p">]</span> <span class="o">&lt;</span>  <span class="n">tol</span><span class="p">)</span>
        <span class="n">check_exit</span> <span class="o">&amp;=</span> <span class="p">(</span><span class="n">res_Htil</span><span class="p">[</span><span class="nb">iter</span><span class="p">]</span> <span class="o">&lt;</span>  <span class="n">tol</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">check_exit</span> <span class="ow">and</span> <span class="nb">iter</span> <span class="o">&gt;</span> <span class="mi">300</span><span class="p">:</span> <span class="c1"># allow 300 iterations of &quot;burn-in&quot;</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">silence</span><span class="p">:</span>
                <span class="k">print</span> <span class="s2">&quot;Termination condition met.  Exit at iter =&quot;</span><span class="p">,</span><span class="nb">iter</span><span class="p">,</span>
            <span class="k">break</span>
        <span class="c1">#=============== print current progress ==============================#</span>
<span class="c1">#        if iter % disp_freq == 0:</span>
        <span class="k">if</span> <span class="p">(</span><span class="nb">iter</span><span class="o">&gt;</span><span class="mi">1</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="nb">iter</span> <span class="o">%</span> <span class="n">disp_freq</span> <span class="o">==</span> <span class="mi">0</span><span class="p">):</span>
<span class="c1">#            str_ = &quot;iter={:4} cost={:3.3f}&quot;.format(iter,cost_list[iter+1])</span>
            <span class="n">str_</span> <span class="o">=</span> <span class="s2">&quot;iter={:4} cost={:6.5e}&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">iter</span><span class="p">,</span><span class="n">cost</span><span class="p">)</span>
            <span class="n">str_</span> <span class="o">+=</span> <span class="s2">&quot; nmf={:3.2e}&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">cost_nmf</span><span class="p">)</span>
            <span class="n">str_</span> <span class="o">+=</span> <span class="s2">&quot; G={:3.2e}&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">cost_graph</span><span class="p">)</span>
            <span class="n">str_</span> <span class="o">+=</span> <span class="s2">&quot; diffcost={:3.2e}&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">diffcost</span><span class="p">[</span><span class="nb">iter</span><span class="p">])</span>
            <span class="n">str_</span> <span class="o">+=</span> <span class="s2">&quot; W={:3.2e}&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">res_W</span><span class="p">[</span><span class="nb">iter</span><span class="p">])</span>
            <span class="n">str_</span> <span class="o">+=</span> <span class="s2">&quot; W2={:3.2e}&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">res_W2</span><span class="p">[</span><span class="nb">iter</span><span class="p">])</span>
            <span class="n">str_</span> <span class="o">+=</span> <span class="s2">&quot; P={:3.2e}&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">res_P</span><span class="p">[</span><span class="nb">iter</span><span class="p">])</span>
            <span class="n">str_</span> <span class="o">+=</span> <span class="s2">&quot; H={:3.2e}&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">res_H</span><span class="p">[</span><span class="nb">iter</span><span class="p">])</span>
            <span class="n">str_</span> <span class="o">+=</span> <span class="s2">&quot; H2={:3.2e}&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">res_Htil</span><span class="p">[</span><span class="nb">iter</span><span class="p">])</span>
<span class="c1">#            str_ += &quot; diffW={:3.2e}&quot;.format(diffW[iter])</span>
            <span class="k">print</span> <span class="n">str_</span> <span class="o">+</span> <span class="s2">&quot; ({:3.1f} sec)&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span><span class="o">-</span><span class="n">start</span><span class="p">)</span>
    <span class="c1">#%%---- end of admm for loop ---------------------------------------------#</span>
    <span class="n">cost_list</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">cost_list</span><span class="p">)</span>

    <span class="c1"># convert to pandas dataframe</span>
    <span class="n">cost</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">([</span><span class="n">cost_list</span><span class="p">,</span> <span class="n">cost_nmf_list</span><span class="p">,</span> <span class="n">cost_graph_list</span><span class="p">],</span>
                        <span class="n">index</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;total&#39;</span><span class="p">,</span><span class="s1">&#39;nmf&#39;</span><span class="p">,</span><span class="s1">&#39;graph&#39;</span><span class="p">])</span><span class="o">.</span><span class="n">T</span>

    <span class="n">res</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">([</span><span class="n">res_W</span><span class="p">,</span><span class="n">res_W2</span><span class="p">,</span><span class="n">res_P</span><span class="p">,</span><span class="n">res_H</span><span class="p">,</span><span class="n">diffcost</span><span class="p">],</span>
                       <span class="n">index</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;res_W&#39;</span><span class="p">,</span><span class="s1">&#39;res_W2&#39;</span><span class="p">,</span><span class="s1">&#39;res_P&#39;</span><span class="p">,</span><span class="s1">&#39;res_H&#39;</span><span class="p">,</span><span class="s1">&#39;diffcost&#39;</span><span class="p">])</span><span class="o">.</span><span class="n">T</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">silence</span><span class="p">:</span> <span class="n">print_time</span><span class="p">(</span><span class="n">start</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">W</span><span class="p">,</span><span class="n">P</span><span class="p">,</span><span class="n">H</span><span class="p">,</span><span class="n">Wtil</span><span class="p">,</span><span class="n">Ptil</span><span class="p">,</span><span class="n">cost</span><span class="p">,</span><span class="n">res</span>


<span class="k">def</span> <span class="nf">ls_sgpnmf_admm</span><span class="p">(</span><span class="n">X</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">r</span><span class="p">,</span><span class="n">L</span><span class="p">,</span><span class="n">tau</span><span class="o">=</span><span class="mf">1e-1</span><span class="p">,</span><span class="n">gam</span><span class="o">=</span><span class="mf">1e-1</span><span class="p">,</span><span class="n">gam2</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span><span class="n">rho</span><span class="o">=</span><span class="mf">1e3</span><span class="p">,</span><span class="n">max_iter</span><span class="o">=</span><span class="mi">5000</span><span class="p">,</span>
                   <span class="n">tol</span><span class="o">=</span><span class="mf">1e-4</span><span class="p">,</span><span class="n">W_init</span><span class="o">=</span><span class="s1">&#39;nndsvd&#39;</span><span class="p">,</span><span class="n">disp_freq</span><span class="o">=</span><span class="mi">1000</span><span class="p">,</span><span class="n">silence</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span>
                   <span class="n">add_intercept</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Graph regularized Spectral Projective NMF using ADMM.</span>

<span class="sd">    &gt;&gt;&gt; W,P,H,w,Wtil,Ptil,cost,res = ls_sgpnmf_admm(X,y,r,L,rho=5e2)</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    X : ndarray of shape (n_features, n_samples)=(p,n)</span>
<span class="sd">        Data matrix with columns as data points</span>
<span class="sd">    y : array-like of shape [n_samples,]</span>
<span class="sd">        Label vector</span>
<span class="sd">    r : int</span>
<span class="sd">        Dimension of the embedding space (n_components)</span>
<span class="sd">    L : ndarray of shape = [n_samples, n_samples]</span>
<span class="sd">        Laplacian matrix.</span>
<span class="sd">    tau : float</span>
<span class="sd">        Amount of graph regularization to apply</span>
<span class="sd">    gam : float</span>
<span class="sd">        Amount of weight on the classification loss</span>
<span class="sd">    gam2 : float (default=0)</span>
<span class="sd">        Amount of regularization on the classifier (results in ridge regression</span>
<span class="sd">        update)</span>
<span class="sd">    rho : float</span>
<span class="sd">        Augmented Lagrangian parameter</span>
<span class="sd">    max_iter : int</span>
<span class="sd">        max number of iterations</span>
<span class="sd">    tol : float</span>
<span class="sd">        convergence tolerance (on relative change in objective value and</span>
<span class="sd">        all primal residuals)</span>
<span class="sd">    W_init : None, rng, or &#39;nndsvd&#39;</span>
<span class="sd">        Way to initialize W (and H).  If ``None`` or ``RandomState object``</span>
<span class="sd">        is supplied, both W and H will be initialized via non-negative</span>
<span class="sd">        random number.  If ``&#39;nndsvd&#39;``, will use deterministic initialization</span>
<span class="sd">        NNDSVD &quot;Non-Negative Double Singular Value Decomposition&quot;, proposed by</span>
<span class="sd">        Boutsidis2008.</span>
<span class="sd">    disp_freq : int</span>
<span class="sd">        Frequency of update display (in iterations)</span>
<span class="sd">    silence : bool</span>
<span class="sd">        If True, don&#39;t print-out convergence detail at the end</span>
<span class="sd">    add_intercept : bool (default=False)</span>
<span class="sd">        Add intercept term to classifier (added 02/16/2016)</span>

<span class="sd">    Update history</span>
<span class="sd">    --------------</span>
<span class="sd">    **02/04/2016** - function created</span>

<span class="sd">    **02/16/2016** - added ``add_intercept`` option</span>

<span class="sd">    **07/11/2016** - added keyboard interrupt</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">rho</span> <span class="o">*=</span> <span class="mf">1.</span>
    <span class="n">tau</span> <span class="o">*=</span> <span class="mf">1.</span>
    <span class="n">gam</span> <span class="o">*=</span> <span class="mf">1.</span>
    <span class="n">gam2</span> <span class="o">*=</span> <span class="mf">1.</span>
    <span class="n">p</span><span class="p">,</span><span class="n">n</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">shape</span>
    <span class="c1">#%%=== initialize variables =====</span>
    <span class="c1"># define main primal variable W (basis matrix)</span>
    <span class="k">if</span> <span class="n">W_init</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
        <span class="n">W</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="n">p</span><span class="p">,</span><span class="n">r</span><span class="p">)</span>
        <span class="n">W</span> <span class="o">/=</span> <span class="n">norm</span><span class="p">(</span><span class="n">W</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>

        <span class="n">H</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="n">r</span><span class="p">,</span><span class="n">n</span><span class="p">)</span>
        <span class="n">H</span> <span class="o">/=</span> <span class="n">norm</span><span class="p">(</span><span class="n">H</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">W_init</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">RandomState</span><span class="p">):</span>
        <span class="n">rng</span> <span class="o">=</span> <span class="n">W_init</span>

        <span class="n">W</span> <span class="o">=</span> <span class="n">rng</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="n">p</span><span class="p">,</span><span class="n">r</span><span class="p">)</span>
        <span class="n">W</span> <span class="o">/=</span> <span class="n">norm</span><span class="p">(</span><span class="n">W</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>

        <span class="n">H</span> <span class="o">=</span> <span class="n">rng</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="n">r</span><span class="p">,</span><span class="n">n</span><span class="p">)</span>
        <span class="n">H</span> <span class="o">/=</span> <span class="n">norm</span><span class="p">(</span><span class="n">H</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">W_init</span> <span class="o">==</span> <span class="s1">&#39;nndsvd&#39;</span><span class="p">:</span>
<span class="c1">#        W = nnd_svd(X,r)</span>
        <span class="n">W</span><span class="p">,</span><span class="n">H</span> <span class="o">=</span> <span class="n">nnd_svd</span><span class="p">(</span><span class="n">X</span><span class="p">,</span><span class="n">r</span><span class="p">,</span><span class="n">get_H</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Invalid input for &quot;W_init&quot;&#39;</span><span class="p">)</span>

    <span class="n">P</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">r</span><span class="p">,</span><span class="n">p</span><span class="p">))</span>
<span class="c1">#    P = np.random.rand(r,p)</span>

    <span class="k">if</span> <span class="n">add_intercept</span><span class="p">:</span>
        <span class="n">w</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">r</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="c1"># &lt;- classification vector</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">w</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">r</span><span class="p">)</span> <span class="c1"># &lt;- classification vector</span>

    <span class="c1"># aux. variables</span>
    <span class="n">Wtil</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">W</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
    <span class="n">W2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">W</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>  <span class="c1"># &lt;- for spectral projection</span>
    <span class="n">Ptil</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">P</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
    <span class="n">Htil</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">H</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="c1"># &lt;- for graph regularization</span>

    <span class="c1"># dual variables</span>
    <span class="n">Lam_W</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">W</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
    <span class="n">Lam_W2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">W</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="c1"># &lt;- for spectral projection</span>
    <span class="n">Lam_P</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">P</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
    <span class="n">Lam_H</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">H</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
    <span class="n">Lam_Htil</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">H</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="c1"># &lt;- for graph regularization</span>
    <span class="c1">#%%=== create empty lists for tracking updates ===</span>
    <span class="c1"># keep track of frobenius norm loss</span>
    <span class="n">cost_list</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">cost_ls_list</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">cost_nmf_list</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">cost_graph_list</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="n">PX</span> <span class="o">=</span> <span class="n">Ptil</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>
    <span class="n">cost_nmf</span> <span class="o">=</span> <span class="n">norm</span><span class="p">(</span><span class="n">Wtil</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">PX</span><span class="p">)</span> <span class="o">-</span> <span class="n">X</span><span class="p">,</span><span class="s1">&#39;fro&#39;</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="o">/</span><span class="mi">2</span>
    <span class="k">if</span> <span class="n">add_intercept</span><span class="p">:</span>
        <span class="c1"># used for the least-squares term</span>
        <span class="n">one_n</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
        <span class="n">PX</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="n">PX</span><span class="p">,</span><span class="n">one_n</span><span class="p">))</span>
    <span class="n">cost_ls</span>  <span class="o">=</span> <span class="n">gam</span><span class="o">*</span><span class="n">norm</span><span class="p">(</span><span class="n">y</span> <span class="o">-</span> <span class="n">PX</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">w</span><span class="p">))</span> <span class="o">**</span><span class="mi">2</span><span class="o">/</span><span class="mi">2</span> <span class="o">+</span> <span class="n">gam2</span><span class="o">*</span><span class="n">norm</span><span class="p">(</span><span class="n">w</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="o">/</span><span class="mi">2</span>
    <span class="n">cost_graph</span> <span class="o">=</span> <span class="n">tau</span><span class="o">*</span><span class="n">trace</span><span class="p">(</span> <span class="n">L</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span> <span class="n">dot</span><span class="p">(</span><span class="n">Htil</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">Htil</span><span class="p">)))</span>
    <span class="n">cost</span> <span class="o">=</span> <span class="n">cost_nmf</span> <span class="o">+</span> <span class="n">cost_graph</span> <span class="o">+</span> <span class="n">cost_ls</span>

    <span class="n">cost_nmf_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">cost_nmf</span><span class="p">)</span>
    <span class="n">cost_ls_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">cost_ls</span><span class="p">)</span>
    <span class="n">cost_graph_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">cost_graph</span><span class="p">)</span>
    <span class="n">cost_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">cost</span><span class="p">)</span>

    <span class="c1"># relative change in cost</span>
    <span class="n">diffcost</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="c1"># keep track of relative primal residual</span>
    <span class="n">res_W</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">res_W2</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">res_P</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">res_H</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">res_Htil</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="c1"># also keep track of diffW</span>
<span class="c1">#    diffW = []</span>
    <span class="c1">#%%=== run admm iterations ===</span>
    <span class="n">eye_r</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="n">r</span><span class="p">)</span>
    <span class="n">eye_n</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>

    <span class="c1"># precompute term needed for inversion lemma</span>
    <span class="n">K</span> <span class="o">=</span> <span class="n">solve</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="o">+</span> <span class="n">dot</span><span class="p">(</span><span class="n">X</span><span class="o">.</span><span class="n">T</span><span class="p">,</span><span class="n">X</span><span class="p">),</span> <span class="n">X</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>

    <span class="n">start</span><span class="o">=</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
    <span class="k">for</span> <span class="nb">iter</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">max_iter</span><span class="p">):</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="c1">#W_old = W #&lt;- to keep track of diffW</span>
            <span class="c1">#================ primal updates (P, W, H, Ptil, Wtil) ===============#</span>
            <span class="c1"># update for P involves inversion lemma...</span>
            <span class="n">_R</span> <span class="o">=</span> <span class="n">dot</span><span class="p">(</span><span class="n">X</span><span class="p">,</span><span class="n">Lam_H</span><span class="o">.</span><span class="n">T</span><span class="p">)</span><span class="o">/</span><span class="n">rho</span> <span class="o">-</span> <span class="n">Lam_P</span><span class="o">.</span><span class="n">T</span><span class="o">/</span><span class="n">rho</span> <span class="o">+</span> <span class="n">dot</span><span class="p">(</span><span class="n">X</span><span class="p">,</span><span class="n">H</span><span class="o">.</span><span class="n">T</span><span class="p">)</span> <span class="o">+</span> <span class="n">Ptil</span><span class="o">.</span><span class="n">T</span>
            <span class="n">P</span> <span class="o">=</span> <span class="p">(</span><span class="n">_R</span> <span class="o">-</span> <span class="n">X</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span> <span class="n">dot</span><span class="p">(</span><span class="n">K</span><span class="p">,</span><span class="n">_R</span><span class="p">)</span> <span class="p">))</span><span class="o">.</span><span class="n">T</span>
            <span class="n">Ptil</span> <span class="o">=</span> <span class="p">(</span><span class="n">P</span><span class="o">+</span><span class="n">Lam_P</span><span class="o">/</span><span class="n">rho</span><span class="p">)</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
    
            <span class="c1"># (W,H) updates</span>
            <span class="k">if</span> <span class="n">add_intercept</span><span class="p">:</span>
                <span class="n">ytil</span> <span class="o">=</span> <span class="n">y</span> <span class="o">-</span> <span class="n">one_n</span><span class="o">*</span><span class="n">w</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
                <span class="n">H</span> <span class="o">=</span> <span class="n">solve</span><span class="p">(</span><span class="n">dot</span><span class="p">(</span><span class="n">W</span><span class="o">.</span><span class="n">T</span><span class="p">,</span><span class="n">W</span><span class="p">)</span><span class="o">+</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">rho</span><span class="p">)</span><span class="o">*</span><span class="n">eye_r</span> <span class="o">+</span> <span class="n">gam</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">outer</span><span class="p">(</span><span class="n">w</span><span class="p">[:</span><span class="n">r</span><span class="p">],</span><span class="n">w</span><span class="p">[:</span><span class="n">r</span><span class="p">]),</span>
                          <span class="n">dot</span><span class="p">(</span><span class="n">W</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">X</span><span class="p">)</span> <span class="o">+</span> <span class="n">rho</span><span class="o">*</span><span class="n">dot</span><span class="p">(</span><span class="n">P</span><span class="p">,</span><span class="n">X</span><span class="p">)</span> <span class="o">-</span> <span class="n">Lam_H</span> <span class="o">+</span> <span class="n">rho</span><span class="o">*</span><span class="n">Htil</span> <span class="o">-</span>
                          <span class="n">Lam_Htil</span> <span class="o">+</span> <span class="n">gam</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">outer</span><span class="p">(</span><span class="n">w</span><span class="p">[:</span><span class="n">r</span><span class="p">],</span><span class="n">ytil</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">H</span> <span class="o">=</span> <span class="n">solve</span><span class="p">(</span><span class="n">dot</span><span class="p">(</span><span class="n">W</span><span class="o">.</span><span class="n">T</span><span class="p">,</span><span class="n">W</span><span class="p">)</span><span class="o">+</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">rho</span><span class="p">)</span><span class="o">*</span><span class="n">eye_r</span> <span class="o">+</span> <span class="n">gam</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">outer</span><span class="p">(</span><span class="n">w</span><span class="p">,</span><span class="n">w</span><span class="p">),</span>
                          <span class="n">dot</span><span class="p">(</span><span class="n">W</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">X</span><span class="p">)</span> <span class="o">+</span> <span class="n">rho</span><span class="o">*</span><span class="n">dot</span><span class="p">(</span><span class="n">P</span><span class="p">,</span><span class="n">X</span><span class="p">)</span> <span class="o">-</span> <span class="n">Lam_H</span> <span class="o">+</span> <span class="n">rho</span><span class="o">*</span><span class="n">Htil</span> <span class="o">-</span>
                          <span class="n">Lam_Htil</span> <span class="o">+</span> <span class="n">gam</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">outer</span><span class="p">(</span><span class="n">w</span><span class="p">,</span><span class="n">y</span><span class="p">))</span>
            <span class="n">W</span> <span class="o">=</span> <span class="n">solve</span><span class="p">(</span><span class="n">dot</span><span class="p">(</span><span class="n">H</span><span class="p">,</span><span class="n">H</span><span class="o">.</span><span class="n">T</span><span class="p">)</span><span class="o">+</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">rho</span><span class="p">)</span><span class="o">*</span><span class="n">eye_r</span><span class="p">,</span>
                      <span class="n">dot</span><span class="p">(</span><span class="n">H</span><span class="p">,</span> <span class="n">X</span><span class="o">.</span><span class="n">T</span><span class="p">)</span> <span class="o">+</span> <span class="n">rho</span><span class="o">*</span><span class="n">Wtil</span><span class="o">.</span><span class="n">T</span> <span class="o">-</span> <span class="n">Lam_W</span><span class="o">.</span><span class="n">T</span> <span class="o">+</span> <span class="n">rho</span><span class="o">*</span><span class="n">W2</span><span class="o">.</span><span class="n">T</span> <span class="o">-</span> <span class="n">Lam_W2</span><span class="o">.</span><span class="n">T</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>
            <span class="n">Wtil</span> <span class="o">=</span> <span class="p">(</span><span class="n">W</span><span class="o">+</span><span class="n">Lam_W</span><span class="o">/</span><span class="n">rho</span><span class="p">)</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
    
            <span class="n">W2</span> <span class="o">=</span> <span class="n">projection_spectral</span><span class="p">(</span><span class="n">W</span> <span class="o">+</span> <span class="n">Lam_W2</span><span class="o">/</span><span class="n">rho</span><span class="p">)</span>
    
            <span class="n">Htil</span> <span class="o">=</span> <span class="n">solve</span><span class="p">(</span><span class="n">tau</span><span class="o">*</span><span class="n">L</span> <span class="o">+</span> <span class="n">rho</span><span class="o">*</span><span class="n">eye_n</span><span class="p">,</span> <span class="n">rho</span><span class="o">*</span><span class="n">H</span><span class="o">.</span><span class="n">T</span><span class="o">+</span><span class="n">Lam_Htil</span><span class="o">.</span><span class="n">T</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>
    
            <span class="k">if</span> <span class="n">add_intercept</span><span class="p">:</span>
                <span class="c1"># H with intercept</span>
                <span class="n">H_</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="n">H</span><span class="p">,</span><span class="n">one_n</span><span class="p">))</span>
                <span class="c1"># for now, ignore gam2 regularizer...i never use them</span>
                <span class="n">w</span> <span class="o">=</span> <span class="n">solve</span><span class="p">(</span> <span class="n">H_</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">H_</span><span class="o">.</span><span class="n">T</span><span class="p">),</span> <span class="n">H_</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">y</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">w</span> <span class="o">=</span> <span class="n">solve</span><span class="p">(</span> <span class="n">H</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">H</span><span class="o">.</span><span class="n">T</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="n">gam2</span><span class="o">/</span><span class="n">gam</span><span class="p">)</span><span class="o">*</span><span class="n">eye_r</span><span class="p">,</span> <span class="n">H</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">y</span><span class="p">))</span>
    
            <span class="c1">#====================== dual updates =================================#</span>
            <span class="n">Lam_W</span> <span class="o">=</span> <span class="n">Lam_W</span> <span class="o">+</span> <span class="n">rho</span><span class="o">*</span><span class="p">(</span><span class="n">W</span> <span class="o">-</span> <span class="n">Wtil</span><span class="p">)</span>
            <span class="n">Lam_W2</span> <span class="o">=</span> <span class="n">Lam_W2</span> <span class="o">+</span> <span class="n">rho</span><span class="o">*</span><span class="p">(</span><span class="n">W</span> <span class="o">-</span> <span class="n">W2</span><span class="p">)</span>
            <span class="n">Lam_P</span> <span class="o">=</span> <span class="n">Lam_P</span> <span class="o">+</span> <span class="n">rho</span><span class="o">*</span><span class="p">(</span><span class="n">P</span> <span class="o">-</span> <span class="n">Ptil</span><span class="p">)</span>
            <span class="n">Lam_H</span> <span class="o">=</span> <span class="n">Lam_H</span> <span class="o">+</span> <span class="n">rho</span><span class="o">*</span><span class="p">(</span><span class="n">H</span> <span class="o">-</span> <span class="n">dot</span><span class="p">(</span><span class="n">P</span><span class="p">,</span><span class="n">X</span><span class="p">))</span>
            <span class="n">Lam_Htil</span> <span class="o">=</span> <span class="n">Lam_Htil</span> <span class="o">+</span> <span class="n">rho</span><span class="o">*</span><span class="p">(</span><span class="n">H</span><span class="o">-</span><span class="n">Htil</span><span class="p">)</span>
    
            <span class="c1">#============ comptute objective values ==============================#</span>
            <span class="c1"># main loss function</span>
            <span class="n">PX</span> <span class="o">=</span> <span class="n">Ptil</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>
            <span class="n">cost_nmf</span> <span class="o">=</span> <span class="n">norm</span><span class="p">(</span><span class="n">Wtil</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">PX</span><span class="p">)</span> <span class="o">-</span> <span class="n">X</span><span class="p">,</span><span class="s1">&#39;fro&#39;</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="o">/</span><span class="mi">2</span>
            <span class="k">if</span> <span class="n">add_intercept</span><span class="p">:</span> <span class="c1"># for computing LS loss term</span>
                <span class="n">PX</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="n">PX</span><span class="p">,</span><span class="n">one_n</span><span class="p">))</span>
            <span class="n">cost_ls</span>  <span class="o">=</span> <span class="n">gam</span><span class="o">*</span><span class="n">norm</span><span class="p">(</span><span class="n">y</span> <span class="o">-</span> <span class="n">PX</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">w</span><span class="p">))</span> <span class="o">**</span><span class="mi">2</span><span class="o">/</span><span class="mi">2</span> <span class="o">+</span> <span class="n">gam2</span><span class="o">*</span><span class="n">norm</span><span class="p">(</span><span class="n">w</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="o">/</span><span class="mi">2</span>
            <span class="n">cost_graph</span> <span class="o">=</span> <span class="n">tau</span><span class="o">*</span><span class="n">trace</span><span class="p">(</span> <span class="n">L</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span> <span class="n">dot</span><span class="p">(</span><span class="n">Htil</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">Htil</span><span class="p">)))</span>
            <span class="n">cost</span> <span class="o">=</span> <span class="n">cost_nmf</span> <span class="o">+</span> <span class="n">cost_graph</span> <span class="o">+</span> <span class="n">cost_ls</span>
    
            <span class="n">cost_nmf_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">cost_nmf</span><span class="p">)</span>
            <span class="n">cost_ls_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">cost_ls</span><span class="p">)</span>
            <span class="n">cost_graph_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">cost_graph</span><span class="p">)</span>
            <span class="n">cost_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">cost</span><span class="p">)</span>
    
            <span class="c1"># relative change in cost</span>
            <span class="n">diffcost</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">cost_list</span><span class="p">[</span><span class="nb">iter</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">cost_list</span><span class="p">[</span><span class="nb">iter</span><span class="p">])</span><span class="o">/</span><span class="n">cost_list</span><span class="p">[</span><span class="nb">iter</span><span class="p">])</span>
    
            <span class="c1"># relative primal residuals</span>
            <span class="n">res_W</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">norm</span><span class="p">(</span><span class="n">W</span><span class="o">-</span><span class="n">Wtil</span><span class="p">,</span><span class="s1">&#39;fro&#39;</span><span class="p">)</span><span class="o">/</span><span class="n">norm</span><span class="p">(</span><span class="n">W</span><span class="p">,</span><span class="s1">&#39;fro&#39;</span><span class="p">))</span>
            <span class="n">res_W2</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">norm</span><span class="p">(</span><span class="n">W</span><span class="o">-</span><span class="n">W2</span><span class="p">,</span><span class="s1">&#39;fro&#39;</span><span class="p">)</span><span class="o">/</span><span class="n">norm</span><span class="p">(</span><span class="n">W</span><span class="p">,</span><span class="s1">&#39;fro&#39;</span><span class="p">))</span>
            <span class="n">res_P</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">norm</span><span class="p">(</span><span class="n">P</span><span class="o">-</span><span class="n">Ptil</span><span class="p">,</span><span class="s1">&#39;fro&#39;</span><span class="p">)</span><span class="o">/</span><span class="n">norm</span><span class="p">(</span><span class="n">P</span><span class="p">,</span><span class="s1">&#39;fro&#39;</span><span class="p">))</span>
            <span class="n">res_H</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">norm</span><span class="p">(</span><span class="n">H</span><span class="o">-</span><span class="n">P</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">X</span><span class="p">),</span><span class="s1">&#39;fro&#39;</span><span class="p">)</span><span class="o">/</span><span class="n">norm</span><span class="p">(</span><span class="n">H</span><span class="p">,</span><span class="s1">&#39;fro&#39;</span><span class="p">))</span>
            <span class="n">res_Htil</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">norm</span><span class="p">(</span><span class="n">H</span><span class="o">-</span><span class="n">Htil</span><span class="p">,</span><span class="s1">&#39;fro&#39;</span><span class="p">)</span><span class="o">/</span><span class="n">norm</span><span class="p">(</span><span class="n">H</span><span class="p">,</span><span class="s1">&#39;fro&#39;</span><span class="p">))</span>
    
            <span class="c1"># relative change in basis matrix</span>
    <span class="c1">#        diffW.append( norm(W-W_old,&#39;fro&#39;)/ norm(W_old, &#39;fro&#39;) )</span>
    
            <span class="c1">#=== termination check ====#</span>
            <span class="n">check_exit</span>  <span class="o">=</span> <span class="p">(</span><span class="n">diffcost</span><span class="p">[</span><span class="nb">iter</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">tol</span><span class="p">)</span>
            <span class="n">check_exit</span> <span class="o">&amp;=</span> <span class="p">(</span><span class="n">res_W</span><span class="p">[</span><span class="nb">iter</span><span class="p">]</span> <span class="o">&lt;</span>  <span class="n">tol</span><span class="p">)</span>
            <span class="n">check_exit</span> <span class="o">&amp;=</span> <span class="p">(</span><span class="n">res_W2</span><span class="p">[</span><span class="nb">iter</span><span class="p">]</span> <span class="o">&lt;</span>  <span class="n">tol</span><span class="p">)</span>
            <span class="n">check_exit</span> <span class="o">&amp;=</span> <span class="p">(</span><span class="n">res_P</span><span class="p">[</span><span class="nb">iter</span><span class="p">]</span> <span class="o">&lt;</span>  <span class="n">tol</span><span class="p">)</span>
            <span class="n">check_exit</span> <span class="o">&amp;=</span> <span class="p">(</span><span class="n">res_H</span><span class="p">[</span><span class="nb">iter</span><span class="p">]</span> <span class="o">&lt;</span>  <span class="n">tol</span><span class="p">)</span>
            <span class="n">check_exit</span> <span class="o">&amp;=</span> <span class="p">(</span><span class="n">res_Htil</span><span class="p">[</span><span class="nb">iter</span><span class="p">]</span> <span class="o">&lt;</span>  <span class="n">tol</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">check_exit</span> <span class="ow">and</span> <span class="nb">iter</span> <span class="o">&gt;</span> <span class="mi">300</span><span class="p">:</span> <span class="c1"># allow 300 iterations of &quot;burn-in&quot;</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">silence</span><span class="p">:</span>
                    <span class="k">print</span> <span class="s2">&quot;    Termination condition met.  Exit at iter =&quot;</span><span class="p">,</span><span class="nb">iter</span><span class="p">,</span>
                <span class="k">break</span>
            <span class="c1">#=============== print current progress ==============================#</span>
    <span class="c1">#        if iter % disp_freq == 0:</span>
            <span class="k">if</span> <span class="p">(</span><span class="nb">iter</span><span class="o">&gt;</span><span class="mi">1</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="nb">iter</span> <span class="o">%</span> <span class="n">disp_freq</span> <span class="o">==</span> <span class="mi">0</span><span class="p">):</span>
    <span class="c1">#            str_ = &quot;iter={:4} cost={:3.3f}&quot;.format(iter,cost_list[iter+1])</span>
                <span class="n">str_</span> <span class="o">=</span> <span class="s2">&quot;iter={:4} cost={:6.5e}&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">iter</span><span class="p">,</span><span class="n">cost</span><span class="p">)</span>
                <span class="n">str_</span> <span class="o">+=</span> <span class="s2">&quot; nmf={:3.2e}&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">cost_nmf</span><span class="p">)</span>
                <span class="n">str_</span> <span class="o">+=</span> <span class="s2">&quot; ls={:3.2e}&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">cost_ls</span><span class="p">)</span>
                <span class="n">str_</span> <span class="o">+=</span> <span class="s2">&quot; G={:3.2e}&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">cost_graph</span><span class="p">)</span>
                <span class="n">str_</span> <span class="o">+=</span> <span class="s2">&quot; diffcost={:3.2e}&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">diffcost</span><span class="p">[</span><span class="nb">iter</span><span class="p">])</span>
                <span class="n">str_</span> <span class="o">+=</span> <span class="s2">&quot; W={:3.2e}&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">res_W</span><span class="p">[</span><span class="nb">iter</span><span class="p">])</span>
                <span class="n">str_</span> <span class="o">+=</span> <span class="s2">&quot; W2={:3.2e}&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">res_W2</span><span class="p">[</span><span class="nb">iter</span><span class="p">])</span>
                <span class="n">str_</span> <span class="o">+=</span> <span class="s2">&quot; P={:3.2e}&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">res_P</span><span class="p">[</span><span class="nb">iter</span><span class="p">])</span>
                <span class="n">str_</span> <span class="o">+=</span> <span class="s2">&quot; H={:3.2e}&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">res_H</span><span class="p">[</span><span class="nb">iter</span><span class="p">])</span>
                <span class="n">str_</span> <span class="o">+=</span> <span class="s2">&quot; H2={:3.2e}&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">res_Htil</span><span class="p">[</span><span class="nb">iter</span><span class="p">])</span>
    <span class="c1">#            str_ += &quot; diffW={:3.2e}&quot;.format(diffW[iter])</span>
                <span class="k">print</span> <span class="n">str_</span> <span class="o">+</span> <span class="s2">&quot; ({:3.1f} sec)&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span><span class="o">-</span><span class="n">start</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">KeyboardInterrupt</span><span class="p">:</span>
            <span class="k">break</span>
    <span class="c1">#%%---- end of admm for loop ---------------------------------------------#</span>
    <span class="n">cost_list</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">cost_list</span><span class="p">)</span>

    <span class="c1"># convert to pandas dataframe</span>
    <span class="n">cost</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">([</span><span class="n">cost_list</span><span class="p">,</span> <span class="n">cost_nmf_list</span><span class="p">,</span> <span class="n">cost_graph_list</span><span class="p">,</span><span class="n">cost_ls_list</span><span class="p">],</span>
                        <span class="n">index</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;total&#39;</span><span class="p">,</span><span class="s1">&#39;nmf&#39;</span><span class="p">,</span><span class="s1">&#39;graph&#39;</span><span class="p">,</span><span class="s1">&#39;ls&#39;</span><span class="p">])</span><span class="o">.</span><span class="n">T</span>

    <span class="n">res</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">([</span><span class="n">res_W</span><span class="p">,</span><span class="n">res_W2</span><span class="p">,</span><span class="n">res_P</span><span class="p">,</span><span class="n">res_H</span><span class="p">,</span><span class="n">diffcost</span><span class="p">],</span>
                       <span class="n">index</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;res_W&#39;</span><span class="p">,</span><span class="s1">&#39;res_W2&#39;</span><span class="p">,</span><span class="s1">&#39;res_P&#39;</span><span class="p">,</span><span class="s1">&#39;res_H&#39;</span><span class="p">,</span><span class="s1">&#39;diffcost&#39;</span><span class="p">])</span><span class="o">.</span><span class="n">T</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">silence</span><span class="p">:</span> <span class="n">print_time</span><span class="p">(</span><span class="n">start</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">W</span><span class="p">,</span><span class="n">P</span><span class="p">,</span><span class="n">H</span><span class="p">,</span><span class="n">w</span><span class="p">,</span><span class="n">Wtil</span><span class="p">,</span><span class="n">Ptil</span><span class="p">,</span><span class="n">cost</span><span class="p">,</span><span class="n">res</span>

<span class="k">def</span> <span class="nf">ls_sgpnmf_admm_bal</span><span class="p">(</span><span class="n">X</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">r</span><span class="p">,</span><span class="n">L</span><span class="p">,</span><span class="n">tau</span><span class="o">=</span><span class="mf">1e-1</span><span class="p">,</span><span class="n">gam</span><span class="o">=</span><span class="mf">1e-1</span><span class="p">,</span><span class="n">gam2</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span><span class="n">rho</span><span class="o">=</span><span class="mf">1e3</span><span class="p">,</span><span class="n">max_iter</span><span class="o">=</span><span class="mi">5000</span><span class="p">,</span>
                   <span class="n">tol</span><span class="o">=</span><span class="mf">1e-4</span><span class="p">,</span><span class="n">W_init</span><span class="o">=</span><span class="s1">&#39;nndsvd&#39;</span><span class="p">,</span><span class="n">disp_freq</span><span class="o">=</span><span class="mi">1000</span><span class="p">,</span><span class="n">silence</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span>
                   <span class="n">add_intercept</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Same as ``ls_sgpnmf_admm``, but with class-weighted loss</span>

<span class="sd">    &gt;&gt;&gt; W,P,H,w,Wtil,Ptil,cost,res = ls_sgpnmf_admm(X,y,r,L,rho=5e2)</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    X : ndarray of shape (n_features, n_samples)=(p,n)</span>
<span class="sd">        Data matrix with columns as data points</span>
<span class="sd">    y : array-like of shape [n_samples,]</span>
<span class="sd">        Label vector</span>
<span class="sd">    r : int</span>
<span class="sd">        Dimension of the embedding space (n_components)</span>
<span class="sd">    L : ndarray of shape = [n_samples, n_samples]</span>
<span class="sd">        Laplacian matrix.</span>
<span class="sd">    tau : float</span>
<span class="sd">        Amount of graph regularization to apply</span>
<span class="sd">    gam : float</span>
<span class="sd">        Amount of weight on the classification loss</span>
<span class="sd">    gam2 : float (default=0)</span>
<span class="sd">        Amount of regularization on the classifier (results in ridge regression</span>
<span class="sd">        update)</span>
<span class="sd">    rho : float</span>
<span class="sd">        Augmented Lagrangian parameter</span>
<span class="sd">    max_iter : int</span>
<span class="sd">        max number of iterations</span>
<span class="sd">    tol : float</span>
<span class="sd">        convergence tolerance (on relative change in objective value and</span>
<span class="sd">        all primal residuals)</span>
<span class="sd">    W_init : None, rng, or &#39;nndsvd&#39;</span>
<span class="sd">        Way to initialize W (and H).  If ``None`` or ``RandomState object``</span>
<span class="sd">        is supplied, both W and H will be initialized via non-negative</span>
<span class="sd">        random number.  If ``&#39;nndsvd&#39;``, will use deterministic initialization</span>
<span class="sd">        NNDSVD &quot;Non-Negative Double Singular Value Decomposition&quot;, proposed by</span>
<span class="sd">        Boutsidis2008.</span>
<span class="sd">    disp_freq : int</span>
<span class="sd">        Frequency of update display (in iterations)</span>
<span class="sd">    silence : bool</span>
<span class="sd">        If True, don&#39;t print-out convergence detail at the end</span>
<span class="sd">    add_intercept : bool (default=False)</span>
<span class="sd">        Add intercept term to classifier (added 02/16/2016)</span>

<span class="sd">    Update history</span>
<span class="sd">    --------------</span>
<span class="sd">    **02/17/2016** - function created</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">rho</span> <span class="o">*=</span> <span class="mf">1.</span>
    <span class="n">tau</span> <span class="o">*=</span> <span class="mf">1.</span>
    <span class="n">gam</span> <span class="o">*=</span> <span class="mf">1.</span>
    <span class="n">gam2</span> <span class="o">*=</span> <span class="mf">1.</span>
    <span class="n">p</span><span class="p">,</span><span class="n">n</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">shape</span>
    <span class="c1">#%% get class balance info</span>
    <span class="n">weight_pos</span> <span class="o">=</span> <span class="mf">1.</span><span class="o">*</span><span class="p">(</span><span class="n">y</span><span class="o">==-</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span><span class="o">/</span><span class="n">n</span>
    <span class="n">weight_neg</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">weight_pos</span>
    <span class="n">weight_vec</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
    <span class="n">weight_vec</span><span class="p">[</span><span class="n">y</span><span class="o">==+</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">weight_pos</span>
    <span class="n">weight_vec</span><span class="p">[</span><span class="n">y</span><span class="o">==-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">weight_neg</span>
    <span class="n">J</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span> <span class="n">weight_vec</span> <span class="p">)</span>
    <span class="c1">#%%=== initialize variables =====</span>
    <span class="c1"># define main primal variable W (basis matrix)</span>
    <span class="k">if</span> <span class="n">W_init</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
        <span class="n">W</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="n">p</span><span class="p">,</span><span class="n">r</span><span class="p">)</span>
        <span class="n">W</span> <span class="o">/=</span> <span class="n">norm</span><span class="p">(</span><span class="n">W</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>

        <span class="n">H</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="n">r</span><span class="p">,</span><span class="n">n</span><span class="p">)</span>
        <span class="n">H</span> <span class="o">/=</span> <span class="n">norm</span><span class="p">(</span><span class="n">H</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">W_init</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">RandomState</span><span class="p">):</span>
        <span class="n">rng</span> <span class="o">=</span> <span class="n">W_init</span>

        <span class="n">W</span> <span class="o">=</span> <span class="n">rng</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="n">p</span><span class="p">,</span><span class="n">r</span><span class="p">)</span>
        <span class="n">W</span> <span class="o">/=</span> <span class="n">norm</span><span class="p">(</span><span class="n">W</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>

        <span class="n">H</span> <span class="o">=</span> <span class="n">rng</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="n">r</span><span class="p">,</span><span class="n">n</span><span class="p">)</span>
        <span class="n">H</span> <span class="o">/=</span> <span class="n">norm</span><span class="p">(</span><span class="n">H</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">W_init</span> <span class="o">==</span> <span class="s1">&#39;nndsvd&#39;</span><span class="p">:</span>
<span class="c1">#        W = nnd_svd(X,r)</span>
        <span class="n">W</span><span class="p">,</span><span class="n">H</span> <span class="o">=</span> <span class="n">nnd_svd</span><span class="p">(</span><span class="n">X</span><span class="p">,</span><span class="n">r</span><span class="p">,</span><span class="n">get_H</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Invalid input for &quot;W_init&quot;&#39;</span><span class="p">)</span>

    <span class="n">P</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">r</span><span class="p">,</span><span class="n">p</span><span class="p">))</span>
<span class="c1">#    P = np.random.rand(r,p)</span>

    <span class="k">if</span> <span class="n">add_intercept</span><span class="p">:</span>
        <span class="n">w</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">r</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="c1"># &lt;- classification vector</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">w</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">r</span><span class="p">)</span> <span class="c1"># &lt;- classification vector</span>

    <span class="c1"># aux. variables</span>
    <span class="n">Wtil</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">W</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
    <span class="n">W2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">W</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>  <span class="c1"># &lt;- for spectral projection</span>
    <span class="n">Ptil</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">P</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
    <span class="n">Htil</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">H</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="c1"># &lt;- for graph regularization</span>

    <span class="c1"># dual variables</span>
    <span class="n">Lam_W</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">W</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
    <span class="n">Lam_W2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">W</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="c1"># &lt;- for spectral projection</span>
    <span class="n">Lam_P</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">P</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
    <span class="n">Lam_H</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">H</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
    <span class="n">Lam_Htil</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">H</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="c1"># &lt;- for graph regularization</span>
    <span class="c1">#%%=== create empty lists for tracking updates ===</span>
    <span class="c1"># keep track of frobenius norm loss</span>
    <span class="n">cost_list</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">cost_ls_list</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">cost_nmf_list</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">cost_graph_list</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="n">PX</span> <span class="o">=</span> <span class="n">Ptil</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>
    <span class="n">cost_nmf</span> <span class="o">=</span> <span class="n">norm</span><span class="p">(</span><span class="n">Wtil</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">PX</span><span class="p">)</span> <span class="o">-</span> <span class="n">X</span><span class="p">,</span><span class="s1">&#39;fro&#39;</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="o">/</span><span class="mi">2</span>
    <span class="k">if</span> <span class="n">add_intercept</span><span class="p">:</span>
        <span class="c1"># used for the least-squares term</span>
        <span class="n">one_n</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
        <span class="n">PX</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="n">PX</span><span class="p">,</span><span class="n">one_n</span><span class="p">))</span>
    <span class="c1"># compute weighted error</span>
    <span class="n">_err</span> <span class="o">=</span> <span class="p">(</span><span class="n">y</span><span class="o">-</span><span class="n">PX</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">w</span><span class="p">))</span>
    <span class="n">_err</span> <span class="o">=</span> <span class="n">_err</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span> <span class="n">J</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">_err</span><span class="p">))</span>
    <span class="n">cost_ls</span>  <span class="o">=</span> <span class="n">gam</span><span class="o">*</span><span class="n">_err</span><span class="o">/</span><span class="mi">2</span> <span class="o">+</span> <span class="n">gam2</span><span class="o">*</span><span class="n">norm</span><span class="p">(</span><span class="n">w</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="o">/</span><span class="mi">2</span>
    <span class="c1">#cost_ls  = gam*norm(y - PX.T.dot(w)) **2/2 + gam2*norm(w)**2/2</span>
    <span class="n">cost_graph</span> <span class="o">=</span> <span class="n">tau</span><span class="o">*</span><span class="n">trace</span><span class="p">(</span> <span class="n">L</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span> <span class="n">dot</span><span class="p">(</span><span class="n">Htil</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">Htil</span><span class="p">)))</span>
    <span class="n">cost</span> <span class="o">=</span> <span class="n">cost_nmf</span> <span class="o">+</span> <span class="n">cost_graph</span> <span class="o">+</span> <span class="n">cost_ls</span>

    <span class="n">cost_nmf_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">cost_nmf</span><span class="p">)</span>
    <span class="n">cost_ls_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">cost_ls</span><span class="p">)</span>
    <span class="n">cost_graph_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">cost_graph</span><span class="p">)</span>
    <span class="n">cost_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">cost</span><span class="p">)</span>

    <span class="c1"># relative change in cost</span>
    <span class="n">diffcost</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="c1"># keep track of relative primal residual</span>
    <span class="n">res_W</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">res_W2</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">res_P</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">res_H</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">res_Htil</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="c1"># also keep track of diffW</span>
<span class="c1">#    diffW = []</span>
    <span class="c1">#%%=== run admm iterations ===</span>
    <span class="n">eye_r</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="n">r</span><span class="p">)</span>
    <span class="n">eye_n</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>

    <span class="c1"># precompute term needed for inversion lemma</span>
    <span class="n">K</span> <span class="o">=</span> <span class="n">solve</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="o">+</span> <span class="n">dot</span><span class="p">(</span><span class="n">X</span><span class="o">.</span><span class="n">T</span><span class="p">,</span><span class="n">X</span><span class="p">),</span> <span class="n">X</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>

    <span class="n">start</span><span class="o">=</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
    <span class="k">for</span> <span class="nb">iter</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">max_iter</span><span class="p">):</span>
<span class="c1">#        W_old = W #&lt;- to keep track of diffW</span>

        <span class="c1">#================ primal updates (P, W, H, Ptil, Wtil) ===============#</span>
        <span class="c1"># update for P involves inversion lemma...</span>
        <span class="n">_R</span> <span class="o">=</span> <span class="n">dot</span><span class="p">(</span><span class="n">X</span><span class="p">,</span><span class="n">Lam_H</span><span class="o">.</span><span class="n">T</span><span class="p">)</span><span class="o">/</span><span class="n">rho</span> <span class="o">-</span> <span class="n">Lam_P</span><span class="o">.</span><span class="n">T</span><span class="o">/</span><span class="n">rho</span> <span class="o">+</span> <span class="n">dot</span><span class="p">(</span><span class="n">X</span><span class="p">,</span><span class="n">H</span><span class="o">.</span><span class="n">T</span><span class="p">)</span> <span class="o">+</span> <span class="n">Ptil</span><span class="o">.</span><span class="n">T</span>
        <span class="n">P</span> <span class="o">=</span> <span class="p">(</span><span class="n">_R</span> <span class="o">-</span> <span class="n">X</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span> <span class="n">dot</span><span class="p">(</span><span class="n">K</span><span class="p">,</span><span class="n">_R</span><span class="p">)</span> <span class="p">))</span><span class="o">.</span><span class="n">T</span>
        <span class="n">Ptil</span> <span class="o">=</span> <span class="p">(</span><span class="n">P</span><span class="o">+</span><span class="n">Lam_P</span><span class="o">/</span><span class="n">rho</span><span class="p">)</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>

        <span class="c1"># (W,H) updates</span>
        <span class="n">WtW</span> <span class="o">=</span> <span class="n">W</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">W</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">rho</span><span class="p">)</span><span class="o">*</span><span class="n">eye_r</span>
        <span class="k">if</span> <span class="n">add_intercept</span><span class="p">:</span>
            <span class="n">ytil</span> <span class="o">=</span> <span class="n">y</span> <span class="o">-</span> <span class="n">one_n</span><span class="o">*</span><span class="n">w</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">_S</span> <span class="o">=</span> <span class="n">dot</span><span class="p">(</span><span class="n">W</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">X</span><span class="p">)</span> <span class="o">+</span> <span class="n">rho</span><span class="o">*</span><span class="n">dot</span><span class="p">(</span><span class="n">P</span><span class="p">,</span><span class="n">X</span><span class="p">)</span> <span class="o">-</span> <span class="n">Lam_H</span> <span class="o">+</span> <span class="n">rho</span><span class="o">*</span><span class="n">Htil</span> <span class="o">-</span>\
                      <span class="n">Lam_Htil</span> <span class="o">+</span> <span class="n">gam</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">outer</span><span class="p">(</span><span class="n">w</span><span class="p">[:</span><span class="n">r</span><span class="p">],</span><span class="n">ytil</span><span class="p">)</span>
            <span class="c1">#H = solve(dot(W.T,W)+(2*rho)*eye_r + gam*np.outer(w[:r],w[:r]),_S)</span>
            <span class="n">wtw</span> <span class="o">=</span> <span class="n">gam</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">outer</span><span class="p">(</span><span class="n">w</span><span class="p">[:</span><span class="n">r</span><span class="p">],</span><span class="n">w</span><span class="p">[:</span><span class="n">r</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">_S</span> <span class="o">=</span> <span class="n">dot</span><span class="p">(</span><span class="n">W</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">X</span><span class="p">)</span> <span class="o">+</span> <span class="n">rho</span><span class="o">*</span><span class="n">dot</span><span class="p">(</span><span class="n">P</span><span class="p">,</span><span class="n">X</span><span class="p">)</span> <span class="o">-</span> <span class="n">Lam_H</span> <span class="o">+</span> <span class="n">rho</span><span class="o">*</span><span class="n">Htil</span> <span class="o">-</span>\
                      <span class="n">Lam_Htil</span> <span class="o">+</span> <span class="n">gam</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">outer</span><span class="p">(</span><span class="n">w</span><span class="p">,</span><span class="n">y</span><span class="p">)</span>
            <span class="c1">#H = solve(dot(W.T,W)+(2*rho)*eye_r + gam*np.outer(w,w),_S)</span>
            <span class="n">wtw</span> <span class="o">=</span> <span class="n">gam</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">outer</span><span class="p">(</span><span class="n">w</span><span class="p">,</span><span class="n">w</span><span class="p">)</span>
        <span class="n">H</span><span class="p">[:,</span><span class="n">y</span><span class="o">==+</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">solve</span><span class="p">(</span><span class="n">WtW</span> <span class="o">+</span> <span class="n">weight_pos</span><span class="o">*</span><span class="n">wtw</span><span class="p">,</span> <span class="n">_S</span><span class="p">[:,</span><span class="n">y</span><span class="o">==+</span><span class="mi">1</span><span class="p">])</span>
        <span class="n">H</span><span class="p">[:,</span><span class="n">y</span><span class="o">==-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">solve</span><span class="p">(</span><span class="n">WtW</span> <span class="o">+</span> <span class="n">weight_neg</span><span class="o">*</span><span class="n">wtw</span><span class="p">,</span> <span class="n">_S</span><span class="p">[:,</span><span class="n">y</span><span class="o">==-</span><span class="mi">1</span><span class="p">])</span>

        <span class="n">W</span> <span class="o">=</span> <span class="n">solve</span><span class="p">(</span><span class="n">dot</span><span class="p">(</span><span class="n">H</span><span class="p">,</span><span class="n">H</span><span class="o">.</span><span class="n">T</span><span class="p">)</span><span class="o">+</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">rho</span><span class="p">)</span><span class="o">*</span><span class="n">eye_r</span><span class="p">,</span>
                  <span class="n">dot</span><span class="p">(</span><span class="n">H</span><span class="p">,</span> <span class="n">X</span><span class="o">.</span><span class="n">T</span><span class="p">)</span> <span class="o">+</span> <span class="n">rho</span><span class="o">*</span><span class="n">Wtil</span><span class="o">.</span><span class="n">T</span> <span class="o">-</span> <span class="n">Lam_W</span><span class="o">.</span><span class="n">T</span> <span class="o">+</span> <span class="n">rho</span><span class="o">*</span><span class="n">W2</span><span class="o">.</span><span class="n">T</span> <span class="o">-</span> <span class="n">Lam_W2</span><span class="o">.</span><span class="n">T</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>
        <span class="n">Wtil</span> <span class="o">=</span> <span class="p">(</span><span class="n">W</span><span class="o">+</span><span class="n">Lam_W</span><span class="o">/</span><span class="n">rho</span><span class="p">)</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>


        <span class="n">W2</span> <span class="o">=</span> <span class="n">projection_spectral</span><span class="p">(</span><span class="n">W</span> <span class="o">+</span> <span class="n">Lam_W2</span><span class="o">/</span><span class="n">rho</span><span class="p">)</span>

        <span class="n">Htil</span> <span class="o">=</span> <span class="n">solve</span><span class="p">(</span><span class="n">tau</span><span class="o">*</span><span class="n">L</span> <span class="o">+</span> <span class="n">rho</span><span class="o">*</span><span class="n">eye_n</span><span class="p">,</span> <span class="n">rho</span><span class="o">*</span><span class="n">H</span><span class="o">.</span><span class="n">T</span><span class="o">+</span><span class="n">Lam_Htil</span><span class="o">.</span><span class="n">T</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>

        <span class="k">if</span> <span class="n">add_intercept</span><span class="p">:</span>
            <span class="c1"># H with intercept</span>
            <span class="n">H_</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="n">H</span><span class="p">,</span><span class="n">one_n</span><span class="p">))</span>
            <span class="c1"># for now, ignore gam2 regularizer...i never use them</span>
            <span class="n">w</span> <span class="o">=</span> <span class="n">solve</span><span class="p">(</span> <span class="n">H_</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">J</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">H_</span><span class="o">.</span><span class="n">T</span><span class="p">)),</span> <span class="n">H_</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">J</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">y</span><span class="p">)))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">w</span> <span class="o">=</span> <span class="n">solve</span><span class="p">(</span> <span class="n">H</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">J</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">H</span><span class="o">.</span><span class="n">T</span><span class="p">))</span> <span class="o">+</span> <span class="p">(</span><span class="n">gam2</span><span class="o">/</span><span class="n">gam</span><span class="p">)</span><span class="o">*</span><span class="n">eye_r</span><span class="p">,</span> <span class="n">H</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">J</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">y</span><span class="p">)))</span>

        <span class="c1">#====================== dual updates =================================#</span>
        <span class="n">Lam_W</span> <span class="o">=</span> <span class="n">Lam_W</span> <span class="o">+</span> <span class="n">rho</span><span class="o">*</span><span class="p">(</span><span class="n">W</span> <span class="o">-</span> <span class="n">Wtil</span><span class="p">)</span>
        <span class="n">Lam_W2</span> <span class="o">=</span> <span class="n">Lam_W2</span> <span class="o">+</span> <span class="n">rho</span><span class="o">*</span><span class="p">(</span><span class="n">W</span> <span class="o">-</span> <span class="n">W2</span><span class="p">)</span>
        <span class="n">Lam_P</span> <span class="o">=</span> <span class="n">Lam_P</span> <span class="o">+</span> <span class="n">rho</span><span class="o">*</span><span class="p">(</span><span class="n">P</span> <span class="o">-</span> <span class="n">Ptil</span><span class="p">)</span>
        <span class="n">Lam_H</span> <span class="o">=</span> <span class="n">Lam_H</span> <span class="o">+</span> <span class="n">rho</span><span class="o">*</span><span class="p">(</span><span class="n">H</span> <span class="o">-</span> <span class="n">dot</span><span class="p">(</span><span class="n">P</span><span class="p">,</span><span class="n">X</span><span class="p">))</span>
        <span class="n">Lam_Htil</span> <span class="o">=</span> <span class="n">Lam_Htil</span> <span class="o">+</span> <span class="n">rho</span><span class="o">*</span><span class="p">(</span><span class="n">H</span><span class="o">-</span><span class="n">Htil</span><span class="p">)</span>

        <span class="c1">#============ comptute objective values ==============================#</span>
        <span class="c1"># main loss function</span>
        <span class="n">PX</span> <span class="o">=</span> <span class="n">Ptil</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>
        <span class="n">cost_nmf</span> <span class="o">=</span> <span class="n">norm</span><span class="p">(</span><span class="n">Wtil</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">PX</span><span class="p">)</span> <span class="o">-</span> <span class="n">X</span><span class="p">,</span><span class="s1">&#39;fro&#39;</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="o">/</span><span class="mi">2</span>
        <span class="k">if</span> <span class="n">add_intercept</span><span class="p">:</span> <span class="c1"># for computing LS loss term</span>
            <span class="n">PX</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="n">PX</span><span class="p">,</span><span class="n">one_n</span><span class="p">))</span>
        <span class="c1"># compute weighted error</span>
        <span class="n">_err</span> <span class="o">=</span> <span class="p">(</span><span class="n">y</span><span class="o">-</span><span class="n">PX</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">w</span><span class="p">))</span>
        <span class="n">_err</span> <span class="o">=</span> <span class="n">_err</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span> <span class="n">J</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">_err</span><span class="p">))</span>
        <span class="n">cost_ls</span>  <span class="o">=</span> <span class="n">gam</span><span class="o">*</span><span class="n">_err</span><span class="o">/</span><span class="mi">2</span> <span class="o">+</span> <span class="n">gam2</span><span class="o">*</span><span class="n">norm</span><span class="p">(</span><span class="n">w</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="o">/</span><span class="mi">2</span>
<span class="c1">#        cost_ls  = gam*norm(y - PX.T.dot(w)) **2/2 + gam2*norm(w)**2/2</span>
        <span class="n">cost_graph</span> <span class="o">=</span> <span class="n">tau</span><span class="o">*</span><span class="n">trace</span><span class="p">(</span> <span class="n">L</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span> <span class="n">dot</span><span class="p">(</span><span class="n">Htil</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">Htil</span><span class="p">)))</span>
        <span class="n">cost</span> <span class="o">=</span> <span class="n">cost_nmf</span> <span class="o">+</span> <span class="n">cost_graph</span> <span class="o">+</span> <span class="n">cost_ls</span>

        <span class="n">cost_nmf_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">cost_nmf</span><span class="p">)</span>
        <span class="n">cost_ls_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">cost_ls</span><span class="p">)</span>
        <span class="n">cost_graph_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">cost_graph</span><span class="p">)</span>
        <span class="n">cost_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">cost</span><span class="p">)</span>

        <span class="c1"># relative change in cost</span>
        <span class="n">diffcost</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">cost_list</span><span class="p">[</span><span class="nb">iter</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">cost_list</span><span class="p">[</span><span class="nb">iter</span><span class="p">])</span><span class="o">/</span><span class="n">cost_list</span><span class="p">[</span><span class="nb">iter</span><span class="p">])</span>

        <span class="c1"># relative primal residuals</span>
        <span class="n">res_W</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">norm</span><span class="p">(</span><span class="n">W</span><span class="o">-</span><span class="n">Wtil</span><span class="p">,</span><span class="s1">&#39;fro&#39;</span><span class="p">)</span><span class="o">/</span><span class="n">norm</span><span class="p">(</span><span class="n">W</span><span class="p">,</span><span class="s1">&#39;fro&#39;</span><span class="p">))</span>
        <span class="n">res_W2</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">norm</span><span class="p">(</span><span class="n">W</span><span class="o">-</span><span class="n">W2</span><span class="p">,</span><span class="s1">&#39;fro&#39;</span><span class="p">)</span><span class="o">/</span><span class="n">norm</span><span class="p">(</span><span class="n">W</span><span class="p">,</span><span class="s1">&#39;fro&#39;</span><span class="p">))</span>
        <span class="n">res_P</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">norm</span><span class="p">(</span><span class="n">P</span><span class="o">-</span><span class="n">Ptil</span><span class="p">,</span><span class="s1">&#39;fro&#39;</span><span class="p">)</span><span class="o">/</span><span class="n">norm</span><span class="p">(</span><span class="n">P</span><span class="p">,</span><span class="s1">&#39;fro&#39;</span><span class="p">))</span>
        <span class="n">res_H</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">norm</span><span class="p">(</span><span class="n">H</span><span class="o">-</span><span class="n">P</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">X</span><span class="p">),</span><span class="s1">&#39;fro&#39;</span><span class="p">)</span><span class="o">/</span><span class="n">norm</span><span class="p">(</span><span class="n">H</span><span class="p">,</span><span class="s1">&#39;fro&#39;</span><span class="p">))</span>
        <span class="n">res_Htil</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">norm</span><span class="p">(</span><span class="n">H</span><span class="o">-</span><span class="n">Htil</span><span class="p">,</span><span class="s1">&#39;fro&#39;</span><span class="p">)</span><span class="o">/</span><span class="n">norm</span><span class="p">(</span><span class="n">H</span><span class="p">,</span><span class="s1">&#39;fro&#39;</span><span class="p">))</span>

        <span class="c1"># relative change in basis matrix</span>
<span class="c1">#        diffW.append( norm(W-W_old,&#39;fro&#39;)/ norm(W_old, &#39;fro&#39;) )</span>

        <span class="c1">#=== termination check ====#</span>
        <span class="n">check_exit</span>  <span class="o">=</span> <span class="p">(</span><span class="n">diffcost</span><span class="p">[</span><span class="nb">iter</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">tol</span><span class="p">)</span>
        <span class="n">check_exit</span> <span class="o">&amp;=</span> <span class="p">(</span><span class="n">res_W</span><span class="p">[</span><span class="nb">iter</span><span class="p">]</span> <span class="o">&lt;</span>  <span class="n">tol</span><span class="p">)</span>
        <span class="n">check_exit</span> <span class="o">&amp;=</span> <span class="p">(</span><span class="n">res_W2</span><span class="p">[</span><span class="nb">iter</span><span class="p">]</span> <span class="o">&lt;</span>  <span class="n">tol</span><span class="p">)</span>
        <span class="n">check_exit</span> <span class="o">&amp;=</span> <span class="p">(</span><span class="n">res_P</span><span class="p">[</span><span class="nb">iter</span><span class="p">]</span> <span class="o">&lt;</span>  <span class="n">tol</span><span class="p">)</span>
        <span class="n">check_exit</span> <span class="o">&amp;=</span> <span class="p">(</span><span class="n">res_H</span><span class="p">[</span><span class="nb">iter</span><span class="p">]</span> <span class="o">&lt;</span>  <span class="n">tol</span><span class="p">)</span>
        <span class="n">check_exit</span> <span class="o">&amp;=</span> <span class="p">(</span><span class="n">res_Htil</span><span class="p">[</span><span class="nb">iter</span><span class="p">]</span> <span class="o">&lt;</span>  <span class="n">tol</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">check_exit</span> <span class="ow">and</span> <span class="nb">iter</span> <span class="o">&gt;</span> <span class="mi">300</span><span class="p">:</span> <span class="c1"># allow 300 iterations of &quot;burn-in&quot;</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">silence</span><span class="p">:</span>
                <span class="k">print</span> <span class="s2">&quot;    Termination condition met.  Exit at iter =&quot;</span><span class="p">,</span><span class="nb">iter</span><span class="p">,</span>
            <span class="k">break</span>
        <span class="c1">#=============== print current progress ==============================#</span>
<span class="c1">#        if iter % disp_freq == 0:</span>
        <span class="k">if</span> <span class="p">(</span><span class="nb">iter</span><span class="o">&gt;</span><span class="mi">1</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="nb">iter</span> <span class="o">%</span> <span class="n">disp_freq</span> <span class="o">==</span> <span class="mi">0</span><span class="p">):</span>
<span class="c1">#            str_ = &quot;iter={:4} cost={:3.3f}&quot;.format(iter,cost_list[iter+1])</span>
            <span class="n">str_</span> <span class="o">=</span> <span class="s2">&quot;iter={:4} cost={:6.5e}&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">iter</span><span class="p">,</span><span class="n">cost</span><span class="p">)</span>
            <span class="n">str_</span> <span class="o">+=</span> <span class="s2">&quot; nmf={:3.2e}&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">cost_nmf</span><span class="p">)</span>
            <span class="n">str_</span> <span class="o">+=</span> <span class="s2">&quot; G={:3.2e}&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">cost_graph</span><span class="p">)</span>
            <span class="n">str_</span> <span class="o">+=</span> <span class="s2">&quot; diffcost={:3.2e}&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">diffcost</span><span class="p">[</span><span class="nb">iter</span><span class="p">])</span>
            <span class="n">str_</span> <span class="o">+=</span> <span class="s2">&quot; W={:3.2e}&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">res_W</span><span class="p">[</span><span class="nb">iter</span><span class="p">])</span>
            <span class="n">str_</span> <span class="o">+=</span> <span class="s2">&quot; W2={:3.2e}&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">res_W2</span><span class="p">[</span><span class="nb">iter</span><span class="p">])</span>
            <span class="n">str_</span> <span class="o">+=</span> <span class="s2">&quot; P={:3.2e}&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">res_P</span><span class="p">[</span><span class="nb">iter</span><span class="p">])</span>
            <span class="n">str_</span> <span class="o">+=</span> <span class="s2">&quot; H={:3.2e}&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">res_H</span><span class="p">[</span><span class="nb">iter</span><span class="p">])</span>
            <span class="n">str_</span> <span class="o">+=</span> <span class="s2">&quot; H2={:3.2e}&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">res_Htil</span><span class="p">[</span><span class="nb">iter</span><span class="p">])</span>
<span class="c1">#            str_ += &quot; diffW={:3.2e}&quot;.format(diffW[iter])</span>
            <span class="k">print</span> <span class="n">str_</span> <span class="o">+</span> <span class="s2">&quot; ({:3.1f} sec)&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span><span class="o">-</span><span class="n">start</span><span class="p">)</span>
    <span class="c1">#%%---- end of admm for loop ---------------------------------------------#</span>
    <span class="n">cost_list</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">cost_list</span><span class="p">)</span>

    <span class="c1"># convert to pandas dataframe</span>
    <span class="n">cost</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">([</span><span class="n">cost_list</span><span class="p">,</span> <span class="n">cost_nmf_list</span><span class="p">,</span> <span class="n">cost_graph_list</span><span class="p">,</span><span class="n">cost_ls_list</span><span class="p">],</span>
                        <span class="n">index</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;total&#39;</span><span class="p">,</span><span class="s1">&#39;nmf&#39;</span><span class="p">,</span><span class="s1">&#39;graph&#39;</span><span class="p">,</span><span class="s1">&#39;ls&#39;</span><span class="p">])</span><span class="o">.</span><span class="n">T</span>

    <span class="n">res</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">([</span><span class="n">res_W</span><span class="p">,</span><span class="n">res_W2</span><span class="p">,</span><span class="n">res_P</span><span class="p">,</span><span class="n">res_H</span><span class="p">,</span><span class="n">diffcost</span><span class="p">],</span>
                       <span class="n">index</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;res_W&#39;</span><span class="p">,</span><span class="s1">&#39;res_W2&#39;</span><span class="p">,</span><span class="s1">&#39;res_P&#39;</span><span class="p">,</span><span class="s1">&#39;res_H&#39;</span><span class="p">,</span><span class="s1">&#39;diffcost&#39;</span><span class="p">])</span><span class="o">.</span><span class="n">T</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">silence</span><span class="p">:</span> <span class="n">print_time</span><span class="p">(</span><span class="n">start</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">W</span><span class="p">,</span><span class="n">P</span><span class="p">,</span><span class="n">H</span><span class="p">,</span><span class="n">w</span><span class="p">,</span><span class="n">Wtil</span><span class="p">,</span><span class="n">Ptil</span><span class="p">,</span><span class="n">cost</span><span class="p">,</span><span class="n">res</span>


<span class="k">def</span> <span class="nf">pnge_admm</span><span class="p">(</span><span class="n">X</span><span class="p">,</span><span class="n">r1</span><span class="p">,</span><span class="n">r2</span><span class="p">,</span><span class="n">L1</span><span class="p">,</span><span class="n">L2</span><span class="p">,</span><span class="n">tau</span><span class="o">=</span><span class="mf">1e-1</span><span class="p">,</span><span class="n">rho</span><span class="o">=</span><span class="mf">1e3</span><span class="p">,</span><span class="n">max_iter</span><span class="o">=</span><span class="mi">5000</span><span class="p">,</span><span class="n">tol</span><span class="o">=</span><span class="mf">1e-4</span><span class="p">,</span>
              <span class="n">W_init</span><span class="o">=</span><span class="s1">&#39;nndsvd&#39;</span><span class="p">,</span><span class="n">disp_freq</span><span class="o">=</span><span class="mi">1000</span><span class="p">,</span><span class="n">silence</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Projective non-negative graph embedding using ADMM.</span>

<span class="sd">    Note: in my Onenote, I used H_s, H_p...these are H_1 and H_2 in this code</span>
<span class="sd">    (basically, replace all (s,p) pairs with (1,2) pair)</span>

<span class="sd">    &gt;&gt;&gt; W,P,H,Wtil,Ptil,cost_list,res = gpnmf_admm(X,r,rho=5e2)</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    X : ndarray of shape (n_features, n_samples)=(p,n)</span>
<span class="sd">        Data matrix with columns as data points</span>
<span class="sd">    r1 : int</span>
<span class="sd">        Dimension of the intrinsic embedding space (n_components)</span>
<span class="sd">    r2 : int</span>
<span class="sd">        Dimension of the complementary embedding space (n_components)</span>
<span class="sd">    L1 : ndarray of shape = [n_samples, n_samples]</span>
<span class="sd">        Laplacian matrix of intrinsic graph</span>
<span class="sd">    L2 : ndarray of shape = [n_samples, n_samples]</span>
<span class="sd">        Laplacian matrix of penalty graph.</span>
<span class="sd">    tau : float</span>
<span class="sd">        Amount of graph regularization to apply</span>
<span class="sd">    rho : float</span>
<span class="sd">        Augmented Lagrangian parameter</span>
<span class="sd">    max_iter : int</span>
<span class="sd">        max number of iterations</span>
<span class="sd">    tol : float</span>
<span class="sd">        convergence tolerance (on relative change in objective value and</span>
<span class="sd">        all primal residuals)</span>
<span class="sd">    W_init : None, rng, or &#39;nndsvd&#39;</span>
<span class="sd">        Way to initialize W (and H).  If ``None`` or ``RandomState object``</span>
<span class="sd">        is supplied, both W and H will be initialized via non-negative</span>
<span class="sd">        random number.  If ``&#39;nndsvd&#39;``, will use deterministic initialization</span>
<span class="sd">        NNDSVD &quot;Non-Negative Double Singular Value Decomposition&quot;, proposed by</span>
<span class="sd">        Boutsidis2008.</span>
<span class="sd">    disp_freq : int</span>
<span class="sd">        Frequency of update display (in iterations)</span>
<span class="sd">    silence : bool</span>
<span class="sd">        If True, don&#39;t print-out convergence detail at the end.</span>

<span class="sd">    Update history</span>
<span class="sd">    --------------</span>
<span class="sd">    **02/03/2016** - function created</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">r</span> <span class="o">=</span> <span class="n">r1</span><span class="o">+</span><span class="n">r2</span>
    <span class="n">rho</span> <span class="o">*=</span> <span class="mf">1.</span>
    <span class="n">tau</span> <span class="o">*=</span> <span class="mf">1.</span>
    <span class="n">p</span><span class="p">,</span><span class="n">n</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">shape</span>
    <span class="c1">#%%=== initialize variables =====</span>
    <span class="c1"># define main primal variable W (basis matrix)</span>
    <span class="k">if</span> <span class="n">W_init</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
        <span class="n">W</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="n">p</span><span class="p">,</span><span class="n">r</span><span class="p">)</span>
        <span class="n">W</span> <span class="o">/=</span> <span class="n">norm</span><span class="p">(</span><span class="n">W</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>

        <span class="n">H</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="n">r</span><span class="p">,</span><span class="n">n</span><span class="p">)</span>
        <span class="n">H</span> <span class="o">/=</span> <span class="n">norm</span><span class="p">(</span><span class="n">H</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">W_init</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">RandomState</span><span class="p">):</span>
        <span class="n">rng</span> <span class="o">=</span> <span class="n">W_init</span>

        <span class="n">W</span> <span class="o">=</span> <span class="n">rng</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="n">p</span><span class="p">,</span><span class="n">r</span><span class="p">)</span>
        <span class="n">W</span> <span class="o">/=</span> <span class="n">norm</span><span class="p">(</span><span class="n">W</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>

        <span class="n">H</span> <span class="o">=</span> <span class="n">rng</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="n">r</span><span class="p">,</span><span class="n">n</span><span class="p">)</span>
        <span class="n">H</span> <span class="o">/=</span> <span class="n">norm</span><span class="p">(</span><span class="n">H</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">W_init</span> <span class="o">==</span> <span class="s1">&#39;nndsvd&#39;</span><span class="p">:</span>
<span class="c1">#        W = nnd_svd(X,r)</span>
        <span class="n">W</span><span class="p">,</span><span class="n">H</span> <span class="o">=</span> <span class="n">nnd_svd</span><span class="p">(</span><span class="n">X</span><span class="p">,</span><span class="n">r</span><span class="p">,</span><span class="n">get_H</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Invalid input for &quot;W_init&quot;&#39;</span><span class="p">)</span>

    <span class="n">P</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">r</span><span class="p">,</span><span class="n">p</span><span class="p">))</span>
<span class="c1">#    P = np.random.rand(r,p)</span>

    <span class="c1"># aux. variables</span>
    <span class="n">Wtil</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">W</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
    <span class="n">Ptil</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">P</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
    <span class="n">Htil</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">H</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="c1"># &lt;- for graph regularization</span>

    <span class="n">idx_i</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">r1</span><span class="p">)</span>       <span class="c1"># &lt;- intrinsic graph indices (top half of H matrices)</span>
    <span class="n">idx_p</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">r1</span><span class="p">,</span><span class="n">r1</span><span class="o">+</span><span class="n">r2</span><span class="p">)</span> <span class="c1"># &lt;- penalty   graph indices (bot half of H matrices)</span>
<span class="c1">#    Htil1 = np.zeros((r1,n)) # &lt;- the top half part of Htil (intrinsic part)</span>
<span class="c1">#    Htil2 = np.zeros((r2,n)) # &lt;- the bot half part of Htil (complementary part)</span>

    <span class="c1"># dual variables</span>
    <span class="n">Lam_W</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">W</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
    <span class="n">Lam_P</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">P</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
    <span class="n">Lam_H</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">H</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
    <span class="n">Lam_Htil</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">H</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="c1"># &lt;- for graph regularization</span>
    <span class="c1">#%%=== create empty lists for tracking updates ===</span>
    <span class="c1"># keep track of frobenius norm loss</span>
    <span class="n">cost_list</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">cost_nmf_list</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">cost_graph_list</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="n">cost_nmf</span> <span class="o">=</span> <span class="n">norm</span><span class="p">(</span><span class="n">Wtil</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">Ptil</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">X</span><span class="p">))</span> <span class="o">-</span> <span class="n">X</span><span class="p">,</span><span class="s1">&#39;fro&#39;</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="o">/</span><span class="mi">2</span>
    <span class="n">_term1</span> <span class="o">=</span> <span class="n">trace</span><span class="p">(</span><span class="n">L1</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span> <span class="n">dot</span><span class="p">(</span><span class="n">Htil</span><span class="p">[</span><span class="n">idx_i</span><span class="p">]</span><span class="o">.</span><span class="n">T</span><span class="p">,</span><span class="n">Htil</span><span class="p">[</span><span class="n">idx_i</span><span class="p">])))</span>
    <span class="n">_term2</span> <span class="o">=</span> <span class="n">trace</span><span class="p">(</span><span class="n">L2</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span> <span class="n">dot</span><span class="p">(</span><span class="n">Htil</span><span class="p">[</span><span class="n">idx_p</span><span class="p">]</span><span class="o">.</span><span class="n">T</span><span class="p">,</span><span class="n">Htil</span><span class="p">[</span><span class="n">idx_p</span><span class="p">])))</span>
    <span class="n">cost_graph</span> <span class="o">=</span> <span class="p">(</span><span class="n">tau</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">_term1</span> <span class="o">+</span> <span class="n">_term2</span><span class="p">)</span>
    <span class="n">cost</span> <span class="o">=</span> <span class="n">cost_nmf</span> <span class="o">+</span> <span class="n">cost_graph</span>

    <span class="n">cost_nmf_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">cost_nmf</span><span class="p">)</span>
    <span class="n">cost_graph_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">cost_graph</span><span class="p">)</span>
    <span class="n">cost_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">cost</span><span class="p">)</span>

    <span class="c1"># relative change in cost</span>
    <span class="n">diffcost</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="c1"># keep track of relative primal residual</span>
    <span class="n">res_W</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">res_P</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">res_H</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">res_Htil</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="c1"># also keep track of diffW</span>
<span class="c1">#    diffW = []</span>
    <span class="c1">#%%=== run admm iterations ===</span>
    <span class="n">eye_r</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="n">r</span><span class="p">)</span>
    <span class="n">eye_n</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>

    <span class="c1"># precompute term needed for inversion lemma</span>
    <span class="n">K</span> <span class="o">=</span> <span class="n">solve</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="o">+</span> <span class="n">dot</span><span class="p">(</span><span class="n">X</span><span class="o">.</span><span class="n">T</span><span class="p">,</span><span class="n">X</span><span class="p">),</span> <span class="n">X</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>

    <span class="n">start</span><span class="o">=</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
    <span class="k">for</span> <span class="nb">iter</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">max_iter</span><span class="p">):</span>
<span class="c1">#        W_old = W #&lt;- to keep track of diffW</span>

        <span class="c1">#================ primal updates (P, W, H, Ptil, Wtil) ===============#</span>
        <span class="c1"># update for P involves inversion lemma...</span>
        <span class="n">_R</span> <span class="o">=</span> <span class="n">dot</span><span class="p">(</span><span class="n">X</span><span class="p">,</span><span class="n">Lam_H</span><span class="o">.</span><span class="n">T</span><span class="p">)</span><span class="o">/</span><span class="n">rho</span> <span class="o">-</span> <span class="n">Lam_P</span><span class="o">.</span><span class="n">T</span><span class="o">/</span><span class="n">rho</span> <span class="o">+</span> <span class="n">dot</span><span class="p">(</span><span class="n">X</span><span class="p">,</span><span class="n">H</span><span class="o">.</span><span class="n">T</span><span class="p">)</span> <span class="o">+</span> <span class="n">Ptil</span><span class="o">.</span><span class="n">T</span>
        <span class="n">P</span> <span class="o">=</span> <span class="p">(</span><span class="n">_R</span> <span class="o">-</span> <span class="n">X</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span> <span class="n">dot</span><span class="p">(</span><span class="n">K</span><span class="p">,</span><span class="n">_R</span><span class="p">)</span> <span class="p">))</span><span class="o">.</span><span class="n">T</span>
        <span class="n">Ptil</span> <span class="o">=</span> <span class="p">(</span><span class="n">P</span><span class="o">+</span><span class="n">Lam_P</span><span class="o">/</span><span class="n">rho</span><span class="p">)</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>

        <span class="c1"># (W,H) updates</span>
        <span class="n">H</span> <span class="o">=</span> <span class="n">solve</span><span class="p">(</span><span class="n">dot</span><span class="p">(</span><span class="n">W</span><span class="o">.</span><span class="n">T</span><span class="p">,</span><span class="n">W</span><span class="p">)</span><span class="o">+</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">rho</span><span class="p">)</span><span class="o">*</span><span class="n">eye_r</span><span class="p">,</span>
                  <span class="n">dot</span><span class="p">(</span><span class="n">W</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">X</span><span class="p">)</span> <span class="o">+</span> <span class="n">rho</span><span class="o">*</span><span class="n">dot</span><span class="p">(</span><span class="n">P</span><span class="p">,</span><span class="n">X</span><span class="p">)</span> <span class="o">-</span> <span class="n">Lam_H</span> <span class="o">+</span> <span class="n">rho</span><span class="o">*</span><span class="n">Htil</span> <span class="o">-</span> <span class="n">Lam_Htil</span> <span class="p">)</span>
        <span class="n">W</span> <span class="o">=</span> <span class="n">solve</span><span class="p">(</span><span class="n">dot</span><span class="p">(</span><span class="n">H</span><span class="p">,</span><span class="n">H</span><span class="o">.</span><span class="n">T</span><span class="p">)</span><span class="o">+</span><span class="n">rho</span><span class="o">*</span><span class="n">eye_r</span><span class="p">,</span> <span class="n">dot</span><span class="p">(</span><span class="n">H</span><span class="p">,</span> <span class="n">X</span><span class="o">.</span><span class="n">T</span><span class="p">)</span> <span class="o">+</span> <span class="n">rho</span><span class="o">*</span><span class="n">Wtil</span><span class="o">.</span><span class="n">T</span> <span class="o">-</span> <span class="n">Lam_W</span><span class="o">.</span><span class="n">T</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>
        <span class="n">Wtil</span> <span class="o">=</span> <span class="p">(</span><span class="n">W</span><span class="o">+</span><span class="n">Lam_W</span><span class="o">/</span><span class="n">rho</span><span class="p">)</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>

        <span class="c1"># --- Htil updates...broken down to two part: Htil1 and Htil2 ---</span>
        <span class="c1"># intrinsic graph update (top half of Htil matrix)</span>
        <span class="n">Htil</span><span class="p">[</span><span class="n">idx_i</span><span class="p">]</span> <span class="o">=</span> <span class="n">solve</span><span class="p">(</span><span class="n">tau</span><span class="o">*</span><span class="n">L1</span> <span class="o">+</span> <span class="n">rho</span><span class="o">*</span><span class="n">eye_n</span><span class="p">,</span> <span class="n">rho</span><span class="o">*</span><span class="n">H</span><span class="p">[</span><span class="n">idx_i</span><span class="p">]</span><span class="o">.</span><span class="n">T</span><span class="o">+</span><span class="n">Lam_Htil</span><span class="p">[</span><span class="n">idx_i</span><span class="p">]</span><span class="o">.</span><span class="n">T</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>

        <span class="c1"># penalty graph update (bottom half of Htil matrix)</span>
        <span class="n">Htil</span><span class="p">[</span><span class="n">idx_p</span><span class="p">]</span> <span class="o">=</span> <span class="n">solve</span><span class="p">(</span><span class="n">tau</span><span class="o">*</span><span class="n">L2</span> <span class="o">+</span> <span class="n">rho</span><span class="o">*</span><span class="n">eye_n</span><span class="p">,</span> <span class="n">rho</span><span class="o">*</span><span class="n">H</span><span class="p">[</span><span class="n">idx_p</span><span class="p">]</span><span class="o">.</span><span class="n">T</span><span class="o">+</span><span class="n">Lam_Htil</span><span class="p">[</span><span class="n">idx_p</span><span class="p">]</span><span class="o">.</span><span class="n">T</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>

        <span class="c1">#====================== dual updates =================================#</span>
        <span class="n">Lam_W</span> <span class="o">=</span> <span class="n">Lam_W</span> <span class="o">+</span> <span class="n">rho</span><span class="o">*</span><span class="p">(</span><span class="n">W</span> <span class="o">-</span> <span class="n">Wtil</span><span class="p">)</span>
        <span class="n">Lam_P</span> <span class="o">=</span> <span class="n">Lam_P</span> <span class="o">+</span> <span class="n">rho</span><span class="o">*</span><span class="p">(</span><span class="n">P</span> <span class="o">-</span> <span class="n">Ptil</span><span class="p">)</span>
        <span class="n">Lam_H</span> <span class="o">=</span> <span class="n">Lam_H</span> <span class="o">+</span> <span class="n">rho</span><span class="o">*</span><span class="p">(</span><span class="n">H</span> <span class="o">-</span> <span class="n">dot</span><span class="p">(</span><span class="n">P</span><span class="p">,</span><span class="n">X</span><span class="p">))</span>
        <span class="n">Lam_Htil</span> <span class="o">=</span> <span class="n">Lam_Htil</span> <span class="o">+</span> <span class="n">rho</span><span class="o">*</span><span class="p">(</span><span class="n">H</span><span class="o">-</span><span class="n">Htil</span><span class="p">)</span>

        <span class="c1">#============ comptute objective values ==============================#</span>
        <span class="c1"># main loss function</span>
        <span class="n">cost_nmf</span> <span class="o">=</span> <span class="n">norm</span><span class="p">(</span><span class="n">Wtil</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">Ptil</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">X</span><span class="p">))</span> <span class="o">-</span> <span class="n">X</span><span class="p">,</span><span class="s1">&#39;fro&#39;</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="o">/</span><span class="mi">2</span>
        <span class="n">_term1</span> <span class="o">=</span> <span class="n">trace</span><span class="p">(</span><span class="n">L1</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span> <span class="n">dot</span><span class="p">(</span><span class="n">Htil</span><span class="p">[</span><span class="n">idx_i</span><span class="p">]</span><span class="o">.</span><span class="n">T</span><span class="p">,</span><span class="n">Htil</span><span class="p">[</span><span class="n">idx_i</span><span class="p">])))</span>
        <span class="n">_term2</span> <span class="o">=</span> <span class="n">trace</span><span class="p">(</span><span class="n">L2</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span> <span class="n">dot</span><span class="p">(</span><span class="n">Htil</span><span class="p">[</span><span class="n">idx_p</span><span class="p">]</span><span class="o">.</span><span class="n">T</span><span class="p">,</span><span class="n">Htil</span><span class="p">[</span><span class="n">idx_p</span><span class="p">])))</span>
        <span class="n">cost_graph</span> <span class="o">=</span> <span class="p">(</span><span class="n">tau</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">_term1</span> <span class="o">+</span> <span class="n">_term2</span><span class="p">)</span>
        <span class="n">cost</span> <span class="o">=</span> <span class="n">cost_nmf</span> <span class="o">+</span> <span class="n">cost_graph</span>

        <span class="n">cost_nmf_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">cost_nmf</span><span class="p">)</span>
        <span class="n">cost_graph_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">cost_graph</span><span class="p">)</span>
        <span class="n">cost_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">cost</span><span class="p">)</span>

        <span class="c1"># relative change in cost</span>
        <span class="n">diffcost</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">cost_list</span><span class="p">[</span><span class="nb">iter</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">cost_list</span><span class="p">[</span><span class="nb">iter</span><span class="p">])</span><span class="o">/</span><span class="n">cost_list</span><span class="p">[</span><span class="nb">iter</span><span class="p">])</span>

        <span class="c1"># relative primal residuals</span>
        <span class="n">res_W</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">norm</span><span class="p">(</span><span class="n">W</span><span class="o">-</span><span class="n">Wtil</span><span class="p">,</span><span class="s1">&#39;fro&#39;</span><span class="p">)</span><span class="o">/</span><span class="n">norm</span><span class="p">(</span><span class="n">W</span><span class="p">,</span><span class="s1">&#39;fro&#39;</span><span class="p">))</span>
        <span class="n">res_P</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">norm</span><span class="p">(</span><span class="n">P</span><span class="o">-</span><span class="n">Ptil</span><span class="p">,</span><span class="s1">&#39;fro&#39;</span><span class="p">)</span><span class="o">/</span><span class="n">norm</span><span class="p">(</span><span class="n">P</span><span class="p">,</span><span class="s1">&#39;fro&#39;</span><span class="p">))</span>
        <span class="n">res_H</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">norm</span><span class="p">(</span><span class="n">H</span><span class="o">-</span><span class="n">P</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">X</span><span class="p">),</span><span class="s1">&#39;fro&#39;</span><span class="p">)</span><span class="o">/</span><span class="n">norm</span><span class="p">(</span><span class="n">H</span><span class="p">,</span><span class="s1">&#39;fro&#39;</span><span class="p">))</span>
        <span class="n">res_Htil</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">norm</span><span class="p">(</span><span class="n">H</span><span class="o">-</span><span class="n">Htil</span><span class="p">,</span><span class="s1">&#39;fro&#39;</span><span class="p">)</span><span class="o">/</span><span class="n">norm</span><span class="p">(</span><span class="n">H</span><span class="p">,</span><span class="s1">&#39;fro&#39;</span><span class="p">))</span>

        <span class="c1"># relative change in basis matrix</span>
<span class="c1">#        diffW.append( norm(W-W_old,&#39;fro&#39;)/ norm(W_old, &#39;fro&#39;) )</span>

        <span class="c1">#=== termination check ====#</span>
        <span class="n">check_exit</span>  <span class="o">=</span> <span class="p">(</span><span class="n">diffcost</span><span class="p">[</span><span class="nb">iter</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">tol</span><span class="p">)</span>
        <span class="n">check_exit</span> <span class="o">&amp;=</span> <span class="p">(</span><span class="n">res_W</span><span class="p">[</span><span class="nb">iter</span><span class="p">]</span> <span class="o">&lt;</span>  <span class="n">tol</span><span class="p">)</span>
        <span class="n">check_exit</span> <span class="o">&amp;=</span> <span class="p">(</span><span class="n">res_P</span><span class="p">[</span><span class="nb">iter</span><span class="p">]</span> <span class="o">&lt;</span>  <span class="n">tol</span><span class="p">)</span>
        <span class="n">check_exit</span> <span class="o">&amp;=</span> <span class="p">(</span><span class="n">res_H</span><span class="p">[</span><span class="nb">iter</span><span class="p">]</span> <span class="o">&lt;</span>  <span class="n">tol</span><span class="p">)</span>
        <span class="n">check_exit</span> <span class="o">&amp;=</span> <span class="p">(</span><span class="n">res_Htil</span><span class="p">[</span><span class="nb">iter</span><span class="p">]</span> <span class="o">&lt;</span>  <span class="n">tol</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">check_exit</span> <span class="ow">and</span> <span class="nb">iter</span> <span class="o">&gt;</span> <span class="mi">300</span><span class="p">:</span> <span class="c1"># allow 300 iterations of &quot;burn-in&quot;</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">silence</span><span class="p">:</span>
                <span class="k">print</span> <span class="s2">&quot;Termination condition met.  Exit at iter =&quot;</span><span class="p">,</span><span class="nb">iter</span><span class="p">,</span>
            <span class="k">break</span>
        <span class="c1">#=============== print current progress ==============================#</span>
<span class="c1">#        if iter % disp_freq == 0:</span>
        <span class="k">if</span> <span class="p">(</span><span class="nb">iter</span><span class="o">&gt;</span><span class="mi">1</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="nb">iter</span> <span class="o">%</span> <span class="n">disp_freq</span> <span class="o">==</span> <span class="mi">0</span><span class="p">):</span>
<span class="c1">#            str_ = &quot;iter={:4} cost={:3.3f}&quot;.format(iter,cost_list[iter+1])</span>
            <span class="n">str_</span> <span class="o">=</span> <span class="s2">&quot;iter={:4} cost={:6.5e}&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">iter</span><span class="p">,</span><span class="n">cost</span><span class="p">)</span>
            <span class="n">str_</span> <span class="o">+=</span> <span class="s2">&quot; nmf={:3.2e}&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">cost_nmf</span><span class="p">)</span>
            <span class="n">str_</span> <span class="o">+=</span> <span class="s2">&quot; graph={:3.2e}&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">cost_graph</span><span class="p">)</span>
            <span class="n">str_</span> <span class="o">+=</span> <span class="s2">&quot; diffcost={:3.2e}&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">diffcost</span><span class="p">[</span><span class="nb">iter</span><span class="p">])</span>
            <span class="n">str_</span> <span class="o">+=</span> <span class="s2">&quot; W={:3.2e}&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">res_W</span><span class="p">[</span><span class="nb">iter</span><span class="p">])</span>
            <span class="n">str_</span> <span class="o">+=</span> <span class="s2">&quot; P={:3.2e}&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">res_P</span><span class="p">[</span><span class="nb">iter</span><span class="p">])</span>
            <span class="n">str_</span> <span class="o">+=</span> <span class="s2">&quot; H={:3.2e}&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">res_H</span><span class="p">[</span><span class="nb">iter</span><span class="p">])</span>
            <span class="n">str_</span> <span class="o">+=</span> <span class="s2">&quot; Htil={:3.2e}&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">res_Htil</span><span class="p">[</span><span class="nb">iter</span><span class="p">])</span>
<span class="c1">#            str_ += &quot; diffW={:3.2e}&quot;.format(diffW[iter])</span>
            <span class="k">print</span> <span class="n">str_</span> <span class="o">+</span> <span class="s2">&quot; ({:3.1f} sec)&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span><span class="o">-</span><span class="n">start</span><span class="p">)</span>
    <span class="c1">#%%---- end of admm for loop ---------------------------------------------#</span>
    <span class="n">cost_list</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">cost_list</span><span class="p">)</span>

    <span class="c1"># convert to pandas dataframe</span>
    <span class="n">cost</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">([</span><span class="n">cost_list</span><span class="p">,</span> <span class="n">cost_nmf_list</span><span class="p">,</span> <span class="n">cost_graph_list</span><span class="p">],</span>
                        <span class="n">index</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;total&#39;</span><span class="p">,</span><span class="s1">&#39;nmf&#39;</span><span class="p">,</span><span class="s1">&#39;graph&#39;</span><span class="p">])</span><span class="o">.</span><span class="n">T</span>

    <span class="n">res</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">([</span><span class="n">res_W</span><span class="p">,</span><span class="n">res_P</span><span class="p">,</span><span class="n">res_H</span><span class="p">,</span><span class="n">diffcost</span><span class="p">],</span>
                       <span class="n">index</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;res_W&#39;</span><span class="p">,</span><span class="s1">&#39;res_P&#39;</span><span class="p">,</span><span class="s1">&#39;res_H&#39;</span><span class="p">,</span><span class="s1">&#39;diffcost&#39;</span><span class="p">])</span><span class="o">.</span><span class="n">T</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">silence</span><span class="p">:</span> <span class="n">print_time</span><span class="p">(</span><span class="n">start</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">W</span><span class="p">,</span><span class="n">P</span><span class="p">,</span><span class="n">H</span><span class="p">,</span><span class="n">Wtil</span><span class="p">,</span><span class="n">Ptil</span><span class="p">,</span><span class="n">cost</span><span class="p">,</span><span class="n">res</span>



<span class="k">def</span> <span class="nf">spnge_admm</span><span class="p">(</span><span class="n">X</span><span class="p">,</span><span class="n">r1</span><span class="p">,</span><span class="n">r2</span><span class="p">,</span><span class="n">L1</span><span class="p">,</span><span class="n">L2</span><span class="p">,</span><span class="n">tau</span><span class="o">=</span><span class="mf">1e-1</span><span class="p">,</span><span class="n">rho</span><span class="o">=</span><span class="mf">1e3</span><span class="p">,</span><span class="n">max_iter</span><span class="o">=</span><span class="mi">5000</span><span class="p">,</span><span class="n">tol</span><span class="o">=</span><span class="mf">1e-4</span><span class="p">,</span>
               <span class="n">W_init</span><span class="o">=</span><span class="s1">&#39;nndsvd&#39;</span><span class="p">,</span><span class="n">disp_freq</span><span class="o">=</span><span class="mi">1000</span><span class="p">,</span><span class="n">silence</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Projective non-negative graph embedding using ADMM.</span>

<span class="sd">    Note: in my Onenote, I used H_s, H_p...these are H_1 and H_2 in this code</span>
<span class="sd">    (basically, replace all (s,p) pairs with (1,2) pair)</span>

<span class="sd">    &gt;&gt;&gt; W,P,H,Wtil,Ptil,cost_list,res = gpnmf_admm(X,r,rho=5e2)</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    X : ndarray of shape (n_features, n_samples)=(p,n)</span>
<span class="sd">        Data matrix with columns as data points</span>
<span class="sd">    r1 : int</span>
<span class="sd">        Dimension of the intrinsic embedding space (n_components)</span>
<span class="sd">    r2 : int</span>
<span class="sd">        Dimension of the complementary embedding space (n_components)</span>
<span class="sd">    L1 : ndarray of shape = [n_samples, n_samples]</span>
<span class="sd">        Laplacian matrix of intrinsic graph</span>
<span class="sd">    L2 : ndarray of shape = [n_samples, n_samples]</span>
<span class="sd">        Laplacian matrix of penalty graph.</span>
<span class="sd">    tau : float</span>
<span class="sd">        Amount of graph regularization to apply</span>
<span class="sd">    rho : float</span>
<span class="sd">        Augmented Lagrangian parameter</span>
<span class="sd">    max_iter : int</span>
<span class="sd">        max number of iterations</span>
<span class="sd">    tol : float</span>
<span class="sd">        convergence tolerance (on relative change in objective value and</span>
<span class="sd">        all primal residuals)</span>
<span class="sd">    W_init : None (default), rng, or &#39;nndsvd&#39;</span>
<span class="sd">        Way to initialize W (and H).  If ``None`` or ``RandomState object``</span>
<span class="sd">        is supplied, both W and H will be initialized via non-negative</span>
<span class="sd">        random number.  If ``&#39;nndsvd&#39;``, will use deterministic initialization</span>
<span class="sd">        NNDSVD &quot;Non-Negative Double Singular Value Decomposition&quot;, proposed by</span>
<span class="sd">        Boutsidis2008.</span>
<span class="sd">    disp_freq : int</span>
<span class="sd">        Frequency of update display (in iterations)</span>
<span class="sd">    silence : bool</span>
<span class="sd">        If True, don&#39;t print-out convergence detail at the end.</span>

<span class="sd">    Update history</span>
<span class="sd">    --------------</span>
<span class="sd">    **02/04/2016** - function created</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">r</span> <span class="o">=</span> <span class="n">r1</span><span class="o">+</span><span class="n">r2</span>
    <span class="n">rho</span> <span class="o">*=</span> <span class="mf">1.</span>
    <span class="n">tau</span> <span class="o">*=</span> <span class="mf">1.</span>
    <span class="n">p</span><span class="p">,</span><span class="n">n</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">shape</span>
    <span class="c1">#%%=== initialize variables =====</span>
    <span class="c1"># define main primal variable W (basis matrix)</span>
    <span class="k">if</span> <span class="n">W_init</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
        <span class="n">W</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="n">p</span><span class="p">,</span><span class="n">r</span><span class="p">)</span>
        <span class="n">W</span> <span class="o">/=</span> <span class="n">norm</span><span class="p">(</span><span class="n">W</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>

        <span class="n">H</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="n">r</span><span class="p">,</span><span class="n">n</span><span class="p">)</span>
        <span class="n">H</span> <span class="o">/=</span> <span class="n">norm</span><span class="p">(</span><span class="n">H</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">W_init</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">RandomState</span><span class="p">):</span>
        <span class="n">rng</span> <span class="o">=</span> <span class="n">W_init</span>

        <span class="n">W</span> <span class="o">=</span> <span class="n">rng</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="n">p</span><span class="p">,</span><span class="n">r</span><span class="p">)</span>
        <span class="n">W</span> <span class="o">/=</span> <span class="n">norm</span><span class="p">(</span><span class="n">W</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>

        <span class="n">H</span> <span class="o">=</span> <span class="n">rng</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="n">r</span><span class="p">,</span><span class="n">n</span><span class="p">)</span>
        <span class="n">H</span> <span class="o">/=</span> <span class="n">norm</span><span class="p">(</span><span class="n">H</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">W_init</span> <span class="o">==</span> <span class="s1">&#39;nndsvd&#39;</span><span class="p">:</span>
<span class="c1">#        W = nnd_svd(X,r)</span>
        <span class="n">W</span><span class="p">,</span><span class="n">H</span> <span class="o">=</span> <span class="n">nnd_svd</span><span class="p">(</span><span class="n">X</span><span class="p">,</span><span class="n">r</span><span class="p">,</span><span class="n">get_H</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Invalid input for &quot;W_init&quot;&#39;</span><span class="p">)</span>

    <span class="n">P</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">r</span><span class="p">,</span><span class="n">p</span><span class="p">))</span>
<span class="c1">#    P = np.random.rand(r,p)</span>

    <span class="c1"># aux. variables</span>
    <span class="n">Wtil</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">W</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
    <span class="n">W2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">W</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>   <span class="c1"># &lt;- for spectral projection</span>
    <span class="n">Ptil</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">P</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
    <span class="n">Htil</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">H</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="c1"># &lt;- for graph regularization</span>

    <span class="n">idx_i</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">r1</span><span class="p">)</span>       <span class="c1"># &lt;- intrinsic graph indices (top half of H matrices)</span>
    <span class="n">idx_p</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">r1</span><span class="p">,</span><span class="n">r1</span><span class="o">+</span><span class="n">r2</span><span class="p">)</span> <span class="c1"># &lt;- penalty   graph indices (bot half of H matrices)</span>
<span class="c1">#    Htil1 = np.zeros((r1,n)) # &lt;- the top half part of Htil (intrinsic part)</span>
<span class="c1">#    Htil2 = np.zeros((r2,n)) # &lt;- the bot half part of Htil (complementary part)</span>

    <span class="c1"># dual variables</span>
    <span class="n">Lam_W</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">W</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
    <span class="n">Lam_W2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">W</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>   <span class="c1"># &lt;- for spectral projection</span>
    <span class="n">Lam_P</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">P</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
    <span class="n">Lam_H</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">H</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
    <span class="n">Lam_Htil</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">H</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="c1"># &lt;- for graph regularization</span>
    <span class="c1">#%%=== create empty lists for tracking updates ===</span>
    <span class="c1"># keep track of frobenius norm loss</span>
    <span class="n">cost_list</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">cost_nmf_list</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">cost_graph_list</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="n">cost_nmf</span> <span class="o">=</span> <span class="n">norm</span><span class="p">(</span><span class="n">Wtil</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">Ptil</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">X</span><span class="p">))</span> <span class="o">-</span> <span class="n">X</span><span class="p">,</span><span class="s1">&#39;fro&#39;</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="o">/</span><span class="mi">2</span>
    <span class="n">_term1</span> <span class="o">=</span> <span class="n">trace</span><span class="p">(</span><span class="n">L1</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span> <span class="n">dot</span><span class="p">(</span><span class="n">Htil</span><span class="p">[</span><span class="n">idx_i</span><span class="p">]</span><span class="o">.</span><span class="n">T</span><span class="p">,</span><span class="n">Htil</span><span class="p">[</span><span class="n">idx_i</span><span class="p">])))</span>
    <span class="n">_term2</span> <span class="o">=</span> <span class="n">trace</span><span class="p">(</span><span class="n">L2</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span> <span class="n">dot</span><span class="p">(</span><span class="n">Htil</span><span class="p">[</span><span class="n">idx_p</span><span class="p">]</span><span class="o">.</span><span class="n">T</span><span class="p">,</span><span class="n">Htil</span><span class="p">[</span><span class="n">idx_p</span><span class="p">])))</span>
    <span class="n">cost_graph</span> <span class="o">=</span> <span class="p">(</span><span class="n">tau</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">_term1</span> <span class="o">+</span> <span class="n">_term2</span><span class="p">)</span>
    <span class="n">cost</span> <span class="o">=</span> <span class="n">cost_nmf</span> <span class="o">+</span> <span class="n">cost_graph</span>

    <span class="n">cost_nmf_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">cost_nmf</span><span class="p">)</span>
    <span class="n">cost_graph_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">cost_graph</span><span class="p">)</span>
    <span class="n">cost_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">cost</span><span class="p">)</span>

    <span class="c1"># relative change in cost</span>
    <span class="n">diffcost</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="c1"># keep track of relative primal residual</span>
    <span class="n">res_W</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">res_W2</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">res_P</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">res_H</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">res_Htil</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="c1"># also keep track of diffW</span>
<span class="c1">#    diffW = []</span>
    <span class="c1">#%%=== run admm iterations ===</span>
    <span class="n">eye_r</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="n">r</span><span class="p">)</span>
    <span class="n">eye_n</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>

    <span class="c1"># precompute term needed for inversion lemma</span>
    <span class="n">K</span> <span class="o">=</span> <span class="n">solve</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="o">+</span> <span class="n">dot</span><span class="p">(</span><span class="n">X</span><span class="o">.</span><span class="n">T</span><span class="p">,</span><span class="n">X</span><span class="p">),</span> <span class="n">X</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>

    <span class="n">start</span><span class="o">=</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
    <span class="k">for</span> <span class="nb">iter</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">max_iter</span><span class="p">):</span>
<span class="c1">#        W_old = W #&lt;- to keep track of diffW</span>

        <span class="c1">#================ primal updates (P, W, H, Ptil, Wtil) ===============#</span>
        <span class="c1"># update for P involves inversion lemma...</span>
        <span class="n">_R</span> <span class="o">=</span> <span class="n">dot</span><span class="p">(</span><span class="n">X</span><span class="p">,</span><span class="n">Lam_H</span><span class="o">.</span><span class="n">T</span><span class="p">)</span><span class="o">/</span><span class="n">rho</span> <span class="o">-</span> <span class="n">Lam_P</span><span class="o">.</span><span class="n">T</span><span class="o">/</span><span class="n">rho</span> <span class="o">+</span> <span class="n">dot</span><span class="p">(</span><span class="n">X</span><span class="p">,</span><span class="n">H</span><span class="o">.</span><span class="n">T</span><span class="p">)</span> <span class="o">+</span> <span class="n">Ptil</span><span class="o">.</span><span class="n">T</span>
        <span class="n">P</span> <span class="o">=</span> <span class="p">(</span><span class="n">_R</span> <span class="o">-</span> <span class="n">X</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span> <span class="n">dot</span><span class="p">(</span><span class="n">K</span><span class="p">,</span><span class="n">_R</span><span class="p">)</span> <span class="p">))</span><span class="o">.</span><span class="n">T</span>
        <span class="n">Ptil</span> <span class="o">=</span> <span class="p">(</span><span class="n">P</span><span class="o">+</span><span class="n">Lam_P</span><span class="o">/</span><span class="n">rho</span><span class="p">)</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>

        <span class="c1"># (W,H) updates</span>
        <span class="n">H</span> <span class="o">=</span> <span class="n">solve</span><span class="p">(</span><span class="n">dot</span><span class="p">(</span><span class="n">W</span><span class="o">.</span><span class="n">T</span><span class="p">,</span><span class="n">W</span><span class="p">)</span><span class="o">+</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">rho</span><span class="p">)</span><span class="o">*</span><span class="n">eye_r</span><span class="p">,</span>
                  <span class="n">dot</span><span class="p">(</span><span class="n">W</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">X</span><span class="p">)</span> <span class="o">+</span> <span class="n">rho</span><span class="o">*</span><span class="n">dot</span><span class="p">(</span><span class="n">P</span><span class="p">,</span><span class="n">X</span><span class="p">)</span> <span class="o">-</span> <span class="n">Lam_H</span> <span class="o">+</span> <span class="n">rho</span><span class="o">*</span><span class="n">Htil</span> <span class="o">-</span> <span class="n">Lam_Htil</span> <span class="p">)</span>
        <span class="n">W</span> <span class="o">=</span> <span class="n">solve</span><span class="p">(</span><span class="n">dot</span><span class="p">(</span><span class="n">H</span><span class="p">,</span><span class="n">H</span><span class="o">.</span><span class="n">T</span><span class="p">)</span><span class="o">+</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">rho</span><span class="p">)</span><span class="o">*</span><span class="n">eye_r</span><span class="p">,</span>
                  <span class="n">dot</span><span class="p">(</span><span class="n">H</span><span class="p">,</span> <span class="n">X</span><span class="o">.</span><span class="n">T</span><span class="p">)</span> <span class="o">+</span> <span class="n">rho</span><span class="o">*</span><span class="n">Wtil</span><span class="o">.</span><span class="n">T</span> <span class="o">-</span> <span class="n">Lam_W</span><span class="o">.</span><span class="n">T</span> <span class="o">+</span> <span class="n">rho</span><span class="o">*</span><span class="n">W2</span><span class="o">.</span><span class="n">T</span> <span class="o">-</span> <span class="n">Lam_W2</span><span class="o">.</span><span class="n">T</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>
        <span class="n">Wtil</span> <span class="o">=</span> <span class="p">(</span><span class="n">W</span><span class="o">+</span><span class="n">Lam_W</span><span class="o">/</span><span class="n">rho</span><span class="p">)</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>

        <span class="c1"># specral projection on two column blocks separately</span>
        <span class="n">_W</span> <span class="o">=</span> <span class="n">W</span> <span class="o">+</span> <span class="n">Lam_W2</span><span class="o">/</span><span class="n">rho</span>
        <span class="n">W2</span><span class="p">[:,</span><span class="n">idx_i</span><span class="p">]</span> <span class="o">=</span> <span class="n">projection_spectral</span><span class="p">(</span><span class="n">_W</span><span class="p">[:,</span><span class="n">idx_i</span><span class="p">])</span>
        <span class="n">W2</span><span class="p">[:,</span><span class="n">idx_p</span><span class="p">]</span> <span class="o">=</span> <span class="n">projection_spectral</span><span class="p">(</span><span class="n">_W</span><span class="p">[:,</span><span class="n">idx_p</span><span class="p">])</span>

        <span class="c1"># --- Htil updates...broken down to two part: Htil1 and Htil2 ---</span>
        <span class="c1"># intrinsic graph update (top half of Htil matrix)</span>
        <span class="n">Htil</span><span class="p">[</span><span class="n">idx_i</span><span class="p">]</span> <span class="o">=</span> <span class="n">solve</span><span class="p">(</span><span class="n">tau</span><span class="o">*</span><span class="n">L1</span> <span class="o">+</span> <span class="n">rho</span><span class="o">*</span><span class="n">eye_n</span><span class="p">,</span> <span class="n">rho</span><span class="o">*</span><span class="n">H</span><span class="p">[</span><span class="n">idx_i</span><span class="p">]</span><span class="o">.</span><span class="n">T</span><span class="o">+</span><span class="n">Lam_Htil</span><span class="p">[</span><span class="n">idx_i</span><span class="p">]</span><span class="o">.</span><span class="n">T</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>

        <span class="c1"># penalty graph update (bottom half of Htil matrix)</span>
        <span class="n">Htil</span><span class="p">[</span><span class="n">idx_p</span><span class="p">]</span> <span class="o">=</span> <span class="n">solve</span><span class="p">(</span><span class="n">tau</span><span class="o">*</span><span class="n">L2</span> <span class="o">+</span> <span class="n">rho</span><span class="o">*</span><span class="n">eye_n</span><span class="p">,</span> <span class="n">rho</span><span class="o">*</span><span class="n">H</span><span class="p">[</span><span class="n">idx_p</span><span class="p">]</span><span class="o">.</span><span class="n">T</span><span class="o">+</span><span class="n">Lam_Htil</span><span class="p">[</span><span class="n">idx_p</span><span class="p">]</span><span class="o">.</span><span class="n">T</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>

        <span class="c1">#====================== dual updates =================================#</span>
        <span class="n">Lam_W</span> <span class="o">=</span> <span class="n">Lam_W</span> <span class="o">+</span> <span class="n">rho</span><span class="o">*</span><span class="p">(</span><span class="n">W</span> <span class="o">-</span> <span class="n">Wtil</span><span class="p">)</span>
        <span class="n">Lam_W2</span> <span class="o">=</span> <span class="n">Lam_W2</span> <span class="o">+</span> <span class="n">rho</span><span class="o">*</span><span class="p">(</span><span class="n">W</span> <span class="o">-</span> <span class="n">W2</span><span class="p">)</span>
        <span class="n">Lam_P</span> <span class="o">=</span> <span class="n">Lam_P</span> <span class="o">+</span> <span class="n">rho</span><span class="o">*</span><span class="p">(</span><span class="n">P</span> <span class="o">-</span> <span class="n">Ptil</span><span class="p">)</span>
        <span class="n">Lam_H</span> <span class="o">=</span> <span class="n">Lam_H</span> <span class="o">+</span> <span class="n">rho</span><span class="o">*</span><span class="p">(</span><span class="n">H</span> <span class="o">-</span> <span class="n">dot</span><span class="p">(</span><span class="n">P</span><span class="p">,</span><span class="n">X</span><span class="p">))</span>
        <span class="n">Lam_Htil</span> <span class="o">=</span> <span class="n">Lam_Htil</span> <span class="o">+</span> <span class="n">rho</span><span class="o">*</span><span class="p">(</span><span class="n">H</span><span class="o">-</span><span class="n">Htil</span><span class="p">)</span>

        <span class="c1">#============ comptute objective values ==============================#</span>
        <span class="c1"># main loss function</span>
        <span class="n">cost_nmf</span> <span class="o">=</span> <span class="n">norm</span><span class="p">(</span><span class="n">Wtil</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">Ptil</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">X</span><span class="p">))</span> <span class="o">-</span> <span class="n">X</span><span class="p">,</span><span class="s1">&#39;fro&#39;</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="o">/</span><span class="mi">2</span>
        <span class="n">_term1</span> <span class="o">=</span> <span class="n">trace</span><span class="p">(</span><span class="n">L1</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span> <span class="n">dot</span><span class="p">(</span><span class="n">Htil</span><span class="p">[</span><span class="n">idx_i</span><span class="p">]</span><span class="o">.</span><span class="n">T</span><span class="p">,</span><span class="n">Htil</span><span class="p">[</span><span class="n">idx_i</span><span class="p">])))</span>
        <span class="n">_term2</span> <span class="o">=</span> <span class="n">trace</span><span class="p">(</span><span class="n">L2</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span> <span class="n">dot</span><span class="p">(</span><span class="n">Htil</span><span class="p">[</span><span class="n">idx_p</span><span class="p">]</span><span class="o">.</span><span class="n">T</span><span class="p">,</span><span class="n">Htil</span><span class="p">[</span><span class="n">idx_p</span><span class="p">])))</span>
        <span class="n">cost_graph</span> <span class="o">=</span> <span class="p">(</span><span class="n">tau</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">_term1</span> <span class="o">+</span> <span class="n">_term2</span><span class="p">)</span>
        <span class="n">cost</span> <span class="o">=</span> <span class="n">cost_nmf</span> <span class="o">+</span> <span class="n">cost_graph</span>

        <span class="n">cost_nmf_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">cost_nmf</span><span class="p">)</span>
        <span class="n">cost_graph_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">cost_graph</span><span class="p">)</span>
        <span class="n">cost_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">cost</span><span class="p">)</span>

        <span class="c1"># relative change in cost</span>
        <span class="n">diffcost</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">cost_list</span><span class="p">[</span><span class="nb">iter</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">cost_list</span><span class="p">[</span><span class="nb">iter</span><span class="p">])</span><span class="o">/</span><span class="n">cost_list</span><span class="p">[</span><span class="nb">iter</span><span class="p">])</span>

        <span class="c1"># relative primal residuals</span>
        <span class="n">res_W</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">norm</span><span class="p">(</span><span class="n">W</span><span class="o">-</span><span class="n">Wtil</span><span class="p">,</span><span class="s1">&#39;fro&#39;</span><span class="p">)</span><span class="o">/</span><span class="n">norm</span><span class="p">(</span><span class="n">W</span><span class="p">,</span><span class="s1">&#39;fro&#39;</span><span class="p">))</span>
        <span class="n">res_W2</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">norm</span><span class="p">(</span><span class="n">W</span><span class="o">-</span><span class="n">W2</span><span class="p">,</span><span class="s1">&#39;fro&#39;</span><span class="p">)</span><span class="o">/</span><span class="n">norm</span><span class="p">(</span><span class="n">W</span><span class="p">,</span><span class="s1">&#39;fro&#39;</span><span class="p">))</span>
        <span class="n">res_P</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">norm</span><span class="p">(</span><span class="n">P</span><span class="o">-</span><span class="n">Ptil</span><span class="p">,</span><span class="s1">&#39;fro&#39;</span><span class="p">)</span><span class="o">/</span><span class="n">norm</span><span class="p">(</span><span class="n">P</span><span class="p">,</span><span class="s1">&#39;fro&#39;</span><span class="p">))</span>
        <span class="n">res_H</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">norm</span><span class="p">(</span><span class="n">H</span><span class="o">-</span><span class="n">P</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">X</span><span class="p">),</span><span class="s1">&#39;fro&#39;</span><span class="p">)</span><span class="o">/</span><span class="n">norm</span><span class="p">(</span><span class="n">H</span><span class="p">,</span><span class="s1">&#39;fro&#39;</span><span class="p">))</span>
        <span class="n">res_Htil</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">norm</span><span class="p">(</span><span class="n">H</span><span class="o">-</span><span class="n">Htil</span><span class="p">,</span><span class="s1">&#39;fro&#39;</span><span class="p">)</span><span class="o">/</span><span class="n">norm</span><span class="p">(</span><span class="n">H</span><span class="p">,</span><span class="s1">&#39;fro&#39;</span><span class="p">))</span>

        <span class="c1"># relative change in basis matrix</span>
<span class="c1">#        diffW.append( norm(W-W_old,&#39;fro&#39;)/ norm(W_old, &#39;fro&#39;) )</span>

        <span class="c1">#=== termination check ====#</span>
        <span class="n">check_exit</span>  <span class="o">=</span> <span class="p">(</span><span class="n">diffcost</span><span class="p">[</span><span class="nb">iter</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">tol</span><span class="p">)</span>
        <span class="n">check_exit</span> <span class="o">&amp;=</span> <span class="p">(</span><span class="n">res_W</span><span class="p">[</span><span class="nb">iter</span><span class="p">]</span> <span class="o">&lt;</span>  <span class="n">tol</span><span class="p">)</span>
        <span class="n">check_exit</span> <span class="o">&amp;=</span> <span class="p">(</span><span class="n">res_P</span><span class="p">[</span><span class="nb">iter</span><span class="p">]</span> <span class="o">&lt;</span>  <span class="n">tol</span><span class="p">)</span>
        <span class="n">check_exit</span> <span class="o">&amp;=</span> <span class="p">(</span><span class="n">res_H</span><span class="p">[</span><span class="nb">iter</span><span class="p">]</span> <span class="o">&lt;</span>  <span class="n">tol</span><span class="p">)</span>
        <span class="n">check_exit</span> <span class="o">&amp;=</span> <span class="p">(</span><span class="n">res_Htil</span><span class="p">[</span><span class="nb">iter</span><span class="p">]</span> <span class="o">&lt;</span>  <span class="n">tol</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">check_exit</span> <span class="ow">and</span> <span class="nb">iter</span> <span class="o">&gt;</span> <span class="mi">300</span><span class="p">:</span> <span class="c1"># allow 300 iterations of &quot;burn-in&quot;</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">silence</span><span class="p">:</span>
                <span class="k">print</span> <span class="s2">&quot;Termination condition met.  Exit at iter =&quot;</span><span class="p">,</span><span class="nb">iter</span><span class="p">,</span>
            <span class="k">break</span>
        <span class="c1">#=============== print current progress ==============================#</span>
<span class="c1">#        if iter % disp_freq == 0:</span>
        <span class="k">if</span> <span class="p">(</span><span class="nb">iter</span><span class="o">&gt;</span><span class="mi">1</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="nb">iter</span> <span class="o">%</span> <span class="n">disp_freq</span> <span class="o">==</span> <span class="mi">0</span><span class="p">):</span>
<span class="c1">#            str_ = &quot;iter={:4} cost={:3.3f}&quot;.format(iter,cost_list[iter+1])</span>
            <span class="n">str_</span> <span class="o">=</span> <span class="s2">&quot;iter={:4} cost={:6.5e}&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">iter</span><span class="p">,</span><span class="n">cost</span><span class="p">)</span>
            <span class="n">str_</span> <span class="o">+=</span> <span class="s2">&quot; nmf={:3.2e}&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">cost_nmf</span><span class="p">)</span>
            <span class="n">str_</span> <span class="o">+=</span> <span class="s2">&quot; graph={:3.2e}&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">cost_graph</span><span class="p">)</span>
            <span class="n">str_</span> <span class="o">+=</span> <span class="s2">&quot; diffcost={:3.2e}&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">diffcost</span><span class="p">[</span><span class="nb">iter</span><span class="p">])</span>
            <span class="n">str_</span> <span class="o">+=</span> <span class="s2">&quot; W={:3.2e}&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">res_W</span><span class="p">[</span><span class="nb">iter</span><span class="p">])</span>
            <span class="n">str_</span> <span class="o">+=</span> <span class="s2">&quot; W2={:3.2e}&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">res_W2</span><span class="p">[</span><span class="nb">iter</span><span class="p">])</span>
            <span class="n">str_</span> <span class="o">+=</span> <span class="s2">&quot; P={:3.2e}&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">res_P</span><span class="p">[</span><span class="nb">iter</span><span class="p">])</span>
            <span class="n">str_</span> <span class="o">+=</span> <span class="s2">&quot; H={:3.2e}&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">res_H</span><span class="p">[</span><span class="nb">iter</span><span class="p">])</span>
            <span class="n">str_</span> <span class="o">+=</span> <span class="s2">&quot; Htil={:3.2e}&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">res_Htil</span><span class="p">[</span><span class="nb">iter</span><span class="p">])</span>
<span class="c1">#            str_ += &quot; diffW={:3.2e}&quot;.format(diffW[iter])</span>
            <span class="k">print</span> <span class="n">str_</span> <span class="o">+</span> <span class="s2">&quot; ({:3.1f} sec)&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span><span class="o">-</span><span class="n">start</span><span class="p">)</span>
    <span class="c1">#%%---- end of admm for loop ---------------------------------------------#</span>
    <span class="n">cost_list</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">cost_list</span><span class="p">)</span>

    <span class="c1"># convert to pandas dataframe</span>
    <span class="n">cost</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">([</span><span class="n">cost_list</span><span class="p">,</span> <span class="n">cost_nmf_list</span><span class="p">,</span> <span class="n">cost_graph_list</span><span class="p">],</span>
                        <span class="n">index</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;total&#39;</span><span class="p">,</span><span class="s1">&#39;nmf&#39;</span><span class="p">,</span><span class="s1">&#39;graph&#39;</span><span class="p">])</span><span class="o">.</span><span class="n">T</span>

    <span class="n">res</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">([</span><span class="n">res_W</span><span class="p">,</span><span class="n">res_W2</span><span class="p">,</span><span class="n">res_P</span><span class="p">,</span><span class="n">res_H</span><span class="p">,</span><span class="n">diffcost</span><span class="p">],</span>
                       <span class="n">index</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;res_W&#39;</span><span class="p">,</span><span class="s1">&#39;res_W2&#39;</span><span class="p">,</span><span class="s1">&#39;res_P&#39;</span><span class="p">,</span><span class="s1">&#39;res_H&#39;</span><span class="p">,</span><span class="s1">&#39;diffcost&#39;</span><span class="p">])</span><span class="o">.</span><span class="n">T</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">silence</span><span class="p">:</span> <span class="n">print_time</span><span class="p">(</span><span class="n">start</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">W</span><span class="p">,</span><span class="n">P</span><span class="p">,</span><span class="n">H</span><span class="p">,</span><span class="n">Wtil</span><span class="p">,</span><span class="n">Ptil</span><span class="p">,</span><span class="n">cost</span><span class="p">,</span><span class="n">res</span>


<span class="k">def</span> <span class="nf">ls_pnge_admm</span><span class="p">(</span><span class="n">X</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">r1</span><span class="p">,</span><span class="n">r2</span><span class="p">,</span><span class="n">L1</span><span class="p">,</span><span class="n">L2</span><span class="p">,</span><span class="n">tau</span><span class="o">=</span><span class="mf">1e-1</span><span class="p">,</span><span class="n">gam</span><span class="o">=</span><span class="mf">1e-2</span><span class="p">,</span><span class="n">rho</span><span class="o">=</span><span class="mf">1e3</span><span class="p">,</span><span class="n">max_iter</span><span class="o">=</span><span class="mi">5000</span><span class="p">,</span>
                 <span class="n">tol</span><span class="o">=</span><span class="mf">1e-4</span><span class="p">,</span><span class="n">W_init</span><span class="o">=</span><span class="s1">&#39;nndsvd&#39;</span><span class="p">,</span><span class="n">disp_freq</span><span class="o">=</span><span class="mi">1000</span><span class="p">,</span><span class="n">silence</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Projective non-negative graph embedding using ADMM.</span>

<span class="sd">    Note: in my Onenote, I used H_s, H_p...these are H_1 and H_2 in this code</span>
<span class="sd">    (basically, replace all (s,p) pairs with (1,2) pair)</span>

<span class="sd">    &gt;&gt;&gt; W,P,H,Wtil,Ptil,cost_list,res = gpnmf_admm(X,r,rho=5e2)</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    X : ndarray of shape (n_features, n_samples)=(p,n)</span>
<span class="sd">        Data matrix with columns as data points</span>
<span class="sd">    y : array-like of shape [n_samples,]</span>
<span class="sd">        Label vector</span>
<span class="sd">    r1 : int</span>
<span class="sd">        Dimension of the intrinsic embedding space (n_components)</span>
<span class="sd">    r2 : int</span>
<span class="sd">        Dimension of the complementary embedding space (n_components)</span>
<span class="sd">    L1 : ndarray of shape = [n_samples, n_samples]</span>
<span class="sd">        Laplacian matrix of intrinsic graph</span>
<span class="sd">    L2 : ndarray of shape = [n_samples, n_samples]</span>
<span class="sd">        Laplacian matrix of penalty graph.</span>
<span class="sd">    tau : float</span>
<span class="sd">        Amount of graph regularization to apply</span>
<span class="sd">    gam : float</span>
<span class="sd">        Amount of weight on the classification loss</span>
<span class="sd">    rho : float</span>
<span class="sd">        Augmented Lagrangian parameter</span>
<span class="sd">    max_iter : int</span>
<span class="sd">        max number of iterations</span>
<span class="sd">    tol : float</span>
<span class="sd">        convergence tolerance (on relative change in objective value and</span>
<span class="sd">        all primal residuals)</span>
<span class="sd">    W_init : None (default), rng, or &#39;nndsvd&#39;</span>
<span class="sd">        Way to initialize W (and H).  If ``None`` or ``RandomState object``</span>
<span class="sd">        is supplied, both W and H will be initialized via non-negative</span>
<span class="sd">        random number.  If ``&#39;nndsvd&#39;``, will use deterministic initialization</span>
<span class="sd">        NNDSVD &quot;Non-Negative Double Singular Value Decomposition&quot;, proposed by</span>
<span class="sd">        Boutsidis2008.</span>
<span class="sd">    disp_freq : int</span>
<span class="sd">        Frequency of update display (in iterations)</span>
<span class="sd">    silence : bool</span>
<span class="sd">        If True, don&#39;t print-out convergence detail at the end.</span>

<span class="sd">    Update history</span>
<span class="sd">    --------------</span>
<span class="sd">    **02/03/2016** - function created</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">r</span> <span class="o">=</span> <span class="n">r1</span><span class="o">+</span><span class="n">r2</span>
    <span class="n">rho</span> <span class="o">*=</span> <span class="mf">1.</span>
    <span class="n">tau</span> <span class="o">*=</span> <span class="mf">1.</span>
    <span class="n">gam</span> <span class="o">*=</span> <span class="mf">1.</span>
    <span class="n">p</span><span class="p">,</span><span class="n">n</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">shape</span>
    <span class="c1">#%%=== initialize variables =====</span>
    <span class="c1"># define main primal variable W (basis matrix)</span>
    <span class="k">if</span> <span class="n">W_init</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
        <span class="n">W</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="n">p</span><span class="p">,</span><span class="n">r</span><span class="p">)</span>
        <span class="n">W</span> <span class="o">/=</span> <span class="n">norm</span><span class="p">(</span><span class="n">W</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>

        <span class="n">H</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="n">r</span><span class="p">,</span><span class="n">n</span><span class="p">)</span>
        <span class="n">H</span> <span class="o">/=</span> <span class="n">norm</span><span class="p">(</span><span class="n">H</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">W_init</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">RandomState</span><span class="p">):</span>
        <span class="n">rng</span> <span class="o">=</span> <span class="n">W_init</span>

        <span class="n">W</span> <span class="o">=</span> <span class="n">rng</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="n">p</span><span class="p">,</span><span class="n">r</span><span class="p">)</span>
        <span class="n">W</span> <span class="o">/=</span> <span class="n">norm</span><span class="p">(</span><span class="n">W</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>

        <span class="n">H</span> <span class="o">=</span> <span class="n">rng</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="n">r</span><span class="p">,</span><span class="n">n</span><span class="p">)</span>
        <span class="n">H</span> <span class="o">/=</span> <span class="n">norm</span><span class="p">(</span><span class="n">H</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">W_init</span> <span class="o">==</span> <span class="s1">&#39;nndsvd&#39;</span><span class="p">:</span>
<span class="c1">#        W = nnd_svd(X,r)</span>
        <span class="n">W</span><span class="p">,</span><span class="n">H</span> <span class="o">=</span> <span class="n">nnd_svd</span><span class="p">(</span><span class="n">X</span><span class="p">,</span><span class="n">r</span><span class="p">,</span><span class="n">get_H</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Invalid input for &quot;W_init&quot;&#39;</span><span class="p">)</span>

    <span class="n">P</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">r</span><span class="p">,</span><span class="n">p</span><span class="p">))</span>
<span class="c1">#    P = np.random.rand(r,p)</span>

    <span class="c1"># aux. variables</span>
    <span class="n">Wtil</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">W</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
    <span class="n">Ptil</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">P</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
    <span class="n">Htil</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">H</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="c1"># &lt;- for graph regularization</span>

    <span class="n">idx_i</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">r1</span><span class="p">)</span>       <span class="c1"># &lt;- intrinsic graph indices (top half of H matrices)</span>
    <span class="n">idx_p</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">r1</span><span class="p">,</span><span class="n">r1</span><span class="o">+</span><span class="n">r2</span><span class="p">)</span> <span class="c1"># &lt;- penalty   graph indices (bot half of H matrices)</span>
<span class="c1">#    Htil1 = np.zeros((r1,n)) # &lt;- the top half part of Htil (intrinsic part)</span>
<span class="c1">#    Htil2 = np.zeros((r2,n)) # &lt;- the bot half part of Htil (complementary part)</span>

    <span class="c1"># classifier</span>
    <span class="n">w</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">r1</span><span class="p">)</span>

    <span class="c1"># dual variables</span>
    <span class="n">Lam_W</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">W</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
    <span class="n">Lam_P</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">P</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
    <span class="n">Lam_H</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">H</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
    <span class="n">Lam_Htil</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">H</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="c1"># &lt;- for graph regularization</span>
    <span class="c1">#%%=== create empty lists for tracking updates ===</span>
    <span class="c1"># keep track of frobenius norm loss</span>
    <span class="n">cost_list</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">cost_nmf_list</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">cost_ls_list</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">cost_graph_list</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="n">cost_nmf</span> <span class="o">=</span> <span class="n">norm</span><span class="p">(</span><span class="n">Wtil</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">Ptil</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">X</span><span class="p">))</span> <span class="o">-</span> <span class="n">X</span><span class="p">,</span><span class="s1">&#39;fro&#39;</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="o">/</span><span class="mi">2</span>
    <span class="n">cost_ls</span>  <span class="o">=</span> <span class="n">gam</span><span class="o">*</span><span class="n">norm</span><span class="p">(</span><span class="n">y</span> <span class="o">-</span> <span class="n">H</span><span class="p">[</span><span class="n">idx_i</span><span class="p">]</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">w</span><span class="p">))</span> <span class="o">**</span><span class="mi">2</span><span class="o">/</span><span class="mi">2</span>
    <span class="n">_term1</span> <span class="o">=</span> <span class="n">trace</span><span class="p">(</span><span class="n">L1</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span> <span class="n">dot</span><span class="p">(</span><span class="n">Htil</span><span class="p">[</span><span class="n">idx_i</span><span class="p">]</span><span class="o">.</span><span class="n">T</span><span class="p">,</span><span class="n">Htil</span><span class="p">[</span><span class="n">idx_i</span><span class="p">])))</span>
    <span class="n">_term2</span> <span class="o">=</span> <span class="n">trace</span><span class="p">(</span><span class="n">L2</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span> <span class="n">dot</span><span class="p">(</span><span class="n">Htil</span><span class="p">[</span><span class="n">idx_p</span><span class="p">]</span><span class="o">.</span><span class="n">T</span><span class="p">,</span><span class="n">Htil</span><span class="p">[</span><span class="n">idx_p</span><span class="p">])))</span>
    <span class="n">cost_graph</span> <span class="o">=</span> <span class="p">(</span><span class="n">tau</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">_term1</span> <span class="o">+</span> <span class="n">_term2</span><span class="p">)</span>
    <span class="n">cost</span> <span class="o">=</span> <span class="n">cost_nmf</span> <span class="o">+</span> <span class="n">cost_graph</span> <span class="o">+</span> <span class="n">cost_ls</span>

    <span class="n">cost_nmf_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">cost_nmf</span><span class="p">)</span>
    <span class="n">cost_graph_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">cost_graph</span><span class="p">)</span>
    <span class="n">cost_ls_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">cost_ls</span><span class="p">)</span>
    <span class="n">cost_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">cost</span><span class="p">)</span>

    <span class="c1"># relative change in cost</span>
    <span class="n">diffcost</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="c1"># keep track of relative primal residual</span>
    <span class="n">res_W</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">res_P</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">res_H</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">res_Htil</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="c1"># also keep track of diffW</span>
<span class="c1">#    diffW = []</span>
    <span class="c1">#%%=== run admm iterations ===</span>
    <span class="n">eye_r</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="n">r</span><span class="p">)</span>
    <span class="n">eye_n</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>

    <span class="c1"># precompute term needed for inversion lemma</span>
    <span class="n">K</span> <span class="o">=</span> <span class="n">solve</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="o">+</span> <span class="n">dot</span><span class="p">(</span><span class="n">X</span><span class="o">.</span><span class="n">T</span><span class="p">,</span><span class="n">X</span><span class="p">),</span> <span class="n">X</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>

    <span class="n">start</span><span class="o">=</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
    <span class="k">for</span> <span class="nb">iter</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">max_iter</span><span class="p">):</span>
<span class="c1">#        W_old = W #&lt;- to keep track of diffW</span>

        <span class="c1">#================ primal updates (P, W, H, Ptil, Wtil) ===============#</span>
        <span class="c1"># update for P involves inversion lemma...</span>
        <span class="n">_R</span> <span class="o">=</span> <span class="n">dot</span><span class="p">(</span><span class="n">X</span><span class="p">,</span><span class="n">Lam_H</span><span class="o">.</span><span class="n">T</span><span class="p">)</span><span class="o">/</span><span class="n">rho</span> <span class="o">-</span> <span class="n">Lam_P</span><span class="o">.</span><span class="n">T</span><span class="o">/</span><span class="n">rho</span> <span class="o">+</span> <span class="n">dot</span><span class="p">(</span><span class="n">X</span><span class="p">,</span><span class="n">H</span><span class="o">.</span><span class="n">T</span><span class="p">)</span> <span class="o">+</span> <span class="n">Ptil</span><span class="o">.</span><span class="n">T</span>
        <span class="n">P</span> <span class="o">=</span> <span class="p">(</span><span class="n">_R</span> <span class="o">-</span> <span class="n">X</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span> <span class="n">dot</span><span class="p">(</span><span class="n">K</span><span class="p">,</span><span class="n">_R</span><span class="p">)</span> <span class="p">))</span><span class="o">.</span><span class="n">T</span>
        <span class="n">Ptil</span> <span class="o">=</span> <span class="p">(</span><span class="n">P</span><span class="o">+</span><span class="n">Lam_P</span><span class="o">/</span><span class="n">rho</span><span class="p">)</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>

        <span class="c1"># intrinsic H update</span>
        <span class="n">Wi</span> <span class="o">=</span> <span class="n">W</span><span class="p">[:,</span><span class="n">idx_i</span><span class="p">]</span>
        <span class="n">Wp</span> <span class="o">=</span> <span class="n">W</span><span class="p">[:,</span><span class="n">idx_p</span><span class="p">]</span>
        <span class="n">H</span><span class="p">[</span><span class="n">idx_i</span><span class="p">]</span> <span class="o">=</span> <span class="n">solve</span><span class="p">(</span><span class="n">dot</span><span class="p">(</span><span class="n">Wi</span><span class="o">.</span><span class="n">T</span><span class="p">,</span><span class="n">Wi</span><span class="p">)</span><span class="o">+</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">rho</span><span class="p">)</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="n">r1</span><span class="p">)</span> <span class="o">+</span> <span class="n">gam</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">outer</span><span class="p">(</span><span class="n">w</span><span class="p">,</span><span class="n">w</span><span class="p">),</span>
                  <span class="n">dot</span><span class="p">(</span><span class="n">Wi</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">X</span><span class="p">)</span> <span class="o">+</span> <span class="n">rho</span><span class="o">*</span><span class="n">dot</span><span class="p">(</span><span class="n">P</span><span class="p">[</span><span class="n">idx_i</span><span class="p">],</span><span class="n">X</span><span class="p">)</span> <span class="o">-</span> <span class="n">Lam_H</span><span class="p">[</span><span class="n">idx_i</span><span class="p">]</span> <span class="o">+</span>
                  <span class="n">rho</span><span class="o">*</span><span class="n">Htil</span><span class="p">[</span><span class="n">idx_i</span><span class="p">]</span> <span class="o">-</span> <span class="n">Lam_Htil</span><span class="p">[</span><span class="n">idx_i</span><span class="p">]</span> <span class="o">+</span> <span class="n">gam</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">outer</span><span class="p">(</span><span class="n">w</span><span class="p">,</span><span class="n">y</span><span class="p">)</span> <span class="p">)</span>
        <span class="n">H</span><span class="p">[</span><span class="n">idx_p</span><span class="p">]</span> <span class="o">=</span> <span class="n">solve</span><span class="p">(</span><span class="n">dot</span><span class="p">(</span><span class="n">Wp</span><span class="o">.</span><span class="n">T</span><span class="p">,</span><span class="n">Wp</span><span class="p">)</span><span class="o">+</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">rho</span><span class="p">)</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="n">r2</span><span class="p">),</span>
                  <span class="n">dot</span><span class="p">(</span><span class="n">Wp</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">X</span><span class="p">)</span> <span class="o">+</span> <span class="n">rho</span><span class="o">*</span><span class="n">dot</span><span class="p">(</span><span class="n">P</span><span class="p">[</span><span class="n">idx_p</span><span class="p">],</span><span class="n">X</span><span class="p">)</span> <span class="o">-</span> <span class="n">Lam_H</span><span class="p">[</span><span class="n">idx_p</span><span class="p">]</span> <span class="o">+</span>
                  <span class="n">rho</span><span class="o">*</span><span class="n">Htil</span><span class="p">[</span><span class="n">idx_p</span><span class="p">]</span> <span class="o">-</span> <span class="n">Lam_Htil</span><span class="p">[</span><span class="n">idx_p</span><span class="p">]</span> <span class="p">)</span>
        <span class="n">w</span> <span class="o">=</span> <span class="n">solve</span><span class="p">(</span> <span class="n">H</span><span class="p">[</span><span class="n">idx_i</span><span class="p">]</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">H</span><span class="p">[</span><span class="n">idx_i</span><span class="p">]</span><span class="o">.</span><span class="n">T</span><span class="p">),</span> <span class="n">H</span><span class="p">[</span><span class="n">idx_i</span><span class="p">]</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">y</span><span class="p">))</span>

        <span class="n">W</span> <span class="o">=</span> <span class="n">solve</span><span class="p">(</span><span class="n">dot</span><span class="p">(</span><span class="n">H</span><span class="p">,</span><span class="n">H</span><span class="o">.</span><span class="n">T</span><span class="p">)</span><span class="o">+</span><span class="n">rho</span><span class="o">*</span><span class="n">eye_r</span><span class="p">,</span> <span class="n">dot</span><span class="p">(</span><span class="n">H</span><span class="p">,</span> <span class="n">X</span><span class="o">.</span><span class="n">T</span><span class="p">)</span> <span class="o">+</span> <span class="n">rho</span><span class="o">*</span><span class="n">Wtil</span><span class="o">.</span><span class="n">T</span> <span class="o">-</span> <span class="n">Lam_W</span><span class="o">.</span><span class="n">T</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>
        <span class="n">Wtil</span> <span class="o">=</span> <span class="p">(</span><span class="n">W</span><span class="o">+</span><span class="n">Lam_W</span><span class="o">/</span><span class="n">rho</span><span class="p">)</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>

        <span class="c1"># --- Htil updates...broken down to two part: Htil1 and Htil2 ---</span>
        <span class="c1"># intrinsic graph update (top half of Htil matrix)</span>
        <span class="n">Htil</span><span class="p">[</span><span class="n">idx_i</span><span class="p">]</span> <span class="o">=</span> <span class="n">solve</span><span class="p">(</span><span class="n">tau</span><span class="o">*</span><span class="n">L1</span> <span class="o">+</span> <span class="n">rho</span><span class="o">*</span><span class="n">eye_n</span><span class="p">,</span> <span class="n">rho</span><span class="o">*</span><span class="n">H</span><span class="p">[</span><span class="n">idx_i</span><span class="p">]</span><span class="o">.</span><span class="n">T</span><span class="o">+</span><span class="n">Lam_Htil</span><span class="p">[</span><span class="n">idx_i</span><span class="p">]</span><span class="o">.</span><span class="n">T</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>

        <span class="c1"># penalty graph update (bottom half of Htil matrix)</span>
        <span class="n">Htil</span><span class="p">[</span><span class="n">idx_p</span><span class="p">]</span> <span class="o">=</span> <span class="n">solve</span><span class="p">(</span><span class="n">tau</span><span class="o">*</span><span class="n">L2</span> <span class="o">+</span> <span class="n">rho</span><span class="o">*</span><span class="n">eye_n</span><span class="p">,</span> <span class="n">rho</span><span class="o">*</span><span class="n">H</span><span class="p">[</span><span class="n">idx_p</span><span class="p">]</span><span class="o">.</span><span class="n">T</span><span class="o">+</span><span class="n">Lam_Htil</span><span class="p">[</span><span class="n">idx_p</span><span class="p">]</span><span class="o">.</span><span class="n">T</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>

        <span class="c1">#====================== dual updates =================================#</span>
        <span class="n">Lam_W</span> <span class="o">=</span> <span class="n">Lam_W</span> <span class="o">+</span> <span class="n">rho</span><span class="o">*</span><span class="p">(</span><span class="n">W</span> <span class="o">-</span> <span class="n">Wtil</span><span class="p">)</span>
        <span class="n">Lam_P</span> <span class="o">=</span> <span class="n">Lam_P</span> <span class="o">+</span> <span class="n">rho</span><span class="o">*</span><span class="p">(</span><span class="n">P</span> <span class="o">-</span> <span class="n">Ptil</span><span class="p">)</span>
        <span class="n">Lam_H</span> <span class="o">=</span> <span class="n">Lam_H</span> <span class="o">+</span> <span class="n">rho</span><span class="o">*</span><span class="p">(</span><span class="n">H</span> <span class="o">-</span> <span class="n">dot</span><span class="p">(</span><span class="n">P</span><span class="p">,</span><span class="n">X</span><span class="p">))</span>
        <span class="n">Lam_Htil</span> <span class="o">=</span> <span class="n">Lam_Htil</span> <span class="o">+</span> <span class="n">rho</span><span class="o">*</span><span class="p">(</span><span class="n">H</span><span class="o">-</span><span class="n">Htil</span><span class="p">)</span>

        <span class="c1">#============ comptute objective values ==============================#</span>
        <span class="c1"># main loss function</span>
        <span class="n">cost_nmf</span> <span class="o">=</span> <span class="n">norm</span><span class="p">(</span><span class="n">Wtil</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">Ptil</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">X</span><span class="p">))</span> <span class="o">-</span> <span class="n">X</span><span class="p">,</span><span class="s1">&#39;fro&#39;</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="o">/</span><span class="mi">2</span>
        <span class="n">cost_ls</span>  <span class="o">=</span> <span class="n">gam</span><span class="o">*</span><span class="n">norm</span><span class="p">(</span><span class="n">y</span> <span class="o">-</span> <span class="n">H</span><span class="p">[</span><span class="n">idx_i</span><span class="p">]</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">w</span><span class="p">))</span> <span class="o">**</span><span class="mi">2</span><span class="o">/</span><span class="mi">2</span>
        <span class="n">_term1</span> <span class="o">=</span> <span class="n">trace</span><span class="p">(</span><span class="n">L1</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span> <span class="n">dot</span><span class="p">(</span><span class="n">Htil</span><span class="p">[</span><span class="n">idx_i</span><span class="p">]</span><span class="o">.</span><span class="n">T</span><span class="p">,</span><span class="n">Htil</span><span class="p">[</span><span class="n">idx_i</span><span class="p">])))</span>
        <span class="n">_term2</span> <span class="o">=</span> <span class="n">trace</span><span class="p">(</span><span class="n">L2</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span> <span class="n">dot</span><span class="p">(</span><span class="n">Htil</span><span class="p">[</span><span class="n">idx_p</span><span class="p">]</span><span class="o">.</span><span class="n">T</span><span class="p">,</span><span class="n">Htil</span><span class="p">[</span><span class="n">idx_p</span><span class="p">])))</span>
        <span class="n">cost_graph</span> <span class="o">=</span> <span class="p">(</span><span class="n">tau</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">_term1</span> <span class="o">+</span> <span class="n">_term2</span><span class="p">)</span>
        <span class="n">cost</span> <span class="o">=</span> <span class="n">cost_nmf</span> <span class="o">+</span> <span class="n">cost_graph</span> <span class="o">+</span> <span class="n">cost_ls</span>

        <span class="n">cost_nmf_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">cost_nmf</span><span class="p">)</span>
        <span class="n">cost_graph_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">cost_graph</span><span class="p">)</span>
        <span class="n">cost_ls_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">cost_ls</span><span class="p">)</span>
        <span class="n">cost_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">cost</span><span class="p">)</span>

        <span class="c1"># relative change in cost</span>
        <span class="n">diffcost</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">cost_list</span><span class="p">[</span><span class="nb">iter</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">cost_list</span><span class="p">[</span><span class="nb">iter</span><span class="p">])</span><span class="o">/</span><span class="n">cost_list</span><span class="p">[</span><span class="nb">iter</span><span class="p">])</span>

        <span class="c1"># relative primal residuals</span>
        <span class="n">res_W</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">norm</span><span class="p">(</span><span class="n">W</span><span class="o">-</span><span class="n">Wtil</span><span class="p">,</span><span class="s1">&#39;fro&#39;</span><span class="p">)</span><span class="o">/</span><span class="n">norm</span><span class="p">(</span><span class="n">W</span><span class="p">,</span><span class="s1">&#39;fro&#39;</span><span class="p">))</span>
        <span class="n">res_P</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">norm</span><span class="p">(</span><span class="n">P</span><span class="o">-</span><span class="n">Ptil</span><span class="p">,</span><span class="s1">&#39;fro&#39;</span><span class="p">)</span><span class="o">/</span><span class="n">norm</span><span class="p">(</span><span class="n">P</span><span class="p">,</span><span class="s1">&#39;fro&#39;</span><span class="p">))</span>
        <span class="n">res_H</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">norm</span><span class="p">(</span><span class="n">H</span><span class="o">-</span><span class="n">P</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">X</span><span class="p">),</span><span class="s1">&#39;fro&#39;</span><span class="p">)</span><span class="o">/</span><span class="n">norm</span><span class="p">(</span><span class="n">H</span><span class="p">,</span><span class="s1">&#39;fro&#39;</span><span class="p">))</span>
        <span class="n">res_Htil</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">norm</span><span class="p">(</span><span class="n">H</span><span class="o">-</span><span class="n">Htil</span><span class="p">,</span><span class="s1">&#39;fro&#39;</span><span class="p">)</span><span class="o">/</span><span class="n">norm</span><span class="p">(</span><span class="n">H</span><span class="p">,</span><span class="s1">&#39;fro&#39;</span><span class="p">))</span>

        <span class="c1"># relative change in basis matrix</span>
<span class="c1">#        diffW.append( norm(W-W_old,&#39;fro&#39;)/ norm(W_old, &#39;fro&#39;) )</span>

        <span class="c1">#=== termination check ====#</span>
        <span class="n">check_exit</span>  <span class="o">=</span> <span class="p">(</span><span class="n">diffcost</span><span class="p">[</span><span class="nb">iter</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">tol</span><span class="p">)</span>
        <span class="n">check_exit</span> <span class="o">&amp;=</span> <span class="p">(</span><span class="n">res_W</span><span class="p">[</span><span class="nb">iter</span><span class="p">]</span> <span class="o">&lt;</span>  <span class="n">tol</span><span class="p">)</span>
        <span class="n">check_exit</span> <span class="o">&amp;=</span> <span class="p">(</span><span class="n">res_P</span><span class="p">[</span><span class="nb">iter</span><span class="p">]</span> <span class="o">&lt;</span>  <span class="n">tol</span><span class="p">)</span>
        <span class="n">check_exit</span> <span class="o">&amp;=</span> <span class="p">(</span><span class="n">res_H</span><span class="p">[</span><span class="nb">iter</span><span class="p">]</span> <span class="o">&lt;</span>  <span class="n">tol</span><span class="p">)</span>
        <span class="n">check_exit</span> <span class="o">&amp;=</span> <span class="p">(</span><span class="n">res_Htil</span><span class="p">[</span><span class="nb">iter</span><span class="p">]</span> <span class="o">&lt;</span>  <span class="n">tol</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">check_exit</span> <span class="ow">and</span> <span class="nb">iter</span> <span class="o">&gt;</span> <span class="mi">300</span><span class="p">:</span> <span class="c1"># allow 300 iterations of &quot;burn-in&quot;</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">silence</span><span class="p">:</span>
                <span class="k">print</span> <span class="s2">&quot;Termination condition met.  Exit at iter =&quot;</span><span class="p">,</span><span class="nb">iter</span><span class="p">,</span>
            <span class="k">break</span>
        <span class="c1">#=============== print current progress ==============================#</span>
<span class="c1">#        if iter % disp_freq == 0:</span>
        <span class="k">if</span> <span class="p">(</span><span class="nb">iter</span><span class="o">&gt;</span><span class="mi">1</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="nb">iter</span> <span class="o">%</span> <span class="n">disp_freq</span> <span class="o">==</span> <span class="mi">0</span><span class="p">):</span>
<span class="c1">#            str_ = &quot;iter={:4} cost={:3.3f}&quot;.format(iter,cost_list[iter+1])</span>
            <span class="n">str_</span> <span class="o">=</span> <span class="s2">&quot;iter={:4} cost={:6.5e}&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">iter</span><span class="p">,</span><span class="n">cost</span><span class="p">)</span>
            <span class="n">str_</span> <span class="o">+=</span> <span class="s2">&quot; nmf={:3.2e}&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">cost_nmf</span><span class="p">)</span>
            <span class="n">str_</span> <span class="o">+=</span> <span class="s2">&quot; graph={:3.2e}&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">cost_graph</span><span class="p">)</span>
            <span class="n">str_</span> <span class="o">+=</span> <span class="s2">&quot; ls={:3.2e}&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">cost_ls</span><span class="p">)</span>
            <span class="n">str_</span> <span class="o">+=</span> <span class="s2">&quot; diffcost={:3.2e}&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">diffcost</span><span class="p">[</span><span class="nb">iter</span><span class="p">])</span>
            <span class="n">str_</span> <span class="o">+=</span> <span class="s2">&quot; W={:3.2e}&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">res_W</span><span class="p">[</span><span class="nb">iter</span><span class="p">])</span>
            <span class="n">str_</span> <span class="o">+=</span> <span class="s2">&quot; P={:3.2e}&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">res_P</span><span class="p">[</span><span class="nb">iter</span><span class="p">])</span>
            <span class="n">str_</span> <span class="o">+=</span> <span class="s2">&quot; H={:3.2e}&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">res_H</span><span class="p">[</span><span class="nb">iter</span><span class="p">])</span>
            <span class="n">str_</span> <span class="o">+=</span> <span class="s2">&quot; Htil={:3.2e}&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">res_Htil</span><span class="p">[</span><span class="nb">iter</span><span class="p">])</span>
<span class="c1">#            str_ += &quot; diffW={:3.2e}&quot;.format(diffW[iter])</span>
            <span class="k">print</span> <span class="n">str_</span> <span class="o">+</span> <span class="s2">&quot; ({:3.1f} sec)&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span><span class="o">-</span><span class="n">start</span><span class="p">)</span>
    <span class="c1">#%%---- end of admm for loop ---------------------------------------------#</span>
    <span class="n">cost_list</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">cost_list</span><span class="p">)</span>

    <span class="c1"># convert to pandas dataframe</span>
    <span class="n">cost</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">([</span><span class="n">cost_list</span><span class="p">,</span> <span class="n">cost_nmf_list</span><span class="p">,</span> <span class="n">cost_graph_list</span><span class="p">,</span><span class="n">cost_ls_list</span><span class="p">],</span>
                        <span class="n">index</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;total&#39;</span><span class="p">,</span><span class="s1">&#39;nmf&#39;</span><span class="p">,</span><span class="s1">&#39;graph&#39;</span><span class="p">,</span><span class="s1">&#39;ls&#39;</span><span class="p">])</span><span class="o">.</span><span class="n">T</span>

    <span class="n">res</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">([</span><span class="n">res_W</span><span class="p">,</span><span class="n">res_P</span><span class="p">,</span><span class="n">res_H</span><span class="p">,</span><span class="n">diffcost</span><span class="p">],</span>
                       <span class="n">index</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;res_W&#39;</span><span class="p">,</span><span class="s1">&#39;res_P&#39;</span><span class="p">,</span><span class="s1">&#39;res_H&#39;</span><span class="p">,</span><span class="s1">&#39;diffcost&#39;</span><span class="p">])</span><span class="o">.</span><span class="n">T</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">silence</span><span class="p">:</span> <span class="n">print_time</span><span class="p">(</span><span class="n">start</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">W</span><span class="p">,</span><span class="n">P</span><span class="p">,</span><span class="n">H</span><span class="p">,</span><span class="n">w</span><span class="p">,</span><span class="n">Wtil</span><span class="p">,</span><span class="n">Ptil</span><span class="p">,</span><span class="n">cost</span><span class="p">,</span><span class="n">res</span>
<span class="c1">#%% === class ====</span>
<span class="k">class</span> <span class="nc">PNMF_ADMM</span><span class="p">(</span><span class="n">BaseEstimator</span><span class="p">,</span><span class="n">TransformerMixin</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">r</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span><span class="n">rho</span><span class="o">=</span><span class="mf">5e2</span><span class="p">,</span><span class="n">W_init</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span><span class="n">max_iter</span><span class="o">=</span><span class="mi">5000</span><span class="p">,</span><span class="n">tol</span><span class="o">=</span><span class="mf">1e-4</span><span class="p">,</span>
                 <span class="n">disp_freq</span><span class="o">=</span><span class="mi">50000</span><span class="p">,</span><span class="n">silence</span><span class="o">=</span><span class="bp">True</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">r</span> <span class="o">=</span> <span class="n">r</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">rho</span> <span class="o">=</span> <span class="n">rho</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">W_init</span> <span class="o">=</span> <span class="n">W_init</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">max_iter</span> <span class="o">=</span> <span class="n">max_iter</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tol</span> <span class="o">=</span> <span class="n">tol</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">disp_freq</span> <span class="o">=</span> <span class="n">disp_freq</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">silence</span> <span class="o">=</span> <span class="n">silence</span>

    <span class="k">def</span> <span class="nf">fit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">X</span><span class="p">,</span><span class="n">y</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;WARNING: Here, to conform with scikit&#39;s convention, X is [n,p] shaped&quot;&quot;&quot;</span>
        <span class="n">W</span><span class="p">,</span><span class="n">P</span><span class="p">,</span><span class="n">H</span><span class="p">,</span><span class="n">Wtil</span><span class="p">,</span><span class="n">Ptil</span><span class="p">,</span><span class="n">cost_list</span><span class="p">,</span><span class="n">res</span> <span class="o">=</span> <span class="n">pnmf_admm</span><span class="p">(</span><span class="n">X</span><span class="o">.</span><span class="n">T</span><span class="p">,</span><span class="n">r</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">r</span><span class="p">,</span> <span class="n">rho</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">rho</span><span class="p">,</span>
            <span class="n">W_init</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">W_init</span><span class="p">,</span> <span class="n">max_iter</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">max_iter</span><span class="p">,</span> <span class="n">tol</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">tol</span><span class="p">,</span>
            <span class="n">disp_freq</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">disp_freq</span><span class="p">,</span> <span class="n">silence</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">silence</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">W_</span> <span class="o">=</span> <span class="n">Wtil</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">P_</span> <span class="o">=</span> <span class="n">Ptil</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">H_</span> <span class="o">=</span> <span class="n">H</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cost_</span> <span class="o">=</span> <span class="n">cost_list</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">resid_</span> <span class="o">=</span> <span class="n">res</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="nf">transform</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">X</span><span class="p">,</span><span class="n">y</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;WARNING: Here, to conform with scikit&#39;s convention, X is [n,p] shaped&quot;&quot;&quot;</span>
        <span class="n">check_is_fitted</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="s1">&#39;P_&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">P_</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>


<span class="k">class</span> <span class="nc">SPNMF_ADMM</span><span class="p">(</span><span class="n">BaseEstimator</span><span class="p">,</span><span class="n">TransformerMixin</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">r</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span><span class="n">rho</span><span class="o">=</span><span class="mf">5e2</span><span class="p">,</span><span class="n">constraint</span><span class="o">=</span><span class="s1">&#39;stiefel&#39;</span><span class="p">,</span><span class="n">W_init</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span>
                 <span class="n">max_iter</span><span class="o">=</span><span class="mi">5000</span><span class="p">,</span><span class="n">tol</span><span class="o">=</span><span class="mf">1e-4</span><span class="p">,</span><span class="n">disp_freq</span><span class="o">=</span><span class="mi">50000</span><span class="p">,</span><span class="n">silence</span><span class="o">=</span><span class="bp">True</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">r</span> <span class="o">=</span> <span class="n">r</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">rho</span> <span class="o">=</span> <span class="n">rho</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">constraint</span> <span class="o">=</span> <span class="n">constraint</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">W_init</span> <span class="o">=</span> <span class="n">W_init</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">max_iter</span> <span class="o">=</span> <span class="n">max_iter</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tol</span> <span class="o">=</span> <span class="n">tol</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">disp_freq</span> <span class="o">=</span> <span class="n">disp_freq</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">silence</span> <span class="o">=</span> <span class="n">silence</span>

    <span class="k">def</span> <span class="nf">fit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">X</span><span class="p">,</span><span class="n">y</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;WARNING: Here, to conform with scikit&#39;s convention, X is [n,p]</span>
<span class="sd">        shaped, so need to apply transpose before inputting to function&quot;&quot;&quot;</span>
        <span class="n">W</span><span class="p">,</span><span class="n">P</span><span class="p">,</span><span class="n">H</span><span class="p">,</span><span class="n">W1</span><span class="p">,</span><span class="n">Ptil</span><span class="p">,</span><span class="n">cost_list</span><span class="p">,</span><span class="n">res</span> <span class="o">=</span> <span class="n">spnmf_admm</span><span class="p">(</span><span class="n">X</span><span class="o">.</span><span class="n">T</span><span class="p">,</span><span class="n">r</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">r</span><span class="p">,</span>
            <span class="n">constraint</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">constraint</span><span class="p">,</span> <span class="n">rho</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">rho</span><span class="p">,</span> <span class="n">max_iter</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">max_iter</span><span class="p">,</span>
            <span class="n">tol</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">tol</span><span class="p">,</span> <span class="n">W_init</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">W_init</span><span class="p">,</span> <span class="n">disp_freq</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">disp_freq</span><span class="p">,</span>
            <span class="n">silence</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">silence</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">W_</span> <span class="o">=</span> <span class="n">W1</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">P_</span> <span class="o">=</span> <span class="n">Ptil</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">H_</span> <span class="o">=</span> <span class="n">H</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cost_</span> <span class="o">=</span> <span class="n">cost_list</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">resid_</span> <span class="o">=</span> <span class="n">res</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="nf">transform</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">X</span><span class="p">,</span><span class="n">y</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;WARNING: Here, to conform with scikit&#39;s convention, X is [n,p] shaped&quot;&quot;&quot;</span>
        <span class="n">check_is_fitted</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="s1">&#39;P_&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">P_</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>


<span class="k">class</span> <span class="nc">PNGE_ADMM</span><span class="p">(</span><span class="n">BaseEstimator</span><span class="p">,</span><span class="n">TransformerMixin</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">knn_i</span><span class="p">,</span><span class="n">knn_p</span><span class="p">,</span><span class="n">r1</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span><span class="n">r2</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span><span class="n">rho</span><span class="o">=</span><span class="mf">5e2</span><span class="p">,</span><span class="n">tau</span><span class="o">=</span><span class="mf">1e-1</span><span class="p">,</span><span class="n">W_init</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span>
                 <span class="n">max_iter</span><span class="o">=</span><span class="mi">5000</span><span class="p">,</span><span class="n">tol</span><span class="o">=</span><span class="mf">1e-4</span><span class="p">,</span><span class="n">disp_freq</span><span class="o">=</span><span class="mi">50000</span><span class="p">,</span><span class="n">silence</span><span class="o">=</span><span class="bp">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        knn_i = # within-class kNN neighbors</span>
<span class="sd">        knn_p = # betwen-class kNN neighbors</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">r1</span> <span class="o">=</span> <span class="n">r1</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">r2</span> <span class="o">=</span> <span class="n">r2</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">knn_i</span> <span class="o">=</span> <span class="n">knn_i</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">knn_p</span> <span class="o">=</span> <span class="n">knn_p</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">r</span>  <span class="o">=</span> <span class="n">r1</span><span class="o">+</span><span class="n">r2</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tau</span> <span class="o">=</span> <span class="n">tau</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">rho</span> <span class="o">=</span> <span class="n">rho</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">W_init</span> <span class="o">=</span> <span class="n">W_init</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">max_iter</span> <span class="o">=</span> <span class="n">max_iter</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tol</span> <span class="o">=</span> <span class="n">tol</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">disp_freq</span> <span class="o">=</span> <span class="n">disp_freq</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">silence</span> <span class="o">=</span> <span class="n">silence</span>

    <span class="k">def</span> <span class="nf">fit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">X</span><span class="p">,</span><span class="n">y</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;WARNING: Here, to conform with scikit&#39;s convention, X is [n,p]</span>
<span class="sd">        shaped, so need to apply transpose before inputting to function&quot;&quot;&quot;</span>
        <span class="c1"># construct intrinsic and penalty graph</span>
        <span class="n">Li</span> <span class="o">=</span> <span class="n">get_knn_within_class</span><span class="p">(</span> <span class="n">X</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">n_neighbors</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">knn_i</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">Lp</span> <span class="o">=</span> <span class="n">get_knn_between_class</span><span class="p">(</span><span class="n">X</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">n_neighbors</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">knn_p</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span>

        <span class="n">W</span><span class="p">,</span><span class="n">P</span><span class="p">,</span><span class="n">H</span><span class="p">,</span><span class="n">Wtil</span><span class="p">,</span><span class="n">Ptil</span><span class="p">,</span><span class="n">cost</span><span class="p">,</span><span class="n">res</span> <span class="o">=</span> <span class="n">pnge_admm</span><span class="p">(</span><span class="n">X</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">r1</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">r1</span><span class="p">,</span><span class="n">r2</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">r2</span><span class="p">,</span>
            <span class="n">L1</span><span class="o">=</span><span class="n">Li</span><span class="p">,</span><span class="n">L2</span><span class="o">=</span><span class="n">Lp</span><span class="p">,</span> <span class="n">tau</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">tau</span><span class="p">,</span> <span class="n">rho</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">rho</span><span class="p">,</span> <span class="n">max_iter</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">max_iter</span><span class="p">,</span>
            <span class="n">tol</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">tol</span><span class="p">,</span> <span class="n">W_init</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">W_init</span><span class="p">,</span> <span class="n">disp_freq</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">disp_freq</span><span class="p">,</span>
            <span class="n">silence</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">silence</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">W_</span> <span class="o">=</span> <span class="n">Wtil</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">P_</span> <span class="o">=</span> <span class="n">Ptil</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">H_</span> <span class="o">=</span> <span class="n">H</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cost_</span> <span class="o">=</span> <span class="n">cost</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">resid_</span> <span class="o">=</span> <span class="n">res</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="nf">transform</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">X</span><span class="p">,</span><span class="n">y</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;WARNING: Here, to conform with scikit&#39;s convention, X is [n,p] shaped&quot;&quot;&quot;</span>
        <span class="n">check_is_fitted</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="s1">&#39;P_&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">P_</span><span class="p">[:</span><span class="bp">self</span><span class="o">.</span><span class="n">r1</span><span class="p">]</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>

<span class="k">class</span> <span class="nc">LS_PNGE_ADMM</span><span class="p">(</span><span class="n">BaseEstimator</span><span class="p">,</span><span class="n">TransformerMixin</span><span class="p">,</span><span class="n">ClassifierMixin</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">knn_i</span><span class="p">,</span><span class="n">knn_p</span><span class="p">,</span><span class="n">r1</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span><span class="n">r2</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span><span class="n">rho</span><span class="o">=</span><span class="mf">5e2</span><span class="p">,</span><span class="n">tau</span><span class="o">=</span><span class="mf">1e-1</span><span class="p">,</span><span class="n">gam</span><span class="o">=</span><span class="mf">1e-1</span><span class="p">,</span><span class="n">W_init</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span>
                 <span class="n">max_iter</span><span class="o">=</span><span class="mi">5000</span><span class="p">,</span><span class="n">tol</span><span class="o">=</span><span class="mf">1e-4</span><span class="p">,</span><span class="n">disp_freq</span><span class="o">=</span><span class="mi">50000</span><span class="p">,</span><span class="n">silence</span><span class="o">=</span><span class="bp">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        knn_i = # within-class kNN neighbors</span>
<span class="sd">        knn_p = # betwen-class kNN neighbors</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">r1</span> <span class="o">=</span> <span class="n">r1</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">r2</span> <span class="o">=</span> <span class="n">r2</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">knn_i</span> <span class="o">=</span> <span class="n">knn_i</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">knn_p</span> <span class="o">=</span> <span class="n">knn_p</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">r</span>  <span class="o">=</span> <span class="n">r1</span><span class="o">+</span><span class="n">r2</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tau</span> <span class="o">=</span> <span class="n">tau</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">gam</span> <span class="o">=</span> <span class="n">gam</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">rho</span> <span class="o">=</span> <span class="n">rho</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">W_init</span> <span class="o">=</span> <span class="n">W_init</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">max_iter</span> <span class="o">=</span> <span class="n">max_iter</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tol</span> <span class="o">=</span> <span class="n">tol</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">disp_freq</span> <span class="o">=</span> <span class="n">disp_freq</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">silence</span> <span class="o">=</span> <span class="n">silence</span>

    <span class="k">def</span> <span class="nf">fit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">X</span><span class="p">,</span><span class="n">y</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;WARNING: Here, to conform with scikit&#39;s convention, X is [n,p]</span>
<span class="sd">        shaped, so need to apply transpose before inputting to function&quot;&quot;&quot;</span>
        <span class="c1"># construct intrinsic and penalty graph</span>
        <span class="n">Li</span> <span class="o">=</span> <span class="n">get_knn_within_class</span><span class="p">(</span> <span class="n">X</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">n_neighbors</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">knn_i</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">Lp</span> <span class="o">=</span> <span class="n">get_knn_between_class</span><span class="p">(</span><span class="n">X</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">n_neighbors</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">knn_p</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span>

        <span class="n">W</span><span class="p">,</span><span class="n">P</span><span class="p">,</span><span class="n">H</span><span class="p">,</span><span class="n">w</span><span class="p">,</span><span class="n">Wtil</span><span class="p">,</span><span class="n">Ptil</span><span class="p">,</span><span class="n">cost</span><span class="p">,</span><span class="n">res</span> <span class="o">=</span> <span class="n">ls_pnge_admm</span><span class="p">(</span><span class="n">X</span><span class="o">.</span><span class="n">T</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">r1</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">r1</span><span class="p">,</span><span class="n">r2</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">r2</span><span class="p">,</span>
            <span class="n">L1</span><span class="o">=</span><span class="n">Li</span><span class="p">,</span><span class="n">L2</span><span class="o">=</span><span class="n">Lp</span><span class="p">,</span> <span class="n">tau</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">tau</span><span class="p">,</span> <span class="n">gam</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">gam</span><span class="p">,</span>
            <span class="n">rho</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">rho</span><span class="p">,</span> <span class="n">max_iter</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">max_iter</span><span class="p">,</span>
            <span class="n">tol</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">tol</span><span class="p">,</span> <span class="n">W_init</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">W_init</span><span class="p">,</span> <span class="n">disp_freq</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">disp_freq</span><span class="p">,</span>
            <span class="n">silence</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">silence</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">W_</span> <span class="o">=</span> <span class="n">Wtil</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">P_</span> <span class="o">=</span> <span class="n">Ptil</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">H_</span> <span class="o">=</span> <span class="n">H</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">w_</span> <span class="o">=</span> <span class="n">w</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cost_</span> <span class="o">=</span> <span class="n">cost</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">resid_</span> <span class="o">=</span> <span class="n">res</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="nf">transform</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">X</span><span class="p">,</span><span class="n">y</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;WARNING: Here, to conform with scikit&#39;s convention, X is [n,p] shaped&quot;&quot;&quot;</span>
        <span class="n">check_is_fitted</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="s1">&#39;P_&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">P_</span><span class="p">[:</span><span class="bp">self</span><span class="o">.</span><span class="n">r1</span><span class="p">]</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">decision_function</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">X</span><span class="p">):</span>
        <span class="n">check_is_fitted</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="s1">&#39;P_&#39;</span><span class="p">)</span>

        <span class="n">H</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>

        <span class="c1"># apply classifier</span>
        <span class="n">score</span> <span class="o">=</span> <span class="n">H</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">w_</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">score</span>

    <span class="k">def</span> <span class="nf">predict</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">X</span><span class="p">):</span>
        <span class="n">check_is_fitted</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="s1">&#39;P_&#39;</span><span class="p">)</span>

        <span class="c1"># project data to low dimensional space</span>
        <span class="n">H</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>

        <span class="c1"># apply classifier</span>
        <span class="n">score</span> <span class="o">=</span> <span class="n">H</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">w_</span><span class="p">)</span>
        <span class="n">ypr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sign</span><span class="p">(</span><span class="n">score</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">ypr</span>


<span class="k">class</span> <span class="nc">LS_SPNMF_ADMM</span><span class="p">(</span><span class="n">BaseEstimator</span><span class="p">,</span><span class="n">ClassifierMixin</span><span class="p">,</span><span class="n">TransformerMixin</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">gam</span><span class="o">=</span><span class="mf">1e-1</span><span class="p">,</span><span class="n">gam2</span><span class="o">=</span><span class="mf">0.</span><span class="p">,</span><span class="n">r</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span><span class="n">rho</span><span class="o">=</span><span class="mf">5e2</span><span class="p">,</span><span class="n">constraint</span><span class="o">=</span><span class="s1">&#39;stiefel&#39;</span><span class="p">,</span><span class="n">W_init</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span>
                 <span class="n">max_iter</span><span class="o">=</span><span class="mi">5000</span><span class="p">,</span><span class="n">tol</span><span class="o">=</span><span class="mf">1e-4</span><span class="p">,</span><span class="n">disp_freq</span><span class="o">=</span><span class="mi">50000</span><span class="p">,</span><span class="n">silence</span><span class="o">=</span><span class="bp">True</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">r</span> <span class="o">=</span> <span class="n">r</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">gam</span> <span class="o">=</span> <span class="n">gam</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">gam2</span> <span class="o">=</span> <span class="n">gam2</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">rho</span> <span class="o">=</span> <span class="n">rho</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">constraint</span> <span class="o">=</span> <span class="n">constraint</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">W_init</span> <span class="o">=</span> <span class="n">W_init</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">max_iter</span> <span class="o">=</span> <span class="n">max_iter</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tol</span> <span class="o">=</span> <span class="n">tol</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">disp_freq</span> <span class="o">=</span> <span class="n">disp_freq</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">silence</span> <span class="o">=</span> <span class="n">silence</span>

    <span class="k">def</span> <span class="nf">fit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">X</span><span class="p">,</span><span class="n">y</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;WARNING: Here, to conform with scikit&#39;s convention, X is [n,p]</span>
<span class="sd">        shaped, so need to apply transpose before inputting to function&quot;&quot;&quot;</span>
        <span class="n">W</span><span class="p">,</span><span class="n">P</span><span class="p">,</span><span class="n">H</span><span class="p">,</span><span class="n">w</span><span class="p">,</span><span class="n">Wtil</span><span class="p">,</span><span class="n">Ptil</span><span class="p">,</span><span class="n">cost</span><span class="p">,</span><span class="n">res</span> <span class="o">=</span> <span class="n">ls_spnmf_admm</span><span class="p">(</span><span class="n">X</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">r</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">r</span><span class="p">,</span>
            <span class="n">gam</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">gam</span><span class="p">,</span> <span class="n">gam2</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">gam2</span><span class="p">,</span>
            <span class="n">constraint</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">constraint</span><span class="p">,</span> <span class="n">rho</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">rho</span><span class="p">,</span> <span class="n">max_iter</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">max_iter</span><span class="p">,</span>
            <span class="n">tol</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">tol</span><span class="p">,</span> <span class="n">W_init</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">W_init</span><span class="p">,</span> <span class="n">disp_freq</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">disp_freq</span><span class="p">,</span>
            <span class="n">silence</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">silence</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">W_</span> <span class="o">=</span> <span class="n">Wtil</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">w_</span> <span class="o">=</span> <span class="n">w</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">P_</span> <span class="o">=</span> <span class="n">Ptil</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">H_</span> <span class="o">=</span> <span class="n">H</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cost_</span> <span class="o">=</span> <span class="n">cost</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">resid_</span> <span class="o">=</span> <span class="n">res</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="nf">transform</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">X</span><span class="p">,</span><span class="n">y</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;WARNING: Here, to conform with scikit&#39;s convention, X is [n,p] shaped&quot;&quot;&quot;</span>
        <span class="n">check_is_fitted</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="s1">&#39;P_&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">P_</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">decision_function</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">X</span><span class="p">):</span>
        <span class="n">check_is_fitted</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="s1">&#39;P_&#39;</span><span class="p">)</span>
        <span class="c1"># project data to low dimensional space</span>
        <span class="n">H</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">P_</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>

        <span class="c1"># apply classifier</span>
        <span class="n">score</span> <span class="o">=</span> <span class="n">H</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">w_</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">score</span>

    <span class="k">def</span> <span class="nf">predict</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">X</span><span class="p">):</span>
        <span class="n">check_is_fitted</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="s1">&#39;P_&#39;</span><span class="p">)</span>

        <span class="c1"># project data to low dimensional space</span>
        <span class="n">H</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">P_</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>

        <span class="c1"># apply classifier</span>
        <span class="n">score</span> <span class="o">=</span> <span class="n">H</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">w_</span><span class="p">)</span>
        <span class="n">ypr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sign</span><span class="p">(</span><span class="n">score</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">ypr</span>


<div class="viewcode-block" id="LS_SGPNMF_ADMM"><a class="viewcode-back" href="../../../test_autodoc.html#tak.ml.LS_SGPNMF_ADMM">[docs]</a><span class="k">class</span> <span class="nc">LS_SGPNMF_ADMM</span><span class="p">(</span><span class="n">BaseEstimator</span><span class="p">,</span><span class="n">ClassifierMixin</span><span class="p">,</span><span class="n">TransformerMixin</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Created 02/04/2016&quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">r</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span><span class="n">tau</span><span class="o">=</span><span class="mf">1e-1</span><span class="p">,</span><span class="n">gam</span><span class="o">=</span><span class="mf">1e-1</span><span class="p">,</span><span class="n">gam2</span><span class="o">=</span><span class="mf">0.</span><span class="p">,</span><span class="n">rho</span><span class="o">=</span><span class="mf">5e2</span><span class="p">,</span><span class="n">max_iter</span><span class="o">=</span><span class="mi">5000</span><span class="p">,</span>
                 <span class="n">tol</span><span class="o">=</span><span class="mf">1e-4</span><span class="p">,</span><span class="n">W_init</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span><span class="n">disp_freq</span><span class="o">=</span><span class="mi">50000</span><span class="p">,</span><span class="n">silence</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span>
                 <span class="n">n_neighbors</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">graph_type</span><span class="o">=</span><span class="s1">&#39;knn_within_class&#39;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        graph_type : {&#39;knn&#39; or &#39;knn_within_class&#39;}</span>
<span class="sd">            (X,y) driven graph construction method</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">r</span> <span class="o">=</span> <span class="n">r</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tau</span> <span class="o">=</span> <span class="n">tau</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">gam</span> <span class="o">=</span> <span class="n">gam</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">gam2</span> <span class="o">=</span> <span class="n">gam2</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">rho</span> <span class="o">=</span> <span class="n">rho</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">max_iter</span> <span class="o">=</span> <span class="n">max_iter</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tol</span> <span class="o">=</span> <span class="n">tol</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">W_init</span> <span class="o">=</span> <span class="n">W_init</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">disp_freq</span> <span class="o">=</span> <span class="n">disp_freq</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">silence</span> <span class="o">=</span> <span class="n">silence</span>

        <span class="c1"># feature driven graph construction method</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_neighbors</span> <span class="o">=</span> <span class="n">n_neighbors</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">graph_type</span> <span class="o">=</span> <span class="n">graph_type</span>

<div class="viewcode-block" id="LS_SGPNMF_ADMM.fit"><a class="viewcode-back" href="../../../test_autodoc.html#tak.ml.LS_SGPNMF_ADMM.fit">[docs]</a>    <span class="k">def</span> <span class="nf">fit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">X</span><span class="p">,</span><span class="n">y</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;WARNING: Here, to conform with scikit&#39;s convention, X is [n,p]</span>
<span class="sd">        shaped, so need to apply transpose before inputting to function&quot;&quot;&quot;</span>
        <span class="c1"># create within-class KNN graph</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">graph_type</span> <span class="o">==</span> <span class="s1">&#39;knn_within_class&#39;</span><span class="p">:</span>
            <span class="n">L</span> <span class="o">=</span> <span class="n">get_knn_within_class</span><span class="p">(</span><span class="n">X</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">n_neighbors</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">n_neighbors</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">graph_type</span> <span class="o">==</span> <span class="s1">&#39;knn&#39;</span><span class="p">:</span>
            <span class="n">L</span> <span class="o">=</span> <span class="n">get_knn_graph</span><span class="p">(</span><span class="n">X</span><span class="p">,</span><span class="n">n_neighbors</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">n_neighbors</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span>
<span class="c1">#        # if L is a tuple or list with two integers, create supervised</span>
<span class="c1">#        # MFA graph (knn_withinclass and knn_betweenclass graph)</span>
<span class="c1">#        if isinstance(self.L,list) or isinstance(self.L,tuple):</span>
<span class="c1">#            # within class intrinsic graph</span>
<span class="c1">#            Ls = get_knn_within_class(X,y,n_neighbors=self.L[0])[1]</span>
<span class="c1">#</span>
<span class="c1">#            # between class penalty graph</span>
<span class="c1">#            Lp = get_knn_between_class(X,y,n_neighbors=self.L[1])[1]</span>
<span class="c1">#</span>
<span class="c1">#            # final laplacian matrix of interest</span>
<span class="c1">#            L = Ls - Lp</span>
<span class="c1">#        elif self.L.shape[1] == len(y):</span>
<span class="c1">#            # else (nxn) laplacian matrix is assumed to be given</span>
<span class="c1">#            # (add exception statement later)</span>
<span class="c1">#            L = self.L</span>


        <span class="n">W</span><span class="p">,</span><span class="n">P</span><span class="p">,</span><span class="n">H</span><span class="p">,</span><span class="n">w</span><span class="p">,</span><span class="n">Wtil</span><span class="p">,</span><span class="n">Ptil</span><span class="p">,</span><span class="n">cost</span><span class="p">,</span><span class="n">res</span> <span class="o">=</span> <span class="n">ls_sgpnmf_admm</span><span class="p">(</span><span class="n">X</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">r</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">r</span><span class="p">,</span> <span class="n">L</span><span class="o">=</span><span class="n">L</span><span class="p">,</span>
            <span class="n">tau</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">tau</span><span class="p">,</span> <span class="n">gam</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">gam</span><span class="p">,</span> <span class="n">gam2</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">gam2</span><span class="p">,</span> <span class="n">rho</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">rho</span><span class="p">,</span>
            <span class="n">max_iter</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">max_iter</span><span class="p">,</span> <span class="n">tol</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">tol</span><span class="p">,</span> <span class="n">W_init</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">W_init</span><span class="p">,</span>
            <span class="n">disp_freq</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">disp_freq</span><span class="p">,</span> <span class="n">silence</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">silence</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">W_</span> <span class="o">=</span> <span class="n">Wtil</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">w_</span> <span class="o">=</span> <span class="n">w</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">P_</span> <span class="o">=</span> <span class="n">Ptil</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">H_</span> <span class="o">=</span> <span class="n">H</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cost_</span> <span class="o">=</span> <span class="n">cost</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">resid_</span> <span class="o">=</span> <span class="n">res</span>
        <span class="k">return</span> <span class="bp">self</span></div>

<div class="viewcode-block" id="LS_SGPNMF_ADMM.transform"><a class="viewcode-back" href="../../../test_autodoc.html#tak.ml.LS_SGPNMF_ADMM.transform">[docs]</a>    <span class="k">def</span> <span class="nf">transform</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">X</span><span class="p">,</span><span class="n">y</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;WARNING: Here, to conform with scikit&#39;s convention, X is [n,p] shaped&quot;&quot;&quot;</span>
        <span class="n">check_is_fitted</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="s1">&#39;P_&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">P_</span><span class="o">.</span><span class="n">T</span><span class="p">)</span></div>


    <span class="k">def</span> <span class="nf">decision_function</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">X</span><span class="p">):</span>
        <span class="n">check_is_fitted</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="s1">&#39;P_&#39;</span><span class="p">)</span>
        <span class="c1"># project data to low dimensional space</span>
        <span class="n">H</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">P_</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>

        <span class="c1"># apply classifier</span>
        <span class="n">score</span> <span class="o">=</span> <span class="n">H</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">w_</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">score</span>

    <span class="k">def</span> <span class="nf">predict</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">X</span><span class="p">):</span>
        <span class="n">check_is_fitted</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="s1">&#39;P_&#39;</span><span class="p">)</span>

        <span class="c1"># project data to low dimensional space</span>
        <span class="n">H</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">P_</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>

        <span class="c1"># apply classifier</span>
        <span class="n">score</span> <span class="o">=</span> <span class="n">H</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">w_</span><span class="p">)</span>
        <span class="n">ypr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sign</span><span class="p">(</span><span class="n">score</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">ypr</span></div>




<span class="c1">#%%==== helper functions =====</span>
<span class="k">def</span> <span class="nf">nnd_svd</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="n">get_H</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; My wrapper to NND-SVD from nimfa module</span>

<span class="sd">    NND-SVD = &quot;Non-Negative Double Singular Value Decomposition&quot;, proposed by</span>
<span class="sd">    Boutsidis2008.  Since my focus is on PNMF, just return matrix W.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    X : ndarray of shape [p,n]</span>
<span class="sd">        Data matrix with columns as data points</span>
<span class="sd">    r : int</span>
<span class="sd">        Dimension of the embedding space</span>
<span class="sd">    get_H : bool (default = False)</span>
<span class="sd">        Return coefficient matrix too (not needed when using projective NMF)</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    W : ndarray of shape [p,r]</span>
<span class="sd">        Initialization of basis &amp; projection matrix</span>
<span class="sd">    H : (optional) ndarray of shape [r,n]</span>
<span class="sd">        Initialization of coefficient matrix.  Returned if ``get_H=True``</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">from</span> <span class="nn">nimfa.methods.seeding.nndsvd</span> <span class="kn">import</span> <span class="n">Nndsvd</span>

    <span class="k">if</span> <span class="n">get_H</span><span class="p">:</span>
        <span class="n">Winit</span><span class="p">,</span><span class="n">Hinit</span> <span class="o">=</span> <span class="n">Nndsvd</span><span class="p">()</span><span class="o">.</span><span class="n">initialize</span><span class="p">(</span><span class="n">X</span><span class="p">,</span><span class="n">rank</span><span class="o">=</span><span class="n">r</span><span class="p">,</span><span class="n">options</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span><span class="n">flag</span><span class="o">=</span><span class="mi">0</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">Winit</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">Hinit</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">Winit</span> <span class="o">=</span> <span class="n">Nndsvd</span><span class="p">()</span><span class="o">.</span><span class="n">initialize</span><span class="p">(</span><span class="n">X</span><span class="p">,</span><span class="n">rank</span><span class="o">=</span><span class="n">r</span><span class="p">,</span><span class="n">options</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span><span class="n">flag</span><span class="o">=</span><span class="mi">0</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span>
        <span class="c1"># convert to ndarray (instead of matrix form)</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">Winit</span><span class="p">)</span>



<span class="k">def</span> <span class="nf">prox_hinge</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">tau</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Proximal operator of the hinge loss</span>

<span class="sd">    Return the prox operator of the hinge loss, given by:</span>

<span class="sd">    .. math::</span>

<span class="sd">        \\text{prox}(x,\\tau) =</span>
<span class="sd">            \\begin{cases}</span>
<span class="sd">                t       &amp; \\text{if}\\quad t &gt; 1 \\\\</span>
<span class="sd">                1       &amp; \\text{if}\\quad 1-\\tau \\le t \\le 1 \\\\</span>
<span class="sd">                t+\\tau &amp; \\text{if}\\quad t &lt; 1-\\tau</span>
<span class="sd">            \\end{cases}</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x : array_like</span>
<span class="sd">        Input values</span>

<span class="sd">    tau : float</span>
<span class="sd">        Prox-operator value</span>

<span class="sd">    Returns</span>
<span class="sd">    ------</span>
<span class="sd">    y : ndarray</span>
<span class="sd">        The prox-operator of the hinge loss</span>

<span class="sd">    Plot</span>
<span class="sd">    ----</span>
<span class="sd">    &gt;&gt;&gt; x = np.linspace(-4,4,501)</span>
<span class="sd">    &gt;&gt;&gt; plt.plot(x, prox(x,tau=2))</span>
<span class="sd">    &gt;&gt;&gt; plt.grid(&#39;on&#39;)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">x</span> <span class="o">*</span> <span class="p">(</span><span class="n">x</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="mf">1.</span> <span class="o">*</span> <span class="p">((</span><span class="mi">1</span><span class="o">-</span><span class="n">tau</span><span class="p">)</span><span class="o">&lt;=</span><span class="n">x</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">x</span><span class="o">&lt;=</span><span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="n">x</span><span class="o">+</span><span class="n">tau</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">x</span> <span class="o">&lt;</span> <span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">tau</span><span class="p">))</span>

<span class="c1">#%% --- graph related ---</span>
<span class="k">def</span> <span class="nf">get_subject_graph</span><span class="p">(</span><span class="n">df</span><span class="p">,</span> <span class="n">return_as_df</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Get &quot;subject-graph&quot;, where S_ij = 1 if (i,j) represents the same subject</span>

<span class="sd">    Returns the similarity matrix S and Laplacian matrix L of shape [n,n].</span>
<span class="sd">    Usecase for TBI, where we have scans from same subjects.</span>

<span class="sd">    Usage</span>
<span class="sd">    -----</span>
<span class="sd">    &gt;&gt;&gt; X,y,df = twio.get_tbi_connectomes(return_all_scores=True)</span>
<span class="sd">    &gt;&gt;&gt; S,L = get_subject_graph(df)</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    S, L : ndarray of shape = [n,n]</span>
<span class="sd">        Similarity and Laplacian matrix, respectively.</span>

<span class="sd">    History</span>
<span class="sd">    -------</span>
<span class="sd">    Created 02/03/2016</span>

<span class="sd">    See ``dev_0203_created_subject_graph.py``</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">n</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="c1">#from scipy import sparse</span>
    <span class="n">S</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">n</span><span class="p">,</span><span class="n">n</span><span class="p">))</span>

    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
        <span class="n">S</span><span class="p">[</span><span class="n">i</span><span class="p">,:]</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="s1">&#39;Subject_ID&#39;</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="n">df</span><span class="p">[</span><span class="s1">&#39;Subject_ID&#39;</span><span class="p">]</span>

    <span class="n">D</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span> <span class="n">S</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="p">)</span>
    <span class="n">L</span> <span class="o">=</span> <span class="n">D</span> <span class="o">-</span> <span class="n">S</span>

    <span class="k">if</span> <span class="n">return_as_df</span><span class="p">:</span>
        <span class="n">S</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">S</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="n">df</span><span class="p">[</span><span class="s1">&#39;Subject_ID&#39;</span><span class="p">],</span><span class="n">columns</span><span class="o">=</span><span class="n">df</span><span class="p">[</span><span class="s1">&#39;Subject_ID&#39;</span><span class="p">])</span>
        <span class="n">L</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">L</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="n">df</span><span class="p">[</span><span class="s1">&#39;Subject_ID&#39;</span><span class="p">],</span><span class="n">columns</span><span class="o">=</span><span class="n">df</span><span class="p">[</span><span class="s1">&#39;Subject_ID&#39;</span><span class="p">])</span>

    <span class="k">return</span> <span class="n">S</span><span class="p">,</span><span class="n">L</span>


<span class="k">def</span> <span class="nf">get_knn_kfn</span><span class="p">(</span><span class="n">X</span><span class="p">,</span><span class="n">n_neighbors</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Get k-nearest and k-farthest neighbors (in Euclidean distance)</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    X : ndarray of shape [n,p]</span>
<span class="sd">        Design matrix</span>
<span class="sd">    n_neighbors : int</span>
<span class="sd">        Number of neighbors</span>

<span class="sd">    Return</span>
<span class="sd">    ------</span>
<span class="sd">    knn : ndarray of shape [n,n_neighbors]</span>
<span class="sd">        K-nearest-neighbors</span>
<span class="sd">    kfn : ndarray of shape [n,n_neighbors,]</span>
<span class="sd">        K-farthest-neighbors</span>

<span class="sd">    Snippets</span>
<span class="sd">    --------</span>
<span class="sd">    I used this as a sanity check for this function (use Spyder variable</span>
<span class="sd">    explorer to compare EDM_sorted and EDM_knn, EDM_kfn below)</span>

<span class="sd">    &gt;&gt;&gt; knn,kfn = tw_nmf.get_knn_kfn(X,n_neighbors=5)</span>
<span class="sd">    &gt;&gt;&gt; EDM = tw.get_EDM(X)</span>
<span class="sd">    &gt;&gt;&gt; EDM_sorted = np.sort(EDM, axis=1)</span>
<span class="sd">    &gt;&gt;&gt; EDM_knn = np.zeros(knn.shape)</span>
<span class="sd">    &gt;&gt;&gt; EDM_kfn = np.zeros(knn.shape)</span>
<span class="sd">    &gt;&gt;&gt; for i in range( EDM_knn.shape[0]):</span>
<span class="sd">    &gt;&gt;&gt;     EDM_knn[i] = EDM[i, knn[i]]</span>
<span class="sd">    &gt;&gt;&gt;     EDM_kfn[i] = EDM[i, kfn[i]]</span>

<span class="sd">    **Created 01/24/2016**</span>
<span class="sd">    ----------------------</span>
<span class="sd">    See ``0124_knn_and_kfarthest_b.py``</span>

<span class="sd">    Updates 02/11/2016</span>

<span class="sd">    - replaced np.argsort with tw.argsort to handle &quot;ties&quot;</span>
<span class="sd">    - add huge diagonal item to EDM</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">from</span> <span class="nn">sklearn.metrics.pairwise</span> <span class="kn">import</span> <span class="n">pairwise_distances</span>
    <span class="n">n</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="c1"># add huge item to diagonal to ensure &quot;self&quot; will be farthest</span>
    <span class="n">EDM</span> <span class="o">=</span> <span class="n">pairwise_distances</span><span class="p">(</span><span class="n">X</span><span class="p">,</span><span class="n">metric</span><span class="o">=</span><span class="s1">&#39;euclidean&#39;</span><span class="p">)</span> <span class="o">+</span> <span class="mf">10e10</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>

    <span class="c1">#idx_rank  = np.argsort(EDM,axis=1)</span>
    <span class="n">idx_rank</span> <span class="o">=</span> <span class="n">tw</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">EDM</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

    <span class="c1"># here ok to start from beginning - i avoided self-similarity above</span>
    <span class="n">knn</span> <span class="o">=</span> <span class="n">idx_rank</span><span class="p">[:,:</span><span class="n">n_neighbors</span><span class="p">]</span>

    <span class="c1"># -1 shift since the &quot;farthest&quot; guy is the huge diagonal EDM element</span>
    <span class="c1"># I added above</span>
    <span class="n">kfn</span> <span class="o">=</span> <span class="n">idx_rank</span><span class="p">[:,</span><span class="o">-</span><span class="n">n_neighbors</span><span class="o">-</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">knn</span><span class="p">,</span><span class="n">kfn</span>



<span class="k">def</span> <span class="nf">get_knn</span><span class="p">(</span><span class="n">X</span><span class="p">,</span><span class="n">n_neighbors</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Get k-nearest neighbors (in Euclidean distance)</span>

<span class="sd">    This function is a simple wrapper to ``get_knn_kfn``, which i created first.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    X : ndarray of shape [n,p]</span>
<span class="sd">        Design matrix</span>
<span class="sd">    n_neighbors : int</span>
<span class="sd">        Number of neighbors</span>

<span class="sd">    Return</span>
<span class="sd">    ------</span>
<span class="sd">    knn : ndarray of shape [n,n_neighbors]</span>
<span class="sd">        K-nearest-neighbors for each samples (each row contains indices of kNN)</span>

<span class="sd">    Snippets</span>
<span class="sd">    --------</span>
<span class="sd">    I used this as a sanity check for this function (use Spyder variable</span>
<span class="sd">    explorer to compare EDM_sorted and EDM_knn, EDM_kfn below)</span>

<span class="sd">    &gt;&gt;&gt; knn,kfn = tw_nmf.get_knn_kfn(X,n_neighbors=5)</span>
<span class="sd">    &gt;&gt;&gt; EDM = tw.get_EDM(X)</span>
<span class="sd">    &gt;&gt;&gt; EDM_sorted = np.sort(EDM, axis=1)</span>
<span class="sd">    &gt;&gt;&gt; EDM_knn = np.zeros(knn.shape)</span>
<span class="sd">    &gt;&gt;&gt; for i in range( EDM_knn.shape[0]):</span>
<span class="sd">    &gt;&gt;&gt;     EDM_knn[i] = EDM[i, knn[i]]</span>

<span class="sd">    **Created 02/11/2016**</span>
<span class="sd">    ----------------------</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">knn</span> <span class="o">=</span> <span class="n">get_knn_kfn</span><span class="p">(</span><span class="n">X</span><span class="p">,</span><span class="n">n_neighbors</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">knn</span>


<span class="k">def</span> <span class="nf">get_kfn</span><span class="p">(</span><span class="n">X</span><span class="p">,</span><span class="n">n_neighbors</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Get k-farthest neighbors (in Euclidean distance)</span>

<span class="sd">    This function is a simple wrapper to ``get_knn_kfn``, which i created first.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    X : ndarray of shape [n,p]</span>
<span class="sd">        Design matrix</span>
<span class="sd">    n_neighbors : int</span>
<span class="sd">        Number of neighbors</span>

<span class="sd">    Return</span>
<span class="sd">    ------</span>
<span class="sd">    kfn : ndarray of shape [n,n_neighbors]</span>
<span class="sd">        K-farthest-neighbors for each samples (each row contains indices of kFN)</span>

<span class="sd">    Snippets</span>
<span class="sd">    --------</span>
<span class="sd">    I used this as a sanity check for this function (use Spyder variable</span>
<span class="sd">    explorer to compare EDM_sorted and EDM_knn, EDM_kfn below)</span>

<span class="sd">    &gt;&gt;&gt; knn,kfn = tw_nmf.get_knn_kfn(X,n_neighbors=5)</span>
<span class="sd">    &gt;&gt;&gt; EDM = tw.get_EDM(X)</span>
<span class="sd">    &gt;&gt;&gt; EDM_sorted = np.sort(EDM, axis=1)</span>
<span class="sd">    &gt;&gt;&gt; EDM_knn = np.zeros(knn.shape)</span>
<span class="sd">    &gt;&gt;&gt; for i in range( EDM_knn.shape[0]):</span>
<span class="sd">    &gt;&gt;&gt;     EDM_knn[i] = EDM[i, knn[i]]</span>

<span class="sd">    **Created 02/11/2016**</span>
<span class="sd">    ----------------------</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">kfn</span> <span class="o">=</span> <span class="n">get_knn_kfn</span><span class="p">(</span><span class="n">X</span><span class="p">,</span><span class="n">n_neighbors</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">kfn</span>


<span class="k">def</span> <span class="nf">make_graph_from_knn</span><span class="p">(</span><span class="n">knn</span><span class="p">,</span><span class="n">symm_method</span><span class="o">=</span><span class="s1">&#39;OR&#39;</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Given knn index info, create similarity and adjacency graph</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    knn : ndarray of shape [n,n_neighbors]</span>
<span class="sd">        K-nearest-neighbors indices (can also be k-FARTHEST)</span>
<span class="sd">    symm_method : {&#39;OR&#39;, &#39;AND&#39;} (default=&quot;OR&quot;)</span>
<span class="sd">        Symmetrization method (since kNN is not a symmetric relation).</span>
<span class="sd">        Logical &quot;AND&quot; or &quot;OR&quot;</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    S, L : ndarray of shape = [n,n]</span>
<span class="sd">        Similarity and Laplacian matrix, respectively.  For now, binary only.</span>

<span class="sd">    Usage</span>
<span class="sd">    -----</span>
<span class="sd">    &gt;&gt;&gt; knn = tw_nmf.get_knn(scores_exec,n_neighbors=3)</span>
<span class="sd">    &gt;&gt;&gt; S,L = tw.make_graph_from_knn(knn)</span>

<span class="sd">    History</span>
<span class="sd">    --------</span>
<span class="sd">    Created 02/11/2016</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">n</span> <span class="o">=</span> <span class="n">knn</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">S</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">n</span><span class="p">,</span><span class="n">n</span><span class="p">))</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
        <span class="n">S</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">knn</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span><span class="o">=</span><span class="mi">1</span>

    <span class="c1"># symmetrize</span>
    <span class="k">if</span> <span class="n">symm_method</span> <span class="o">==</span> <span class="s1">&#39;OR&#39;</span><span class="p">:</span>
        <span class="n">S</span> <span class="o">=</span> <span class="p">((</span><span class="n">S</span> <span class="o">+</span> <span class="n">S</span><span class="o">.</span><span class="n">T</span><span class="p">)</span><span class="o">!=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">symm_method</span> <span class="o">==</span> <span class="s1">&#39;AND&#39;</span><span class="p">:</span>
        <span class="n">S</span> <span class="o">=</span> <span class="p">((</span><span class="n">S</span> <span class="o">+</span> <span class="n">S</span><span class="o">.</span><span class="n">T</span><span class="p">)</span><span class="o">==</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span>

    <span class="c1"># create laplacian matrix</span>
    <span class="n">D</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span> <span class="n">S</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="p">)</span>
    <span class="n">L</span> <span class="o">=</span> <span class="n">D</span> <span class="o">-</span> <span class="n">S</span>

    <span class="k">return</span> <span class="n">S</span><span class="p">,</span><span class="n">L</span>




<span class="k">def</span> <span class="nf">get_knn_kfn_graph</span><span class="p">(</span><span class="n">X</span><span class="p">,</span><span class="n">n_neighbors</span><span class="p">):</span>
    <span class="n">knn</span><span class="p">,</span><span class="n">kfn</span> <span class="o">=</span> <span class="n">get_knn_kfn</span><span class="p">(</span><span class="n">X</span><span class="p">,</span><span class="n">n_neighbors</span><span class="p">)</span>
    <span class="n">n</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="n">A_knn</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">n</span><span class="p">,</span><span class="n">n</span><span class="p">))</span>
    <span class="n">A_kfn</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">n</span><span class="p">,</span><span class="n">n</span><span class="p">))</span>

    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
        <span class="n">A_knn</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">knn</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span><span class="o">=</span><span class="mi">1</span>
        <span class="n">A_kfn</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">kfn</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span><span class="o">=</span><span class="mi">1</span>

    <span class="c1"># symmetrize</span>
    <span class="n">A_knn</span> <span class="o">=</span> <span class="p">((</span><span class="n">A_knn</span> <span class="o">+</span> <span class="n">A_knn</span><span class="o">.</span><span class="n">T</span><span class="p">)</span><span class="o">!=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span>
    <span class="n">A_kfn</span> <span class="o">=</span> <span class="p">((</span><span class="n">A_kfn</span> <span class="o">+</span> <span class="n">A_kfn</span><span class="o">.</span><span class="n">T</span><span class="p">)</span><span class="o">!=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">A_knn</span><span class="p">,</span> <span class="n">A_kfn</span>


<span class="k">def</span> <span class="nf">get_knn_graph</span><span class="p">(</span><span class="n">X</span><span class="p">,</span><span class="n">n_neighbors</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">symm_method</span> <span class="o">=</span> <span class="s1">&#39;OR&#39;</span><span class="p">,</span> <span class="n">get_kfn</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Given [n,p] data matrix, return kNN graph (or kFN graph)</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    X : ndarray of shape [n,p]</span>
<span class="sd">        Design matrix</span>
<span class="sd">    n_neighbors : int</span>
<span class="sd">        Number of neighbors</span>
<span class="sd">    symm_method : {&#39;OR&#39;, &#39;AND&#39;} (default=&quot;OR&quot;)</span>
<span class="sd">        Symmetrization method (since kNN is not a symmetric relation).</span>
<span class="sd">        Logical &quot;AND&quot; or &quot;OR&quot;</span>
<span class="sd">    get_kfn : bool (default=False)</span>
<span class="sd">        Get k-&quot;farthest&quot;-neighbor graph (**added 02/11/2016**)</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    S, L : ndarray of shape = [n,n]</span>
<span class="sd">        Similarity and Laplacian matrix, respectively.  For now, binary only.</span>

<span class="sd">    History</span>
<span class="sd">    -------</span>
<span class="sd">    Created 02/03/2016</span>

<span class="sd">    02/11/2016 - Added new argument ``get_kfn`` for k-farthest option.</span>
<span class="sd">    Also decided to use new function i created, ``make_graph_from_knn`` to</span>
<span class="sd">    construct S,L from knn index info (helps code modularity)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">n</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">S</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">n</span><span class="p">,</span><span class="n">n</span><span class="p">))</span>

    <span class="c1">#--- get neighbor indices ----#</span>
    <span class="k">if</span> <span class="n">get_kfn</span><span class="p">:</span>
        <span class="c1"># note: abusive variable name</span>
        <span class="n">_</span><span class="p">,</span><span class="n">nbr_idx</span> <span class="o">=</span> <span class="n">get_knn_kfn</span><span class="p">(</span><span class="n">X</span><span class="p">,</span><span class="n">n_neighbors</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">nbr_idx</span><span class="p">,</span><span class="n">_</span> <span class="o">=</span> <span class="n">get_knn_kfn</span><span class="p">(</span><span class="n">X</span><span class="p">,</span><span class="n">n_neighbors</span><span class="p">)</span>

    <span class="c1">#--- create binary similarity graph ----#</span>
    <span class="n">S</span><span class="p">,</span><span class="n">L</span> <span class="o">=</span> <span class="n">make_graph_from_knn</span><span class="p">(</span><span class="n">nbr_idx</span><span class="p">,</span><span class="n">symm_method</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">S</span><span class="p">,</span><span class="n">L</span>


<span class="k">def</span> <span class="nf">edm_checker</span><span class="p">(</span><span class="n">Xfeatures</span><span class="p">,</span><span class="n">S</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Can be handy for checking is kNN structure makes sense</span>

<span class="sd">    Created 02/03/2016.  See ``t_0203_gpnmf_trial1.py``</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">from</span> <span class="nn">scipy.stats</span> <span class="kn">import</span> <span class="n">rankdata</span>

    <span class="c1"># EDM vectorized</span>
    <span class="n">edm</span> <span class="o">=</span> <span class="n">tw</span><span class="o">.</span><span class="n">dvec</span><span class="p">(</span><span class="n">tw</span><span class="o">.</span><span class="n">get_EDM</span><span class="p">(</span><span class="n">Xfeatures</span><span class="p">))</span>

    <span class="c1"># study df_edm inside spyder&#39;s variable explorer.</span>
    <span class="c1"># (you&#39;ll see the &quot;top rank&quot; distances are usually &quot;is_neighbor&quot;)</span>
    <span class="n">df_edm_checker</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">([</span><span class="n">edm</span><span class="p">,</span><span class="n">rankdata</span><span class="p">(</span><span class="n">edm</span><span class="p">),</span><span class="n">tw</span><span class="o">.</span><span class="n">dvec</span><span class="p">(</span><span class="n">S</span><span class="p">)],</span>
                           <span class="n">index</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;dist&#39;</span><span class="p">,</span><span class="s1">&#39;rank&#39;</span><span class="p">,</span><span class="s1">&#39;is_neighbor&#39;</span><span class="p">])</span><span class="o">.</span><span class="n">T</span>
    <span class="k">return</span> <span class="n">df_edm_checker</span>


<span class="k">def</span> <span class="nf">edm_checker_embedding</span><span class="p">(</span><span class="n">X</span><span class="p">,</span><span class="n">H</span><span class="p">,</span><span class="n">S</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Checker to see if &quot;similar&quot; sample nearby in embedded space</span>

<span class="sd">    X : ndarray of shape = [n_samples,n_features]</span>
<span class="sd">        Original feature</span>
<span class="sd">    H : ndarray of shape = [n_samples,n_reduced_features]</span>
<span class="sd">        Features embedded in lower dimensional space</span>
<span class="sd">    S : ndarray of shape = [n_samples,n_samples]</span>
<span class="sd">        Similarity matrix.  The nonzero locations indicates pairs where</span>
<span class="sd">        EDM values should be small in the embedded space.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    df_edm : dataframe with nchoosek(n_samples,2) rows (all possible pairs)</span>
<span class="sd">        Contains ranking info of EDM in original and embedded feature space.</span>
<span class="sd">        I used this to view in spyder&#39;s explorer as a check to see my</span>
<span class="sd">        graph regularizer is working.</span>

<span class="sd">    History</span>
<span class="sd">    -------</span>
<span class="sd">    Created 02/03/2016.  See ``t_0203_gpnmf_trial1.py``</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1">##%% ensure subjects that are indicated &quot;similar&quot; by S are indeed nearby in H</span>
    <span class="kn">from</span> <span class="nn">scipy.stats</span> <span class="kn">import</span> <span class="n">rankdata</span>

    <span class="c1"># EDM in original space</span>
    <span class="n">edm_raw</span> <span class="o">=</span> <span class="n">tw</span><span class="o">.</span><span class="n">dvec</span><span class="p">(</span><span class="n">tw</span><span class="o">.</span><span class="n">get_EDM</span><span class="p">(</span><span class="n">X</span><span class="p">))</span>

    <span class="c1"># EDM in new space</span>
    <span class="n">edm</span> <span class="o">=</span> <span class="n">tw</span><span class="o">.</span><span class="n">dvec</span><span class="p">(</span><span class="n">tw</span><span class="o">.</span><span class="n">get_EDM</span><span class="p">(</span><span class="n">H</span><span class="p">))</span>

    <span class="c1"># study df_edm inside spyder&#39;s variable explorer.</span>
    <span class="c1"># (you&#39;ll see the &quot;top rank&quot; distances are usually &quot;is_neighbor&quot;</span>
    <span class="n">df_edm</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">([</span><span class="n">edm_raw</span><span class="p">,</span><span class="n">rankdata</span><span class="p">(</span><span class="n">edm_raw</span><span class="p">),</span><span class="n">edm</span><span class="p">,</span><span class="n">rankdata</span><span class="p">(</span><span class="n">edm</span><span class="p">),</span><span class="n">tw</span><span class="o">.</span><span class="n">dvec</span><span class="p">(</span><span class="n">S</span><span class="p">)],</span>
                           <span class="n">index</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;dist_X&#39;</span><span class="p">,</span><span class="s1">&#39;rank_X&#39;</span><span class="p">,</span><span class="s1">&#39;dist_H&#39;</span><span class="p">,</span><span class="s1">&#39;rank_H&#39;</span><span class="p">,</span><span class="s1">&#39;is_neighbor&#39;</span><span class="p">])</span><span class="o">.</span><span class="n">T</span>
    <span class="k">return</span> <span class="n">df_edm</span>


<span class="k">def</span> <span class="nf">get_knn_within_class</span><span class="p">(</span><span class="n">X</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">n_neighbors</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span><span class="n">symm_method</span><span class="o">=</span><span class="s1">&#39;OR&#39;</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Get within-class k-nearest-neighbor.</span>

<span class="sd">    KNN structure with the restriction that the label of the data pair agree.</span>

<span class="sd">    X : ndarray of shape [n_samples,n_feaures]</span>
<span class="sd">        Data matrix</span>
<span class="sd">    y : label vector of shape [n_samples]</span>
<span class="sd">        Binary label vector</span>

<span class="sd">    History</span>
<span class="sd">    -------</span>
<span class="sd">    Created 02/03/2016 - see ``dev_0203_get_within_betweenclass_knn.py``</span>

<span class="sd">    Update 02/11/2016</span>

<span class="sd">    - replaced np.argsort with tw.argsort to handle &quot;ties&quot;</span>
<span class="sd">    - decided to use new function i created, ``make_graph_from_knn`` to</span>
<span class="sd">      construct S,L from knn index info (helps code modularity)</span>
<span class="sd">    - removed variable ``ranking`` inside code...it doesn&#39;t seem to do anything</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>

    <span class="c1"># set diagonal to large value to avoid self similarity (helps the sorting and ranking)</span>
    <span class="n">EDM</span> <span class="o">=</span> <span class="n">tw</span><span class="o">.</span><span class="n">get_EDM</span><span class="p">(</span><span class="n">X</span><span class="p">)</span> <span class="o">+</span> <span class="mf">1e10</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>

    <span class="c1">#idx_rank = np.argsort(EDM,axis=1)</span>
    <span class="n">idx_rank</span> <span class="o">=</span> <span class="n">tw</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">EDM</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

    <span class="n">knn_within</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">n</span><span class="p">,</span> <span class="n">n_neighbors</span><span class="p">),</span><span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
        <span class="n">kth_nearest</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
            <span class="c1"># candidate subject to compare</span>
            <span class="n">isub</span> <span class="o">=</span> <span class="n">idx_rank</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span>

            <span class="c1"># if candidate subject label agrees, than add to knn</span>
            <span class="k">if</span> <span class="n">y</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="n">y</span><span class="p">[</span><span class="n">isub</span><span class="p">]:</span>
                <span class="n">knn_within</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">kth_nearest</span><span class="p">]</span> <span class="o">=</span> <span class="n">isub</span>

                <span class="c1"># now look for the &quot;next&quot; nearest neighbor</span>
                <span class="n">kth_nearest</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="k">if</span> <span class="n">kth_nearest</span> <span class="o">==</span> <span class="n">n_neighbors</span><span class="p">:</span> <span class="k">break</span>

    <span class="c1"># now we&#39;re ready to make knn graph matrices</span>
    <span class="n">S</span><span class="p">,</span><span class="n">L</span> <span class="o">=</span> <span class="n">make_graph_from_knn</span><span class="p">(</span><span class="n">knn_within</span><span class="p">,</span><span class="n">symm_method</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">S</span><span class="p">,</span><span class="n">L</span><span class="p">,</span><span class="n">knn_within</span>




<span class="k">def</span> <span class="nf">get_knn_between_class</span><span class="p">(</span><span class="n">X</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">n_neighbors</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span><span class="n">symm_method</span><span class="o">=</span><span class="s1">&#39;OR&#39;</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Get between-class k-nearest-neighbor.</span>

<span class="sd">    KNN structure with the restriction that the label of the data pair disagree</span>

<span class="sd">    History</span>
<span class="sd">    -------</span>
<span class="sd">    Created 02/03/2016 - see ``dev_0203_get_within_betweenclass_knn.py``</span>

<span class="sd">    Update 02/11/2016</span>

<span class="sd">    - replaced np.argsort with tw.argsort to handle &quot;ties&quot;</span>
<span class="sd">    - decided to use new function i created, ``make_graph_from_knn`` to</span>
<span class="sd">      construct S,L from knn index info (helps code modularity)</span>
<span class="sd">    - removed variable ``ranking`` inside code...it doesn&#39;t seem to do anything</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>

    <span class="c1"># set diagonal to large value to avoid self similarity (helps the sorting and ranking)</span>
    <span class="n">EDM</span> <span class="o">=</span> <span class="n">tw</span><span class="o">.</span><span class="n">get_EDM</span><span class="p">(</span><span class="n">X</span><span class="p">)</span> <span class="o">+</span> <span class="mf">1e10</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>

    <span class="c1">#idx_rank = np.argsort(EDM,axis=1)</span>
    <span class="n">idx_rank</span> <span class="o">=</span> <span class="n">tw</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">EDM</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

    <span class="n">knn_between</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">n</span><span class="p">,</span> <span class="n">n_neighbors</span><span class="p">),</span><span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
        <span class="n">kth_nearest</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
            <span class="c1"># candidate subject to compare</span>
            <span class="n">isub</span> <span class="o">=</span> <span class="n">idx_rank</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span>

            <span class="c1"># if candidate subject label disagrees, than add to knn</span>
            <span class="k">if</span> <span class="n">y</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">!=</span> <span class="n">y</span><span class="p">[</span><span class="n">isub</span><span class="p">]:</span>
                <span class="n">knn_between</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">kth_nearest</span><span class="p">]</span> <span class="o">=</span> <span class="n">isub</span>

                <span class="c1"># now look for the &quot;next&quot; nearest neighbor</span>
                <span class="n">kth_nearest</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="k">if</span> <span class="n">kth_nearest</span> <span class="o">==</span> <span class="n">n_neighbors</span><span class="p">:</span> <span class="k">break</span>

    <span class="c1"># now we&#39;re ready to make knn graph matrices</span>
    <span class="n">S</span><span class="p">,</span><span class="n">L</span> <span class="o">=</span> <span class="n">make_graph_from_knn</span><span class="p">(</span><span class="n">knn_between</span><span class="p">,</span><span class="n">symm_method</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">S</span><span class="p">,</span><span class="n">L</span><span class="p">,</span><span class="n">knn_between</span>


<span class="k">def</span> <span class="nf">get_gose_graph_sorted_y</span><span class="p">(</span><span class="n">df</span><span class="p">,</span><span class="n">y</span><span class="p">,</span> <span class="n">n_neighbors</span><span class="o">=</span><span class="mi">3</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Get GOSE/DRS knn-graph.</span>

<span class="sd">    For control subjects, all similarity will have zero values.</span>

<span class="sd">    Here assume y is sorted into blocks of TBI and HC.  This way it is easy</span>
<span class="sd">    to assign similarity matrix, as it&#39;ll have block diagonal structure.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    df : dataframe</span>
<span class="sd">        &gt;&gt;&gt; X,y,df = twio.get_tbi_connectomes(return_all_scores=True)</span>
<span class="sd">    y : array-like of shape = (n_subjects,)</span>
<span class="sd">        Vector of binary labels.  Must be sorted in blocks of +1 and -1</span>
<span class="sd">    n_neighbors : int</span>
<span class="sd">        Number of neighbors to select in kNN (ie, value of k)</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    S, L : ndarray of shape = [n,n]</span>
<span class="sd">        Similarity and Laplacian matrix, respectively.  For now, binary only.</span>
<span class="sd">        S_{i,j} will be 1 if subjects i and j are both TBI, and the</span>
<span class="sd">        Euclidean distance in [GOSE,DRS] are among kNN.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>

    <span class="n">df_tbi</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="s1">&#39;y_dx == +1&#39;</span><span class="p">)[[</span><span class="s1">&#39;GOSE&#39;</span><span class="p">,</span><span class="s1">&#39;DRS&#39;</span><span class="p">]]</span>
    <span class="n">S_tbi</span> <span class="o">=</span> <span class="n">get_knn_graph</span><span class="p">(</span><span class="n">df_tbi</span><span class="o">.</span><span class="n">values</span><span class="p">,</span><span class="n">n_neighbors</span><span class="o">=</span><span class="n">n_neighbors</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>

    <span class="n">S</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">n</span><span class="p">,</span><span class="n">n</span><span class="p">))</span>
    <span class="n">S</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ix_</span><span class="p">(</span> <span class="n">df_tbi</span><span class="o">.</span><span class="n">index</span><span class="p">,</span> <span class="n">df_tbi</span><span class="o">.</span><span class="n">index</span><span class="p">)]</span> <span class="o">=</span> <span class="n">S_tbi</span>

    <span class="n">L</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">S</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">))</span> <span class="o">-</span> <span class="n">S</span>
    <span class="k">return</span> <span class="n">S</span><span class="p">,</span> <span class="n">L</span>

<span class="k">def</span> <span class="nf">get_gose_graph</span><span class="p">(</span><span class="n">df</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">n_neighbors</span><span class="o">=</span><span class="mi">3</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Get GOSE/DRS knn-graph, where y can be shuffled in any arbitrary order.</span>

<span class="sd">    For control subjects, all similarity will have zero values.</span>

<span class="sd">    Here assume y is sorted into blocks of TBI and HC.  This way it is easy</span>
<span class="sd">    to assign similarity matrix, as it&#39;ll have block diagonal structure.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    df : dataframe</span>
<span class="sd">        &gt;&gt;&gt; X,y,df = twio.get_tbi_connectomes(return_all_scores=True)</span>
<span class="sd">    y : array-like of shape = (n_subjects,)</span>
<span class="sd">        Vector of binary labels</span>
<span class="sd">    n_neighbors : int</span>
<span class="sd">        Number of neighbors to select in kNN (ie, value of k)</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    S, L : ndarray of shape = [n,n]</span>
<span class="sd">        Similarity and Laplacian matrix, respectively.  For now, binary only.</span>
<span class="sd">        S_{i,j} will be 1 if subjects i and j are both TBI, and the</span>
<span class="sd">        Euclidean distance in [GOSE,DRS] are among kNN.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1">#--- first sort TBI/HC subjects ---#</span>
    <span class="sd">&quot;&quot;&quot;numpy argsort will return index-order of &quot;ties&quot; in seemingly arbitrary</span>
<span class="sd">       order....i want the &quot;ties&quot; to be returned in the order of the original</span>
<span class="sd">       occurence (for example, if y[10],y[15],y[21] are tied, i want the</span>
<span class="sd">       idx_sort to give me (10,15,21), not random permutation of it.</span>
<span class="sd">       Use rankdata for this.</span>
<span class="sd">       http://stackoverflow.com/questions/14671013/</span>
<span class="sd">       ranking-of-numpy-array-with-possible-duplicates</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1">#idx_sort = np.argsort(y) #&lt;== don&#39;t do this!</span>
    <span class="n">idx_sort</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">rankdata</span><span class="p">(</span><span class="n">y</span><span class="p">,</span><span class="s1">&#39;ordinal&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">argsort</span><span class="p">()</span>
    <span class="n">rev_sort</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">idx_sort</span><span class="p">)</span> <span class="c1"># &lt;- to &quot;undo&quot; sorting</span>
    <span class="c1">#http://stackoverflow.com/questions/2483696/undo-or-reverse-argsort-python</span>

    <span class="n">df_sort</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">ix</span><span class="p">[</span><span class="n">idx_sort</span><span class="p">,:]</span><span class="o">.</span><span class="n">reset_index</span><span class="p">(</span><span class="n">drop</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
    <span class="n">y_sort</span>  <span class="o">=</span> <span class="n">y</span><span class="p">[</span><span class="n">idx_sort</span><span class="p">]</span>

    <span class="c1">#--- now we can use the &quot;sorted&quot; gose/drs graph construction ---#</span>
    <span class="n">S</span> <span class="o">=</span> <span class="n">get_gose_graph_sorted_y</span><span class="p">(</span><span class="n">df_sort</span><span class="p">,</span><span class="n">y_sort</span><span class="p">,</span><span class="n">n_neighbors</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>

    <span class="c1"># undo the sorting</span>
    <span class="n">S</span> <span class="o">=</span> <span class="n">S</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ix_</span><span class="p">(</span><span class="n">rev_sort</span><span class="p">,</span><span class="n">rev_sort</span><span class="p">)]</span>

    <span class="c1"># Laplacian graph</span>
    <span class="n">L</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">S</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">))</span> <span class="o">-</span> <span class="n">S</span>
    <span class="k">return</span> <span class="n">S</span><span class="p">,</span><span class="n">L</span>



<span class="k">def</span> <span class="nf">get_subject_constrained_gose_knn</span><span class="p">(</span><span class="n">df</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">n_neighbors</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span><span class="n">sanity_check</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Get gose/drs knn graph, with the constraint that if S_ij cannot be</span>
<span class="sd">    the same subject</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    df : dataframe</span>
<span class="sd">        &gt;&gt;&gt; X,y,df = twio.get_tbi_connectomes(return_all_scores=True)</span>
<span class="sd">    y : array-like of shape = (n_subjects,)</span>
<span class="sd">        Vector of binary labels</span>
<span class="sd">    n_neighbors : int</span>
<span class="sd">        Number of neighbors to select in kNN (ie, value of k)</span>
<span class="sd">    sanity_check : bool (default=False)</span>
<span class="sd">        Return extra &quot;sanity-check&quot; items</span>

<span class="sd">        &gt;&gt;&gt; # sanity_check = False</span>
<span class="sd">        &gt;&gt;&gt; knn_gose, knn_gose_subj = get_subject_constrained_gose_knn(df,y)</span>
<span class="sd">        &gt;&gt;&gt; # sanity_check = True</span>
<span class="sd">        &gt;&gt;&gt; knn_gose, knn_gose_subj,df_EDM,df_EDM_sorted,df_EDM_knn = ...</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    knn_gose : pd.DataFrame of of shape=(n_tbi,n_neibors)</span>
<span class="sd">        knn structure, where each row indicates a subject, and col-values</span>
<span class="sd">        contains integer indices of kNN for that subject.</span>
<span class="sd">    knn_gose_subj : pd.DataFrame of of shape=(n_tbi,n_neibors)</span>
<span class="sd">        Contains string of Subject_ID (good sanity check for myself that</span>
<span class="sd">        the same subject is not connected via knn)</span>

<span class="sd">    Extra returns if sanity_check is on</span>
<span class="sd">    -----------------------------------</span>
<span class="sd">    Bit tedious to explain in words....</span>
<span class="sd">    Run the snippet code above, and explore them in spyder variable explorer,</span>
<span class="sd">    and you&#39;ll get what i mean...</span>

<span class="sd">    History</span>
<span class="sd">    -------</span>
<span class="sd">    Created 02/11/2016 - see ``dev_0211_create_constrained_gose_graph.py``</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
    <span class="n">n_tbi</span> <span class="o">=</span> <span class="p">(</span><span class="n">y</span><span class="o">==+</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>

    <span class="n">df_tbi</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="s1">&#39;y_dx==1&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">reset_index</span><span class="p">()</span>
    <span class="n">id_list</span> <span class="o">=</span> <span class="n">df_tbi</span><span class="p">[</span><span class="s1">&#39;Subject_ID&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>

    <span class="c1"># set diagonal to large value to avoid self similarity (helps the sorting and ranking)</span>
    <span class="n">EDM</span> <span class="o">=</span> <span class="n">tw</span><span class="o">.</span><span class="n">get_EDM</span><span class="p">(</span><span class="n">df_tbi</span><span class="p">[[</span><span class="s1">&#39;GOSE&#39;</span><span class="p">,</span><span class="s1">&#39;DRS&#39;</span><span class="p">]]</span><span class="o">.</span><span class="n">values</span><span class="p">)</span> <span class="o">+</span> <span class="mf">1e10</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="n">n_tbi</span><span class="p">)</span>

    <span class="c1">#--- create subject constrained gose knn graph ---#</span>
    <span class="n">knn_gose</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">n_tbi</span><span class="p">,</span> <span class="n">n_neighbors</span><span class="p">),</span><span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
    <span class="n">knn_gose_subj</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">n_tbi</span><span class="p">,</span><span class="n">n_neighbors</span><span class="p">),</span><span class="n">dtype</span><span class="o">=</span><span class="nb">object</span><span class="p">)</span>
    <span class="n">idx_rank</span> <span class="o">=</span> <span class="n">tw</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">EDM</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_tbi</span><span class="p">):</span>
        <span class="n">kth_nearest</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">id_i</span> <span class="o">=</span> <span class="n">id_list</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
            <span class="c1"># candidate subject to compare</span>
            <span class="n">isub</span> <span class="o">=</span> <span class="n">idx_rank</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span>

            <span class="c1"># if indices (i,j) are NOT the same subject, than add to knn</span>
            <span class="k">if</span> <span class="n">id_i</span> <span class="o">!=</span> <span class="n">id_list</span><span class="p">[</span><span class="n">isub</span><span class="p">]:</span>
                <span class="n">knn_gose</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">kth_nearest</span><span class="p">]</span> <span class="o">=</span> <span class="n">isub</span>
                <span class="c1">#knn_gose_subj[i,kth_nearest] = id_list[isub]</span>
                <span class="n">knn_gose_subj</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">kth_nearest</span><span class="p">]</span> <span class="o">=</span> <span class="n">df_tbi</span><span class="p">[</span><span class="s1">&#39;ID&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">tolist</span><span class="p">()[</span><span class="n">isub</span><span class="p">]</span>

                <span class="c1"># now look for the &quot;next&quot; nearest neighbor</span>
                <span class="n">kth_nearest</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="k">if</span> <span class="n">kth_nearest</span> <span class="o">==</span> <span class="n">n_neighbors</span><span class="p">:</span>
                    <span class="k">break</span>

    <span class="c1"># convert to dataframe so i can view in spyder variable explorer</span>
    <span class="n">knn_gose</span>      <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">knn_gose</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="n">df_tbi</span><span class="p">[</span><span class="s1">&#39;ID&#39;</span><span class="p">])</span>
    <span class="n">knn_gose_subj</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">knn_gose_subj</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="n">df_tbi</span><span class="p">[</span><span class="s1">&#39;ID&#39;</span><span class="p">])</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">sanity_check</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">knn_gose</span><span class="p">,</span> <span class="n">knn_gose_subj</span>

    <span class="c1">#---- for sanity check, get sorted EDM with distance and subject-id -----#</span>
    <span class="n">idx_sort</span> <span class="o">=</span> <span class="n">tw</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">EDM</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">df_EDM_sorted</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">index</span><span class="o">=</span><span class="n">df_tbi</span><span class="p">[</span><span class="s1">&#39;ID&#39;</span><span class="p">],</span><span class="n">columns</span><span class="o">=</span><span class="nb">range</span><span class="p">(</span><span class="n">n_tbi</span><span class="p">))</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_tbi</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_tbi</span><span class="p">):</span>
            <span class="n">_dist</span> <span class="o">=</span> <span class="n">EDM</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">idx_sort</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]]</span>
            <span class="n">_id</span>   <span class="o">=</span> <span class="n">df_tbi</span><span class="p">[</span><span class="s1">&#39;ID&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">tolist</span><span class="p">()[</span><span class="n">idx_sort</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]]</span>
            <span class="n">df_EDM_sorted</span><span class="o">.</span><span class="n">ix</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">_id</span><span class="p">,</span><span class="n">_dist</span><span class="p">)</span>

    <span class="c1">#--- now get constrained knn info, of distance and subject-id ---#</span>
    <span class="c1">#--- make sure no same-subject are not connected              ---#</span>
    <span class="n">df_EDM_knn</span><span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">index</span><span class="o">=</span><span class="n">df_tbi</span><span class="p">[</span><span class="s1">&#39;ID&#39;</span><span class="p">],</span> <span class="n">columns</span><span class="o">=</span><span class="nb">range</span><span class="p">(</span><span class="n">n_neighbors</span><span class="p">))</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_tbi</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_neighbors</span><span class="p">):</span>
            <span class="n">idx</span> <span class="o">=</span> <span class="n">knn_gose</span><span class="o">.</span><span class="n">ix</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span>
            <span class="n">_dist</span> <span class="o">=</span> <span class="n">EDM</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">idx</span><span class="p">]</span>
            <span class="n">_id</span>   <span class="o">=</span> <span class="n">df_tbi</span><span class="p">[</span><span class="s1">&#39;ID&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">tolist</span><span class="p">()[</span><span class="n">idx</span><span class="p">]</span>
            <span class="n">df_EDM_knn</span><span class="o">.</span><span class="n">ix</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">_id</span><span class="p">,</span> <span class="n">_dist</span><span class="p">)</span>

    <span class="n">df_EDM</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">EDM</span><span class="p">,</span><span class="n">index</span><span class="o">=</span><span class="n">df_tbi</span><span class="p">[</span><span class="s1">&#39;ID&#39;</span><span class="p">],</span><span class="n">columns</span><span class="o">=</span><span class="n">df_tbi</span><span class="p">[</span><span class="s1">&#39;ID&#39;</span><span class="p">])</span>

    <span class="c1"># Tranpose makes it easier to view in spyder variable explorer</span>
    <span class="n">df_EDM_sorted</span> <span class="o">=</span> <span class="n">df_EDM_sorted</span><span class="o">.</span><span class="n">T</span>
    <span class="n">df_EDM_knn</span>    <span class="o">=</span> <span class="n">df_EDM_knn</span><span class="o">.</span><span class="n">T</span>

    <span class="k">return</span> <span class="n">knn_gose</span><span class="p">,</span> <span class="n">knn_gose_subj</span><span class="p">,</span><span class="n">df_EDM</span><span class="p">,</span><span class="n">df_EDM_sorted</span><span class="p">,</span><span class="n">df_EDM_knn</span>


<span class="k">def</span> <span class="nf">get_subject_constrained_gose_graph</span><span class="p">(</span><span class="n">df</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">n_neighbors</span><span class="o">=</span><span class="mi">10</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Get gose/drs knn graph, with the constraint that if S_ij cannot be</span>
<span class="sd">    the same subject</span>

<span class="sd">    Note that df and y can be permuted in any order, which is important</span>
<span class="sd">    when running cross-validation.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    df : dataframe</span>
<span class="sd">        &gt;&gt;&gt; X,y,df = twio.get_tbi_connectomes(return_all_scores=True)</span>
<span class="sd">    y : array-like of shape = (n_subjects,)</span>
<span class="sd">        Vector of binary labels</span>
<span class="sd">    n_neighbors : int</span>
<span class="sd">        Number of neighbors to select in kNN (ie, value of k)</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    S, L : ndarray of shape = [n,n]</span>
<span class="sd">        Similarity and Laplacian matrix, respectively.  For now, binary only.</span>
<span class="sd">        S_{i,j} will be 1 if subjects i and j are both TBI, and the</span>
<span class="sd">        Euclidean distance in [GOSE,DRS] are among kNN.</span>

<span class="sd">    History</span>
<span class="sd">    -------</span>
<span class="sd">    Created 02/11/2016 - see ``dev_0211_create_constrained_gose_graph.py``</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>

    <span class="c1">#| note that since i&#39;m using rankdata.argsort(), all these sorting and</span>
    <span class="c1">#| revsorting will not do anything  if y are already sorted, which is</span>
    <span class="c1">#| nice since i don&#39;t have to create and maintain a separate function</span>
    <span class="n">idx_sort</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">rankdata</span><span class="p">(</span><span class="n">y</span><span class="p">,</span><span class="s1">&#39;ordinal&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">argsort</span><span class="p">()</span>
    <span class="n">rev_sort</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">idx_sort</span><span class="p">)</span> <span class="c1"># &lt;- to &quot;undo&quot; sorting</span>
    <span class="c1">#http://stackoverflow.com/questions/2483696/undo-or-reverse-argsort-python</span>

    <span class="n">df_sort</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">ix</span><span class="p">[</span><span class="n">idx_sort</span><span class="p">,:]</span><span class="o">.</span><span class="n">reset_index</span><span class="p">(</span><span class="n">drop</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
    <span class="n">y_sort</span>  <span class="o">=</span> <span class="n">y</span><span class="p">[</span><span class="n">idx_sort</span><span class="p">]</span>

    <span class="c1">#--- now we can use the &quot;sorted&quot; gose/drs graph construction ---#</span>
    <span class="n">knn_gose</span> <span class="o">=</span> <span class="n">get_subject_constrained_gose_knn</span><span class="p">(</span><span class="n">df_sort</span><span class="p">,</span><span class="n">y_sort</span><span class="p">,</span><span class="n">n_neighbors</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">S_tbi</span> <span class="o">=</span> <span class="n">make_graph_from_knn</span><span class="p">(</span><span class="n">knn_gose</span><span class="o">.</span><span class="n">values</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">S</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">n</span><span class="p">,</span><span class="n">n</span><span class="p">))</span>

    <span class="c1"># thanks to the sorting, this S will have block diagonal structure</span>
    <span class="n">S</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ix_</span><span class="p">(</span> <span class="n">y_sort</span><span class="o">==+</span><span class="mi">1</span><span class="p">,</span><span class="n">y_sort</span><span class="o">==+</span><span class="mi">1</span><span class="p">)]</span> <span class="o">=</span> <span class="n">S_tbi</span>

    <span class="c1">#==== undo the sorting ====#</span>
    <span class="n">S</span> <span class="o">=</span> <span class="n">S</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ix_</span><span class="p">(</span><span class="n">rev_sort</span><span class="p">,</span><span class="n">rev_sort</span><span class="p">)]</span>

    <span class="c1"># Laplacian graph</span>
    <span class="n">L</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">S</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">))</span> <span class="o">-</span> <span class="n">S</span>
    <span class="k">return</span> <span class="n">S</span><span class="p">,</span><span class="n">L</span>


<span class="k">def</span> <span class="nf">get_gose_kfn</span><span class="p">(</span><span class="n">df</span><span class="p">,</span><span class="n">n_neighbors</span><span class="o">=</span><span class="mi">10</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Get gose/drs kfn graph.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    df : dataframe</span>
<span class="sd">        &gt;&gt;&gt; X,y,df = twio.get_tbi_connectomes(return_all_scores=True)</span>
<span class="sd">    y : array-like of shape = (n_subjects,)</span>
<span class="sd">        Vector of binary labels</span>
<span class="sd">    n_neighbors : int</span>
<span class="sd">        Number of neighbors to select in kFN (ie, value of k)</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    kfn_gose : pd.DataFrame of of shape=(n_tbi,n_neibors)</span>
<span class="sd">        kfn structure, where each row indicates a subject, and col-values</span>
<span class="sd">        contains integer indices of kNN for that subject.</span>
<span class="sd">    kfn_gose_subj : pd.DataFrame of of shape=(n_tbi,n_neibors)</span>
<span class="sd">        Contains string of Subject_ID (good for sanity check with ``df_EDM``)</span>
<span class="sd">    df_EDM : pd.DataFrame of of shape=(n_neighbors,n_neighbors)</span>
<span class="sd">        Col/Index = subject id</span>

<span class="sd">    History</span>
<span class="sd">    -------</span>
<span class="sd">    Created 02/11/2016 - see ``dev_0211_create_kfn_gose_graph.py``</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">df_tbi</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="s1">&#39;y_dx==1&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">reset_index</span><span class="p">()</span>
    <span class="n">n_tbi</span> <span class="o">=</span> <span class="n">df_tbi</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="c1">##### set diagonal to large value to avoid self similarity (helps the sorting and ranking)</span>
    <span class="c1"># no, don&#39;t do this....i want the last n_neighbor columns to be the &quot;farthest&quot;</span>
    <span class="n">EDM</span> <span class="o">=</span> <span class="n">tw</span><span class="o">.</span><span class="n">get_EDM</span><span class="p">(</span><span class="n">df_tbi</span><span class="p">[[</span><span class="s1">&#39;GOSE&#39;</span><span class="p">,</span><span class="s1">&#39;DRS&#39;</span><span class="p">]]</span><span class="o">.</span><span class="n">values</span><span class="p">)</span><span class="c1"># + 1e10*np.eye(n_tbi)</span>

    <span class="c1">#--- create subject constrained gose knn graph ---#</span>
    <span class="n">kfn_gose</span> <span class="o">=</span> <span class="n">get_kfn</span><span class="p">(</span><span class="n">df_tbi</span><span class="p">[[</span><span class="s1">&#39;GOSE&#39;</span><span class="p">,</span><span class="s1">&#39;DRS&#39;</span><span class="p">]]</span><span class="o">.</span><span class="n">values</span><span class="p">,</span><span class="n">n_neighbors</span><span class="p">)</span>
    <span class="n">kfn_gose</span> <span class="o">=</span> <span class="n">kfn_gose</span><span class="p">[:,::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="c1"># reverse sort so &quot;farthest&quot; appears in the first column</span>
    <span class="n">kfn_gose_subj</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">n_tbi</span><span class="p">,</span><span class="n">n_neighbors</span><span class="p">),</span><span class="n">dtype</span><span class="o">=</span><span class="nb">object</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_tbi</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_neighbors</span><span class="p">):</span>
            <span class="n">idx</span> <span class="o">=</span> <span class="n">kfn_gose</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span>
            <span class="n">kfn_gose_subj</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">df_tbi</span><span class="p">[</span><span class="s1">&#39;ID&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">tolist</span><span class="p">()[</span><span class="n">idx</span><span class="p">]</span>

    <span class="c1"># convert to dataframe so i can view in spyder variable explorer</span>
    <span class="n">kfn_gose</span>      <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">kfn_gose</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="n">df_tbi</span><span class="p">[</span><span class="s1">&#39;ID&#39;</span><span class="p">])</span>
    <span class="n">kfn_gose_subj</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">kfn_gose_subj</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="n">df_tbi</span><span class="p">[</span><span class="s1">&#39;ID&#39;</span><span class="p">])</span><span class="o">.</span><span class="n">T</span>

    <span class="n">df_EDM</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">EDM</span><span class="p">,</span><span class="n">index</span><span class="o">=</span><span class="n">df_tbi</span><span class="p">[</span><span class="s1">&#39;ID&#39;</span><span class="p">],</span><span class="n">columns</span><span class="o">=</span><span class="n">df_tbi</span><span class="p">[</span><span class="s1">&#39;ID&#39;</span><span class="p">])</span>
    <span class="n">EDM</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">EDM</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">kfn_gose</span><span class="p">,</span><span class="n">kfn_gose_subj</span><span class="p">,</span><span class="n">df_EDM</span><span class="p">,</span> <span class="n">EDM</span>


<span class="k">def</span> <span class="nf">get_gose_graph_kfn</span><span class="p">(</span><span class="n">df</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">n_neighbors</span><span class="o">=</span><span class="mi">10</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Get gose/drs kfn graph</span>

<span class="sd">    Note that df and y can be permuted in any order, which is important</span>
<span class="sd">    when running cross-validation.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    df : dataframe</span>
<span class="sd">        &gt;&gt;&gt; X,y,df = twio.get_tbi_connectomes(return_all_scores=True)</span>
<span class="sd">    y : array-like of shape = (n_subjects,)</span>
<span class="sd">        Vector of binary labels</span>
<span class="sd">    n_neighbors : int</span>
<span class="sd">        Number of neighbors to select in kFN (ie, value of k)</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    S, L : ndarray of shape = [n,n]</span>
<span class="sd">        Similarity and Laplacian matrix, respectively.  For now, binary only.</span>
<span class="sd">        S_{i,j} will be 1 if subjects i and j are both TBI, and the</span>
<span class="sd">        Euclidean distance in [GOSE,DRS] are among kFN.</span>

<span class="sd">    TODO</span>
<span class="sd">    -----</span>
<span class="sd">    HUGE overlap with ``get_subject_constrained_gose_graph``....the crux is</span>
<span class="sd">    sorting tbi subjects into cluster, than inverse sorting.  Try to merge</span>
<span class="sd">    two functions together if I find i may need to create another variant</span>
<span class="sd">    of this idea.</span>

<span class="sd">    History</span>
<span class="sd">    -------</span>
<span class="sd">    Created 02/11/2016 - see ``dev_0211_create_kfn_gose_graph.py``</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>

    <span class="c1">#| note that since i&#39;m using rankdata.argsort(), all these sorting and</span>
    <span class="c1">#| revsorting will not do anything  if y are already sorted, which is</span>
    <span class="c1">#| nice since i don&#39;t have to create and maintain a separate function</span>
    <span class="n">idx_sort</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">rankdata</span><span class="p">(</span><span class="n">y</span><span class="p">,</span><span class="s1">&#39;ordinal&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">argsort</span><span class="p">()</span>
    <span class="n">rev_sort</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">idx_sort</span><span class="p">)</span> <span class="c1"># &lt;- to &quot;undo&quot; sorting</span>
    <span class="c1">#http://stackoverflow.com/questions/2483696/undo-or-reverse-argsort-python</span>

    <span class="n">df_sort</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">ix</span><span class="p">[</span><span class="n">idx_sort</span><span class="p">,:]</span><span class="o">.</span><span class="n">reset_index</span><span class="p">(</span><span class="n">drop</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
    <span class="n">y_sort</span>  <span class="o">=</span> <span class="n">y</span><span class="p">[</span><span class="n">idx_sort</span><span class="p">]</span>

    <span class="c1">#--- now we can use the &quot;sorted&quot; gose/drs graph construction ---#</span>
    <span class="n">kfn_gose</span> <span class="o">=</span> <span class="n">get_gose_kfn</span><span class="p">(</span><span class="n">df_sort</span><span class="p">,</span><span class="n">n_neighbors</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">S_tbi</span> <span class="o">=</span> <span class="n">make_graph_from_knn</span><span class="p">(</span><span class="n">kfn_gose</span><span class="o">.</span><span class="n">values</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">S</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">n</span><span class="p">,</span><span class="n">n</span><span class="p">))</span>

    <span class="c1"># thanks to the sorting, this S will have block diagonal structure</span>
    <span class="n">S</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ix_</span><span class="p">(</span> <span class="n">y_sort</span><span class="o">==+</span><span class="mi">1</span><span class="p">,</span><span class="n">y_sort</span><span class="o">==+</span><span class="mi">1</span><span class="p">)]</span> <span class="o">=</span> <span class="n">S_tbi</span>

    <span class="c1">#==== undo the sorting ====#</span>
    <span class="n">S</span> <span class="o">=</span> <span class="n">S</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ix_</span><span class="p">(</span><span class="n">rev_sort</span><span class="p">,</span><span class="n">rev_sort</span><span class="p">)]</span>

    <span class="c1"># Laplacian graph</span>
    <span class="n">L</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">S</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">))</span> <span class="o">-</span> <span class="n">S</span>
    <span class="k">return</span> <span class="n">S</span><span class="p">,</span><span class="n">L</span>
<span class="c1">#%%----</span>

<span class="k">def</span> <span class="nf">normalize_W</span><span class="p">(</span><span class="n">W</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Normalize the columns of W to unit norm</span>

<span class="sd">    W : ndarray of shape [p,r]</span>
<span class="sd">        Typically the basis matrix returned from NMF</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">Wnorm</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">W</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
    <span class="kn">from</span> <span class="nn">scipy.linalg</span> <span class="kn">import</span> <span class="n">norm</span>

    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">W</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span>
        <span class="n">Wnorm</span><span class="p">[:,</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">W</span><span class="p">[:,</span><span class="n">i</span><span class="p">]</span> <span class="o">/</span> <span class="n">norm</span><span class="p">(</span><span class="n">W</span><span class="p">[:,</span><span class="n">i</span><span class="p">])</span>

    <span class="k">return</span> <span class="n">Wnorm</span>


<span class="k">def</span> <span class="nf">disp_corrW</span><span class="p">(</span><span class="n">W</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Display correlation matrix of basis matrix W returned from NMF</span>

<span class="sd">    Useful to see how &quot;orthogonal&quot; the learnt basis are.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">Wnorm</span> <span class="o">=</span> <span class="n">normalize_W</span><span class="p">(</span><span class="n">W</span><span class="p">)</span>

    <span class="n">tw</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="s1">&#39;f&#39;</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">subplot</span><span class="p">(</span><span class="mi">131</span><span class="p">),</span><span class="n">tw</span><span class="o">.</span><span class="n">imtak</span><span class="p">(</span><span class="n">W</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">W</span><span class="p">)),</span> <span class="n">plt</span><span class="o">.</span><span class="n">colorbar</span><span class="p">(</span><span class="n">orientation</span><span class="o">=</span><span class="s1">&#39;horizontal&#39;</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">subplot</span><span class="p">(</span><span class="mi">132</span><span class="p">),</span><span class="n">tw</span><span class="o">.</span><span class="n">imtak</span><span class="p">(</span><span class="n">Wnorm</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">Wnorm</span><span class="p">)),</span> <span class="n">plt</span><span class="o">.</span><span class="n">colorbar</span><span class="p">(</span><span class="n">orientation</span><span class="o">=</span><span class="s1">&#39;horizontal&#39;</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">gci</span><span class="p">()</span><span class="o">.</span><span class="n">set_clim</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">))</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">subplot</span><span class="p">(</span><span class="mi">133</span><span class="p">),</span><span class="n">tw</span><span class="o">.</span><span class="n">imtak</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">corrcoef</span><span class="p">(</span><span class="n">W</span><span class="o">.</span><span class="n">T</span><span class="p">)),</span> <span class="n">plt</span><span class="o">.</span><span class="n">colorbar</span><span class="p">(</span><span class="n">orientation</span><span class="o">=</span><span class="s1">&#39;horizontal&#39;</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">gci</span><span class="p">()</span><span class="o">.</span><span class="n">set_clim</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">))</span>
<span class="c1">#    plt.colorbar()</span>


<span class="c1">#%% **** FAILURES ****</span>
<span class="k">def</span> <span class="nf">hinge_pnmf_admm</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="n">rho</span><span class="o">=</span><span class="mf">1e2</span><span class="p">,</span><span class="n">lam</span><span class="o">=</span><span class="mf">1e-1</span><span class="p">,</span><span class="n">gam</span><span class="o">=</span><span class="mf">1e-1</span><span class="p">,</span><span class="n">max_iter</span><span class="o">=</span><span class="mi">5000</span><span class="p">,</span><span class="n">tol</span><span class="o">=</span><span class="mf">1e-4</span><span class="p">,</span>
                    <span class="n">W_init</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span><span class="n">disp_freq</span><span class="o">=</span><span class="mi">2000</span><span class="p">,</span><span class="n">silence</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Supervised Projective NMF with hinge-loss (solved via ADMM)</span>

<span class="sd">    &gt;&gt;&gt; W,P,H,w,Wtil,Ptil,wtil,cost,res = pnmf_admm(X,y,r=10,rho=1e2)</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    X : ndarray of shape =[n_features, n_samples]=[p,n]</span>
<span class="sd">        Data matrix with columns as data points</span>
<span class="sd">    y : array-like, shape = [n_samples]</span>
<span class="sd">        Binary Target vector relative to X (must be +/- 1)</span>
<span class="sd">    r : int</span>
<span class="sd">        Dimension of the embedding space (n_components)</span>
<span class="sd">    lam : float</span>
<span class="sd">        Regularization parameter (amount of emphasis on hinge-loss)</span>
<span class="sd">    gam : float</span>
<span class="sd">        Regularization parameter (classification regularizer)</span>
<span class="sd">    rho : float</span>
<span class="sd">        Augmented Lagrangian parameter</span>
<span class="sd">    max_iter : int</span>
<span class="sd">        max number of iterations</span>
<span class="sd">    tol : float</span>
<span class="sd">        convergence tolerance (on relative change in objective value and</span>
<span class="sd">        all primal residuals)</span>
<span class="sd">    W_init : None (default), rng, or &#39;nndsvd&#39;</span>
<span class="sd">        Way to initialize W (and H).  If ``None`` or ``RandomState object``</span>
<span class="sd">        is supplied, both W and H will be initialized via non-negative</span>
<span class="sd">        random number.  If ``&#39;nndsvd&#39;``, will use deterministic initialization</span>
<span class="sd">        NNDSVD &quot;Non-Negative Double Singular Value Decomposition&quot;, proposed by</span>
<span class="sd">        Boutsidis2008.</span>
<span class="sd">    disp_freq : int</span>
<span class="sd">        Frequency of update display (in iterations)</span>
<span class="sd">    silence : bool</span>
<span class="sd">        If True, don&#39;t print-out convergence detail at the end.</span>

<span class="sd">    Update history</span>
<span class="sd">    --------------</span>
<span class="sd">    **Created 02/02/2016**</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">p</span><span class="p">,</span><span class="n">n</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">shape</span>
    <span class="n">lam</span> <span class="o">*=</span> <span class="mf">1.</span> <span class="c1"># ensure float</span>
    <span class="n">gam</span> <span class="o">*=</span> <span class="mf">1.</span> <span class="c1"># ensure float</span>
    <span class="c1">#%%=== initialize variables =====</span>
    <span class="c1"># define main primal variable W (basis matrix)</span>
    <span class="k">if</span> <span class="n">W_init</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
        <span class="n">W</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="n">p</span><span class="p">,</span><span class="n">r</span><span class="p">)</span>
        <span class="n">W</span> <span class="o">/=</span> <span class="n">norm</span><span class="p">(</span><span class="n">W</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>

        <span class="n">H</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="n">r</span><span class="p">,</span><span class="n">n</span><span class="p">)</span>
        <span class="n">H</span> <span class="o">/=</span> <span class="n">norm</span><span class="p">(</span><span class="n">H</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">W_init</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">RandomState</span><span class="p">):</span>
        <span class="n">rng</span> <span class="o">=</span> <span class="n">W_init</span>

        <span class="n">W</span> <span class="o">=</span> <span class="n">rng</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="n">p</span><span class="p">,</span><span class="n">r</span><span class="p">)</span>
        <span class="n">W</span> <span class="o">/=</span> <span class="n">norm</span><span class="p">(</span><span class="n">W</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>

        <span class="n">H</span> <span class="o">=</span> <span class="n">rng</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="n">r</span><span class="p">,</span><span class="n">n</span><span class="p">)</span>
        <span class="n">H</span> <span class="o">/=</span> <span class="n">norm</span><span class="p">(</span><span class="n">H</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">W_init</span> <span class="o">==</span> <span class="s1">&#39;nndsvd&#39;</span><span class="p">:</span>
<span class="c1">#        W = nnd_svd(X,r)</span>
        <span class="n">W</span><span class="p">,</span><span class="n">H</span> <span class="o">=</span> <span class="n">nnd_svd</span><span class="p">(</span><span class="n">X</span><span class="p">,</span><span class="n">r</span><span class="p">,</span><span class="n">get_H</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Invalid input for &quot;W_init&quot;&#39;</span><span class="p">)</span>

    <span class="n">P</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">r</span><span class="p">,</span><span class="n">p</span><span class="p">))</span>
<span class="c1">#    P = np.random.rand(r,p)</span>

    <span class="c1"># classification weight vector</span>
    <span class="n">w</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">r</span><span class="p">)</span>

    <span class="c1"># aux. variables</span>
    <span class="n">Wtil</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">W</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
    <span class="n">Ptil</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">P</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
    <span class="n">wtil</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>

    <span class="c1"># dual variables</span>
    <span class="n">Lam_W</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">W</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
    <span class="n">Lam_P</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">P</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
    <span class="n">Lam_H</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">H</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
    <span class="n">d_w</span>   <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>

<span class="c1">#    Y = np.diag(y)</span>
    <span class="c1">#%%=== create empty lists for tracking updates ===</span>
    <span class="c1"># keep track of frobenius norm loss</span>
    <span class="n">cost_list</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">cost_recon_list</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">cost_supervised_list</span> <span class="o">=</span> <span class="p">[]</span>
<span class="c1">#    cost = norm(Wtil.dot(Ptil.dot(X)) - X,&#39;fro&#39;)**2/2 + \</span>
<span class="c1">#           lam*np.maximum(0, 1-y*dot(H.T,w)).sum() + norm(gam)**2/2</span>
<span class="c1">#    cost = norm( X - dot(W,P.dot(X)), &#39;fro&#39;)**2/2</span>

    <span class="n">cost_recon</span> <span class="o">=</span> <span class="n">norm</span><span class="p">(</span><span class="n">Wtil</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">Ptil</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">X</span><span class="p">))</span> <span class="o">-</span> <span class="n">X</span><span class="p">,</span><span class="s1">&#39;fro&#39;</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="o">/</span><span class="mi">2</span>
    <span class="n">cost_recon_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">cost_recon</span><span class="p">)</span>

    <span class="n">cost_supervised</span> <span class="o">=</span> <span class="n">lam</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="o">-</span><span class="n">y</span><span class="o">*</span><span class="n">dot</span><span class="p">(</span><span class="n">H</span><span class="o">.</span><span class="n">T</span><span class="p">,</span><span class="n">w</span><span class="p">))</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span> <span class="o">+</span> <span class="n">norm</span><span class="p">(</span><span class="n">gam</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="o">/</span><span class="mi">2</span>
    <span class="n">cost_supervised_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">cost_supervised</span><span class="p">)</span>

    <span class="n">cost</span> <span class="o">=</span> <span class="n">cost_recon</span> <span class="o">+</span> <span class="n">cost_supervised</span>
    <span class="n">cost_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">cost</span><span class="p">)</span>

    <span class="c1"># relative change in cost</span>
    <span class="n">diffcost</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="c1"># precompute term needed for inversion lemma</span>
    <span class="n">K</span> <span class="o">=</span> <span class="n">solve</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="o">+</span> <span class="n">dot</span><span class="p">(</span><span class="n">X</span><span class="o">.</span><span class="n">T</span><span class="p">,</span><span class="n">X</span><span class="p">),</span> <span class="n">X</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>

    <span class="c1"># keep track of relative primal residual</span>
    <span class="n">res_W</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">res_P</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">res_H</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">res_w</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="c1"># also keep track of diffW</span>
<span class="c1">#    diffW = []</span>
    <span class="c1">#%%=== run admm iterations ===</span>
    <span class="n">eye_r</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="n">r</span><span class="p">)</span>

    <span class="c1"># precompute term needed for inversion lemma</span>
    <span class="n">K</span> <span class="o">=</span> <span class="n">solve</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="o">+</span> <span class="n">dot</span><span class="p">(</span><span class="n">X</span><span class="o">.</span><span class="n">T</span><span class="p">,</span><span class="n">X</span><span class="p">),</span> <span class="n">X</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>

    <span class="n">rho_W</span> <span class="o">=</span> <span class="n">rho</span><span class="o">*</span><span class="mi">50000000</span>

    <span class="n">start</span><span class="o">=</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
    <span class="k">for</span> <span class="nb">iter</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">max_iter</span><span class="p">):</span>
<span class="c1">#        rho = min(1e6, rho*1.0001)</span>
<span class="c1">#        W_old = W #&lt;- to keep track of diffW</span>

        <span class="c1">#================ primal updates (P, W, H, Ptil, Wtil) ===============#</span>
        <span class="c1"># update for P involves inversion lemma...</span>


        <span class="c1"># (W,H) updates</span>
        <span class="n">W</span> <span class="o">=</span> <span class="n">solve</span><span class="p">(</span><span class="n">dot</span><span class="p">(</span><span class="n">H</span><span class="p">,</span><span class="n">H</span><span class="o">.</span><span class="n">T</span><span class="p">)</span><span class="o">+</span><span class="n">rho_W</span><span class="o">*</span><span class="n">eye_r</span><span class="p">,</span> <span class="n">dot</span><span class="p">(</span><span class="n">H</span><span class="p">,</span> <span class="n">X</span><span class="o">.</span><span class="n">T</span><span class="p">)</span> <span class="o">+</span> <span class="n">rho_W</span><span class="o">*</span><span class="n">Wtil</span><span class="o">.</span><span class="n">T</span> <span class="o">-</span> <span class="n">Lam_W</span><span class="o">.</span><span class="n">T</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>
        <span class="n">Wtil</span> <span class="o">=</span> <span class="p">(</span><span class="n">W</span><span class="o">+</span><span class="n">Lam_W</span><span class="o">/</span><span class="n">rho_W</span><span class="p">)</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>

        <span class="n">H</span> <span class="o">=</span> <span class="n">solve</span><span class="p">(</span><span class="n">dot</span><span class="p">(</span><span class="n">W</span><span class="o">.</span><span class="n">T</span><span class="p">,</span><span class="n">W</span><span class="p">)</span><span class="o">+</span><span class="n">rho</span><span class="o">*</span><span class="p">(</span><span class="n">eye_r</span><span class="o">+</span><span class="n">np</span><span class="o">.</span><span class="n">outer</span><span class="p">(</span><span class="n">w</span><span class="p">,</span><span class="n">w</span><span class="p">)),</span>
                  <span class="n">dot</span><span class="p">(</span><span class="n">W</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">X</span><span class="p">)</span> <span class="o">-</span> <span class="n">Lam_H</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">outer</span><span class="p">(</span><span class="n">w</span><span class="p">,</span> <span class="p">(</span><span class="n">d_w</span><span class="o">*</span><span class="n">y</span><span class="p">))</span> <span class="o">+</span>
                  <span class="n">rho</span><span class="o">*</span><span class="p">(</span><span class="n">dot</span><span class="p">(</span><span class="n">P</span><span class="p">,</span><span class="n">X</span><span class="p">)</span> <span class="o">+</span> <span class="n">rho</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">outer</span><span class="p">(</span><span class="n">w</span><span class="p">,</span> <span class="p">(</span><span class="n">wtil</span><span class="o">*</span><span class="n">y</span><span class="p">)))</span> <span class="p">)</span>

        <span class="n">_R</span> <span class="o">=</span> <span class="n">dot</span><span class="p">(</span><span class="n">X</span><span class="p">,</span><span class="n">Lam_H</span><span class="o">.</span><span class="n">T</span><span class="p">)</span><span class="o">/</span><span class="n">rho</span> <span class="o">-</span> <span class="n">Lam_P</span><span class="o">.</span><span class="n">T</span><span class="o">/</span><span class="n">rho</span> <span class="o">+</span> <span class="n">dot</span><span class="p">(</span><span class="n">X</span><span class="p">,</span><span class="n">H</span><span class="o">.</span><span class="n">T</span><span class="p">)</span> <span class="o">+</span> <span class="n">Ptil</span><span class="o">.</span><span class="n">T</span>
        <span class="n">P</span> <span class="o">=</span> <span class="p">(</span><span class="n">_R</span> <span class="o">-</span> <span class="n">X</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span> <span class="n">dot</span><span class="p">(</span><span class="n">K</span><span class="p">,</span><span class="n">_R</span><span class="p">)</span> <span class="p">))</span><span class="o">.</span><span class="n">T</span>
        <span class="n">Ptil</span> <span class="o">=</span> <span class="p">(</span><span class="n">P</span><span class="o">+</span><span class="n">Lam_P</span><span class="o">/</span><span class="n">rho</span><span class="p">)</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>

        <span class="c1"># (w,wtil) updates</span>
        <span class="n">w</span> <span class="o">=</span> <span class="n">solve</span><span class="p">(</span> <span class="n">H</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">H</span><span class="o">.</span><span class="n">T</span><span class="p">)</span> <span class="o">+</span> <span class="n">gam</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="n">r</span><span class="p">),</span> <span class="n">H</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span> <span class="o">-</span><span class="n">y</span><span class="o">*</span><span class="n">d_w</span> <span class="o">+</span> <span class="n">rho</span><span class="o">*</span><span class="n">wtil</span><span class="p">)</span> <span class="p">)</span> <span class="o">/</span> <span class="n">rho</span>
        <span class="n">wtil</span> <span class="o">=</span> <span class="n">prox_hinge</span><span class="p">(</span> <span class="n">y</span><span class="o">*</span><span class="n">dot</span><span class="p">(</span><span class="n">H</span><span class="o">.</span><span class="n">T</span><span class="p">,</span><span class="n">w</span><span class="p">)</span> <span class="o">+</span> <span class="n">d_w</span><span class="o">/</span><span class="n">rho</span><span class="p">,</span> <span class="n">lam</span><span class="o">/</span><span class="n">rho</span> <span class="p">)</span>

        <span class="c1">#====================== dual updates =================================#</span>
        <span class="n">Lam_W</span> <span class="o">=</span> <span class="n">Lam_W</span> <span class="o">+</span> <span class="n">rho_W</span><span class="o">*</span><span class="p">(</span><span class="n">W</span> <span class="o">-</span> <span class="n">Wtil</span><span class="p">)</span>
        <span class="n">Lam_P</span> <span class="o">=</span> <span class="n">Lam_P</span> <span class="o">+</span> <span class="n">rho</span><span class="o">*</span><span class="p">(</span><span class="n">P</span> <span class="o">-</span> <span class="n">Ptil</span><span class="p">)</span>
        <span class="n">Lam_H</span> <span class="o">=</span> <span class="n">Lam_H</span> <span class="o">+</span> <span class="n">rho</span><span class="o">*</span><span class="p">(</span><span class="n">H</span> <span class="o">-</span> <span class="n">dot</span><span class="p">(</span><span class="n">P</span><span class="p">,</span><span class="n">X</span><span class="p">))</span>
        <span class="n">d_w</span> <span class="o">=</span> <span class="n">d_w</span> <span class="o">-</span> <span class="n">rho</span><span class="o">*</span><span class="p">(</span><span class="n">wtil</span> <span class="o">-</span> <span class="n">y</span><span class="o">*</span><span class="n">dot</span><span class="p">(</span><span class="n">H</span><span class="o">.</span><span class="n">T</span><span class="p">,</span><span class="n">w</span><span class="p">))</span>

        <span class="c1">#============ comptute objective values ==============================#</span>
        <span class="c1"># main loss function</span>
        <span class="n">cost_recon</span> <span class="o">=</span> <span class="n">norm</span><span class="p">(</span><span class="n">Wtil</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">Ptil</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">X</span><span class="p">))</span> <span class="o">-</span> <span class="n">X</span><span class="p">,</span><span class="s1">&#39;fro&#39;</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="o">/</span><span class="mi">2</span>
        <span class="n">cost_recon_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">cost_recon</span><span class="p">)</span>

        <span class="n">cost_supervised</span> <span class="o">=</span> <span class="n">lam</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="o">-</span><span class="n">y</span><span class="o">*</span><span class="n">dot</span><span class="p">(</span><span class="n">H</span><span class="o">.</span><span class="n">T</span><span class="p">,</span><span class="o">-</span><span class="n">w</span><span class="p">))</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span> <span class="o">+</span> <span class="n">norm</span><span class="p">(</span><span class="n">gam</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="o">/</span><span class="mi">2</span>
        <span class="n">cost_supervised_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">cost_supervised</span><span class="p">)</span>

        <span class="n">cost</span> <span class="o">=</span> <span class="n">cost_recon</span> <span class="o">+</span> <span class="n">cost_supervised</span>
        <span class="n">cost_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">cost</span><span class="p">)</span>

        <span class="c1"># relative change in cost</span>
        <span class="n">diffcost</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">cost_list</span><span class="p">[</span><span class="nb">iter</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">cost_list</span><span class="p">[</span><span class="nb">iter</span><span class="p">])</span><span class="o">/</span><span class="n">cost_list</span><span class="p">[</span><span class="nb">iter</span><span class="p">])</span>

        <span class="c1"># relative primal residuals</span>
        <span class="n">res_W</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">norm</span><span class="p">(</span><span class="n">W</span><span class="o">-</span><span class="n">Wtil</span><span class="p">,</span><span class="s1">&#39;fro&#39;</span><span class="p">)</span><span class="o">/</span><span class="n">norm</span><span class="p">(</span><span class="n">W</span><span class="p">,</span><span class="s1">&#39;fro&#39;</span><span class="p">))</span>
        <span class="n">res_P</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">norm</span><span class="p">(</span><span class="n">P</span><span class="o">-</span><span class="n">Ptil</span><span class="p">,</span><span class="s1">&#39;fro&#39;</span><span class="p">)</span><span class="o">/</span><span class="n">norm</span><span class="p">(</span><span class="n">P</span><span class="p">,</span><span class="s1">&#39;fro&#39;</span><span class="p">))</span>
        <span class="n">res_H</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">norm</span><span class="p">(</span><span class="n">H</span><span class="o">-</span><span class="n">P</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">X</span><span class="p">),</span><span class="s1">&#39;fro&#39;</span><span class="p">)</span><span class="o">/</span><span class="n">norm</span><span class="p">(</span><span class="n">H</span><span class="p">,</span><span class="s1">&#39;fro&#39;</span><span class="p">))</span>
<span class="c1">#        res_w.append(norm(wtil - y*dot(H.T,w))/norm(wtil))</span>
        <span class="n">res_w</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>

        <span class="c1"># relative change in basis matrix</span>
<span class="c1">#        diffW.append( norm(W-W_old,&#39;fro&#39;)/ norm(W_old, &#39;fro&#39;) )</span>

        <span class="c1">#=== termination check ====#</span>
        <span class="n">check_exit</span>  <span class="o">=</span> <span class="p">(</span><span class="n">diffcost</span><span class="p">[</span><span class="nb">iter</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">tol</span><span class="p">)</span>
        <span class="n">check_exit</span> <span class="o">&amp;=</span> <span class="p">(</span><span class="n">res_W</span><span class="p">[</span><span class="nb">iter</span><span class="p">]</span> <span class="o">&lt;</span>  <span class="n">tol</span><span class="p">)</span>
        <span class="n">check_exit</span> <span class="o">&amp;=</span> <span class="p">(</span><span class="n">res_P</span><span class="p">[</span><span class="nb">iter</span><span class="p">]</span> <span class="o">&lt;</span>  <span class="n">tol</span><span class="p">)</span>
        <span class="n">check_exit</span> <span class="o">&amp;=</span> <span class="p">(</span><span class="n">res_H</span><span class="p">[</span><span class="nb">iter</span><span class="p">]</span> <span class="o">&lt;</span>  <span class="n">tol</span><span class="p">)</span>
        <span class="n">check_exit</span> <span class="o">&amp;=</span> <span class="p">(</span><span class="n">res_w</span><span class="p">[</span><span class="nb">iter</span><span class="p">]</span> <span class="o">&lt;</span>  <span class="n">tol</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">check_exit</span> <span class="ow">and</span> <span class="nb">iter</span> <span class="o">&gt;</span> <span class="mi">300</span><span class="p">:</span> <span class="c1"># allow 300 iterations of &quot;burn-in&quot;</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">silence</span><span class="p">:</span>
                <span class="k">print</span> <span class="s2">&quot;Termination condition met.  Exit at iter =&quot;</span><span class="p">,</span><span class="nb">iter</span><span class="p">,</span>
            <span class="k">break</span>
        <span class="c1">#=============== print current progress ==============================#</span>
<span class="c1">#        if iter % disp_freq == 0:</span>
        <span class="k">if</span> <span class="p">(</span><span class="nb">iter</span><span class="o">&gt;-</span><span class="mi">1</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="nb">iter</span> <span class="o">%</span> <span class="n">disp_freq</span> <span class="o">==</span> <span class="mi">0</span><span class="p">):</span>
<span class="c1">#            print rho,</span>
<span class="c1">#            rho = min(1e6, rho*1.05)</span>
<span class="c1">#            str_ = &quot;iter={:4} cost={:3.3f}&quot;.format(iter,cost_list[iter+1])</span>
            <span class="n">str_</span> <span class="o">=</span> <span class="s2">&quot;iter={:4} cost={:6.5e}&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">iter</span><span class="p">,</span><span class="n">cost_list</span><span class="p">[</span><span class="nb">iter</span><span class="o">+</span><span class="mi">1</span><span class="p">])</span>
            <span class="n">str_</span> <span class="o">+=</span> <span class="s2">&quot; costU={:6.5e}&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">cost_recon_list</span><span class="p">[</span><span class="nb">iter</span><span class="o">+</span><span class="mi">1</span><span class="p">])</span>
            <span class="n">str_</span> <span class="o">+=</span> <span class="s2">&quot; costS={:6.5e}&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">cost_supervised_list</span><span class="p">[</span><span class="nb">iter</span><span class="o">+</span><span class="mi">1</span><span class="p">])</span>
            <span class="n">str_</span> <span class="o">+=</span> <span class="s2">&quot; diffcost={:3.2e}&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">diffcost</span><span class="p">[</span><span class="nb">iter</span><span class="p">])</span>
            <span class="n">str_</span> <span class="o">+=</span> <span class="s2">&quot; W={:3.2e}&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">res_W</span><span class="p">[</span><span class="nb">iter</span><span class="p">])</span>
            <span class="n">str_</span> <span class="o">+=</span> <span class="s2">&quot; P={:3.2e}&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">res_P</span><span class="p">[</span><span class="nb">iter</span><span class="p">])</span>
            <span class="n">str_</span> <span class="o">+=</span> <span class="s2">&quot; H={:3.2e}&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">res_H</span><span class="p">[</span><span class="nb">iter</span><span class="p">])</span>
            <span class="n">str_</span> <span class="o">+=</span> <span class="s2">&quot; w={:3.2e}&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">res_w</span><span class="p">[</span><span class="nb">iter</span><span class="p">])</span>
<span class="c1">#            str_ += &quot; diffW={:3.2e}&quot;.format(diffW[iter])</span>
            <span class="k">print</span> <span class="n">str_</span> <span class="o">+</span> <span class="s2">&quot; ({:3.1f} sec)&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span><span class="o">-</span><span class="n">start</span><span class="p">)</span>
    <span class="c1">#%%---- end of admm for loop ---------------------------------------------#</span>
    <span class="n">cost_list</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">cost_list</span><span class="p">)</span>

    <span class="c1"># convert residual in pandas dataframe</span>
    <span class="n">res</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">([</span><span class="n">res_W</span><span class="p">,</span><span class="n">res_P</span><span class="p">,</span><span class="n">res_H</span><span class="p">,</span><span class="n">res_w</span><span class="p">,</span><span class="n">diffcost</span><span class="p">],</span>
                       <span class="n">index</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;res_W&#39;</span><span class="p">,</span><span class="s1">&#39;res_P&#39;</span><span class="p">,</span><span class="s1">&#39;res_H&#39;</span><span class="p">,</span><span class="s1">&#39;res_w&#39;</span><span class="p">,</span><span class="s1">&#39;diffcost&#39;</span><span class="p">])</span><span class="o">.</span><span class="n">T</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">silence</span><span class="p">:</span> <span class="n">print_time</span><span class="p">(</span><span class="n">start</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">W</span><span class="p">,</span><span class="n">P</span><span class="p">,</span><span class="n">H</span><span class="p">,</span><span class="n">w</span><span class="p">,</span><span class="n">Wtil</span><span class="p">,</span><span class="n">Ptil</span><span class="p">,</span><span class="n">cost_list</span><span class="p">,</span><span class="n">res</span>


<span class="k">def</span> <span class="nf">hinge_spnmf_admm</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="n">rho</span><span class="o">=</span><span class="mf">1e2</span><span class="p">,</span><span class="n">lam</span><span class="o">=</span><span class="mf">1e-1</span><span class="p">,</span><span class="n">gam</span><span class="o">=</span><span class="mf">1e-1</span><span class="p">,</span><span class="n">max_iter</span><span class="o">=</span><span class="mi">5000</span><span class="p">,</span><span class="n">tol</span><span class="o">=</span><span class="mf">1e-4</span><span class="p">,</span>
                    <span class="n">W_init</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span><span class="n">disp_freq</span><span class="o">=</span><span class="mi">2000</span><span class="p">,</span><span class="n">silence</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Supervised Projective NMF with hinge-loss (solved via ADMM)</span>

<span class="sd">    &gt;&gt;&gt; W,P,H,w,Wtil,Ptil,wtil,cost,res = pnmf_admm(X,y,r=10,rho=1e2)</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    X : ndarray of shape =[n_features, n_samples]=[p,n]</span>
<span class="sd">        Data matrix with columns as data points</span>
<span class="sd">    y : array-like, shape = [n_samples]</span>
<span class="sd">        Binary Target vector relative to X (must be +/- 1)</span>
<span class="sd">    r : int</span>
<span class="sd">        Dimension of the embedding space (n_components)</span>
<span class="sd">    lam : float</span>
<span class="sd">        Regularization parameter (amount of emphasis on hinge-loss)</span>
<span class="sd">    gam : float</span>
<span class="sd">        Regularization parameter (classification regularizer)</span>
<span class="sd">    rho : float</span>
<span class="sd">        Augmented Lagrangian parameter</span>
<span class="sd">    max_iter : int</span>
<span class="sd">        max number of iterations</span>
<span class="sd">    tol : float</span>
<span class="sd">        convergence tolerance (on relative change in objective value and</span>
<span class="sd">        all primal residuals)</span>
<span class="sd">    W_init : None (default), rng, or &#39;nndsvd&#39;</span>
<span class="sd">        Way to initialize W (and H).  If ``None`` or ``RandomState object``</span>
<span class="sd">        is supplied, both W and H will be initialized via non-negative</span>
<span class="sd">        random number.  If ``&#39;nndsvd&#39;``, will use deterministic initialization</span>
<span class="sd">        NNDSVD &quot;Non-Negative Double Singular Value Decomposition&quot;, proposed by</span>
<span class="sd">        Boutsidis2008.</span>
<span class="sd">    disp_freq : int</span>
<span class="sd">        Frequency of update display (in iterations)</span>
<span class="sd">    silence : bool</span>
<span class="sd">        If True, don&#39;t print-out convergence detail at the end.</span>

<span class="sd">    Update history</span>
<span class="sd">    --------------</span>
<span class="sd">    **Created 02/02/2016**</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">p</span><span class="p">,</span><span class="n">n</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">shape</span>
    <span class="n">lam</span> <span class="o">*=</span> <span class="mf">1.</span> <span class="c1"># ensure float</span>
    <span class="n">gam</span> <span class="o">*=</span> <span class="mf">1.</span> <span class="c1"># ensure float</span>
    <span class="c1">#%%=== initialize variables =====</span>
    <span class="c1"># define main primal variable W (basis matrix)</span>
    <span class="k">if</span> <span class="n">W_init</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
        <span class="n">W</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="n">p</span><span class="p">,</span><span class="n">r</span><span class="p">)</span>
        <span class="n">W</span> <span class="o">/=</span> <span class="n">norm</span><span class="p">(</span><span class="n">W</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>

        <span class="n">H</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="n">r</span><span class="p">,</span><span class="n">n</span><span class="p">)</span>
        <span class="n">H</span> <span class="o">/=</span> <span class="n">norm</span><span class="p">(</span><span class="n">H</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">W_init</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">RandomState</span><span class="p">):</span>
        <span class="n">rng</span> <span class="o">=</span> <span class="n">W_init</span>

        <span class="n">W</span> <span class="o">=</span> <span class="n">rng</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="n">p</span><span class="p">,</span><span class="n">r</span><span class="p">)</span>
        <span class="n">W</span> <span class="o">/=</span> <span class="n">norm</span><span class="p">(</span><span class="n">W</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>

        <span class="n">H</span> <span class="o">=</span> <span class="n">rng</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="n">r</span><span class="p">,</span><span class="n">n</span><span class="p">)</span>
        <span class="n">H</span> <span class="o">/=</span> <span class="n">norm</span><span class="p">(</span><span class="n">H</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">W_init</span> <span class="o">==</span> <span class="s1">&#39;nndsvd&#39;</span><span class="p">:</span>
<span class="c1">#        W = nnd_svd(X,r)</span>
        <span class="n">W</span><span class="p">,</span><span class="n">H</span> <span class="o">=</span> <span class="n">nnd_svd</span><span class="p">(</span><span class="n">X</span><span class="p">,</span><span class="n">r</span><span class="p">,</span><span class="n">get_H</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Invalid input for &quot;W_init&quot;&#39;</span><span class="p">)</span>

<span class="c1">#    P = np.zeros((r,p))</span>
    <span class="n">P</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="n">r</span><span class="p">,</span><span class="n">p</span><span class="p">)</span>

    <span class="c1"># classification weight vector</span>
    <span class="n">w</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">r</span><span class="p">)</span>

    <span class="c1"># aux. variables</span>
    <span class="n">Wtil</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">W</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
    <span class="n">W2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">W</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
    <span class="n">Ptil</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">P</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
    <span class="n">wtil</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
    <span class="n">wtil</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>

    <span class="c1"># dual variables</span>
    <span class="n">Lam_W</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">W</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
    <span class="n">Lam_W2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">W</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
    <span class="n">Lam_P</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">P</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
    <span class="n">Lam_H</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">H</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
    <span class="n">d_w</span>   <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>

<span class="c1">#    Y = np.diag(y)</span>
    <span class="c1">#%%=== create empty lists for tracking updates ===</span>
    <span class="c1"># keep track of frobenius norm loss</span>
    <span class="n">cost_list</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">cost_recon_list</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">cost_supervised_list</span> <span class="o">=</span> <span class="p">[]</span>
<span class="c1">#    cost = norm(Wtil.dot(Ptil.dot(X)) - X,&#39;fro&#39;)**2/2 + \</span>
<span class="c1">#           lam*np.maximum(0, 1-y*dot(H.T,w)).sum() + norm(gam)**2/2</span>
<span class="c1">#    cost = norm( X - dot(W,P.dot(X)), &#39;fro&#39;)**2/2</span>

    <span class="n">cost_recon</span> <span class="o">=</span> <span class="n">norm</span><span class="p">(</span><span class="n">Wtil</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">Ptil</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">X</span><span class="p">))</span> <span class="o">-</span> <span class="n">X</span><span class="p">,</span><span class="s1">&#39;fro&#39;</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="o">/</span><span class="mi">2</span>
    <span class="n">cost_recon_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">cost_recon</span><span class="p">)</span>

    <span class="n">cost_supervised</span> <span class="o">=</span> <span class="n">lam</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="o">-</span><span class="n">y</span><span class="o">*</span><span class="n">dot</span><span class="p">(</span><span class="n">H</span><span class="o">.</span><span class="n">T</span><span class="p">,</span><span class="n">w</span><span class="p">))</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span> <span class="o">+</span> <span class="n">norm</span><span class="p">(</span><span class="n">gam</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="o">/</span><span class="mi">2</span>
    <span class="n">cost_supervised_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">cost_supervised</span><span class="p">)</span>

    <span class="n">cost</span> <span class="o">=</span> <span class="n">cost_recon</span> <span class="o">+</span> <span class="n">cost_supervised</span>
    <span class="n">cost_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">cost</span><span class="p">)</span>

    <span class="c1"># relative change in cost</span>
    <span class="n">diffcost</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="c1"># keep track of relative primal residual</span>
    <span class="n">res_W</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">res_W2</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">res_P</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">res_H</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">res_w</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="c1"># also keep track of diffW</span>
<span class="c1">#    diffW = []</span>
    <span class="c1">#%%=== run admm iterations ===</span>
    <span class="n">eye_r</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="n">r</span><span class="p">)</span>

    <span class="c1"># precompute term needed for inversion lemma</span>
    <span class="n">K</span> <span class="o">=</span> <span class="n">solve</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="o">+</span> <span class="n">dot</span><span class="p">(</span><span class="n">X</span><span class="o">.</span><span class="n">T</span><span class="p">,</span><span class="n">X</span><span class="p">),</span> <span class="n">X</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>
    <span class="n">rho_W</span> <span class="o">=</span> <span class="n">rho</span><span class="o">*</span><span class="mf">5e5</span>
    <span class="n">rho_W2</span> <span class="o">=</span> <span class="n">rho</span><span class="o">*</span><span class="mf">5e5</span>
    <span class="n">start</span><span class="o">=</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
    <span class="k">for</span> <span class="nb">iter</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">max_iter</span><span class="p">):</span>
<span class="c1">#        rho = min(1e6, rho*1.0001)</span>
<span class="c1">#        W_old = W #&lt;- to keep track of diffW</span>
        <span class="c1"># (W,H) updates</span>
        <span class="n">W</span> <span class="o">=</span> <span class="n">solve</span><span class="p">(</span><span class="n">dot</span><span class="p">(</span><span class="n">H</span><span class="p">,</span><span class="n">H</span><span class="o">.</span><span class="n">T</span><span class="p">)</span><span class="o">+</span><span class="p">(</span><span class="n">rho_W</span><span class="o">+</span><span class="n">rho</span><span class="p">)</span><span class="o">*</span><span class="n">eye_r</span><span class="p">,</span>
                  <span class="n">dot</span><span class="p">(</span><span class="n">H</span><span class="p">,</span> <span class="n">X</span><span class="o">.</span><span class="n">T</span><span class="p">)</span> <span class="o">+</span> <span class="n">rho_W</span><span class="o">*</span><span class="n">Wtil</span><span class="o">.</span><span class="n">T</span> <span class="o">-</span> <span class="n">Lam_W</span><span class="o">.</span><span class="n">T</span> <span class="o">-</span> <span class="n">Lam_W2</span><span class="o">.</span><span class="n">T</span> <span class="o">+</span> <span class="n">rho</span><span class="o">*</span><span class="n">W2</span><span class="o">.</span><span class="n">T</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>
        <span class="n">Wtil</span> <span class="o">=</span> <span class="p">(</span><span class="n">W</span><span class="o">+</span><span class="n">Lam_W</span><span class="o">/</span><span class="n">rho_W</span><span class="p">)</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        <span class="c1">#================ primal updates (P, W, H, Ptil, Wtil) ===============#</span>
        <span class="c1"># update for P involves inversion lemma...</span>
        <span class="n">_R</span> <span class="o">=</span> <span class="n">dot</span><span class="p">(</span><span class="n">X</span><span class="p">,</span><span class="n">Lam_H</span><span class="o">.</span><span class="n">T</span><span class="p">)</span><span class="o">/</span><span class="n">rho</span> <span class="o">-</span> <span class="n">Lam_P</span><span class="o">.</span><span class="n">T</span><span class="o">/</span><span class="n">rho</span> <span class="o">+</span> <span class="n">dot</span><span class="p">(</span><span class="n">X</span><span class="p">,</span><span class="n">H</span><span class="o">.</span><span class="n">T</span><span class="p">)</span> <span class="o">+</span> <span class="n">Ptil</span><span class="o">.</span><span class="n">T</span>
        <span class="n">P</span> <span class="o">=</span> <span class="p">(</span><span class="n">_R</span> <span class="o">-</span> <span class="n">X</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span> <span class="n">dot</span><span class="p">(</span><span class="n">K</span><span class="p">,</span><span class="n">_R</span><span class="p">)</span> <span class="p">))</span><span class="o">.</span><span class="n">T</span>
        <span class="n">Ptil</span> <span class="o">=</span> <span class="p">(</span><span class="n">P</span><span class="o">+</span><span class="n">Lam_P</span><span class="o">/</span><span class="n">rho</span><span class="p">)</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>


        <span class="n">W2</span> <span class="o">=</span> <span class="n">projection_spectral</span><span class="p">(</span><span class="n">W</span><span class="o">+</span><span class="n">Lam_W2</span><span class="o">/</span><span class="n">rho</span><span class="p">)</span>

        <span class="n">H</span> <span class="o">=</span> <span class="n">solve</span><span class="p">(</span><span class="n">dot</span><span class="p">(</span><span class="n">W</span><span class="o">.</span><span class="n">T</span><span class="p">,</span><span class="n">W</span><span class="p">)</span><span class="o">+</span><span class="n">rho</span><span class="o">*</span><span class="p">(</span><span class="n">eye_r</span><span class="o">+</span><span class="n">np</span><span class="o">.</span><span class="n">outer</span><span class="p">(</span><span class="n">w</span><span class="p">,</span><span class="n">w</span><span class="p">)),</span>
                  <span class="n">dot</span><span class="p">(</span><span class="n">W</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">X</span><span class="p">)</span> <span class="o">-</span> <span class="n">Lam_H</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">outer</span><span class="p">(</span><span class="n">w</span><span class="p">,</span> <span class="p">(</span><span class="n">d_w</span><span class="o">*</span><span class="n">y</span><span class="p">))</span> <span class="o">+</span>
                  <span class="n">rho</span><span class="o">*</span><span class="p">(</span><span class="n">dot</span><span class="p">(</span><span class="n">P</span><span class="p">,</span><span class="n">X</span><span class="p">)</span> <span class="o">+</span> <span class="n">rho</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">outer</span><span class="p">(</span><span class="n">w</span><span class="p">,</span> <span class="p">(</span><span class="n">wtil</span><span class="o">*</span><span class="n">y</span><span class="p">)))</span> <span class="p">)</span>

        <span class="c1"># (w,wtil) updates</span>
        <span class="n">w</span> <span class="o">=</span> <span class="n">solve</span><span class="p">(</span> <span class="n">H</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">H</span><span class="o">.</span><span class="n">T</span><span class="p">)</span> <span class="o">+</span> <span class="n">gam</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="n">r</span><span class="p">),</span> <span class="n">H</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span> <span class="o">-</span><span class="n">y</span><span class="o">*</span><span class="n">d_w</span> <span class="o">+</span> <span class="n">rho</span><span class="o">*</span><span class="n">wtil</span><span class="p">)</span> <span class="p">)</span> <span class="o">/</span> <span class="n">rho</span>
        <span class="n">wtil</span> <span class="o">=</span> <span class="n">prox_hinge</span><span class="p">(</span> <span class="n">y</span><span class="o">*</span><span class="n">dot</span><span class="p">(</span><span class="n">H</span><span class="o">.</span><span class="n">T</span><span class="p">,</span><span class="n">w</span><span class="p">)</span> <span class="o">+</span> <span class="n">d_w</span><span class="o">/</span><span class="n">rho</span><span class="p">,</span> <span class="n">lam</span><span class="o">/</span><span class="n">rho</span> <span class="p">)</span>

        <span class="c1">#====================== dual updates =================================#</span>
        <span class="n">Lam_W</span> <span class="o">=</span> <span class="n">Lam_W</span> <span class="o">+</span> <span class="n">rho_W</span><span class="o">*</span><span class="p">(</span><span class="n">W</span> <span class="o">-</span> <span class="n">Wtil</span><span class="p">)</span>
        <span class="n">Lam_W2</span> <span class="o">=</span> <span class="n">Lam_W2</span> <span class="o">-</span> <span class="n">rho</span><span class="o">*</span><span class="p">(</span><span class="n">W</span> <span class="o">-</span> <span class="n">W2</span><span class="p">)</span>
        <span class="n">Lam_P</span> <span class="o">=</span> <span class="n">Lam_P</span> <span class="o">+</span> <span class="n">rho</span><span class="o">*</span><span class="p">(</span><span class="n">P</span> <span class="o">-</span> <span class="n">Ptil</span><span class="p">)</span>
        <span class="n">Lam_H</span> <span class="o">=</span> <span class="n">Lam_H</span> <span class="o">+</span> <span class="n">rho</span><span class="o">*</span><span class="p">(</span><span class="n">H</span> <span class="o">-</span> <span class="n">dot</span><span class="p">(</span><span class="n">P</span><span class="p">,</span><span class="n">X</span><span class="p">))</span>
        <span class="n">d_w</span> <span class="o">=</span> <span class="n">d_w</span> <span class="o">-</span> <span class="n">rho</span><span class="o">*</span><span class="p">(</span><span class="n">wtil</span> <span class="o">-</span> <span class="n">y</span><span class="o">*</span><span class="n">dot</span><span class="p">(</span><span class="n">H</span><span class="o">.</span><span class="n">T</span><span class="p">,</span><span class="n">w</span><span class="p">))</span>

        <span class="c1">#============ comptute objective values ==============================#</span>
        <span class="c1"># main loss function</span>
        <span class="n">cost_recon</span> <span class="o">=</span> <span class="n">norm</span><span class="p">(</span><span class="n">Wtil</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">Ptil</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">X</span><span class="p">))</span> <span class="o">-</span> <span class="n">X</span><span class="p">,</span><span class="s1">&#39;fro&#39;</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="o">/</span><span class="mi">2</span>
        <span class="n">cost_recon_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">cost_recon</span><span class="p">)</span>

        <span class="n">cost_supervised</span> <span class="o">=</span> <span class="n">lam</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="o">-</span><span class="n">y</span><span class="o">*</span><span class="n">dot</span><span class="p">(</span><span class="n">H</span><span class="o">.</span><span class="n">T</span><span class="p">,</span><span class="o">-</span><span class="n">w</span><span class="p">))</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span> <span class="o">+</span> <span class="n">norm</span><span class="p">(</span><span class="n">gam</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="o">/</span><span class="mi">2</span>
        <span class="n">cost_supervised_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">cost_supervised</span><span class="p">)</span>

        <span class="n">cost</span> <span class="o">=</span> <span class="n">cost_recon</span> <span class="o">+</span> <span class="n">cost_supervised</span>
        <span class="n">cost_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">cost</span><span class="p">)</span>

        <span class="c1"># relative change in cost</span>
        <span class="n">diffcost</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">cost_list</span><span class="p">[</span><span class="nb">iter</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">cost_list</span><span class="p">[</span><span class="nb">iter</span><span class="p">])</span><span class="o">/</span><span class="n">cost_list</span><span class="p">[</span><span class="nb">iter</span><span class="p">])</span>

        <span class="c1"># relative primal residuals</span>
        <span class="n">res_W</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">norm</span><span class="p">(</span><span class="n">W</span><span class="o">-</span><span class="n">Wtil</span><span class="p">,</span><span class="s1">&#39;fro&#39;</span><span class="p">)</span><span class="o">/</span><span class="n">norm</span><span class="p">(</span><span class="n">W</span><span class="p">,</span><span class="s1">&#39;fro&#39;</span><span class="p">))</span>
        <span class="n">res_W2</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">norm</span><span class="p">(</span><span class="n">W2</span><span class="o">-</span><span class="n">Wtil</span><span class="p">,</span><span class="s1">&#39;fro&#39;</span><span class="p">)</span><span class="o">/</span><span class="n">norm</span><span class="p">(</span><span class="n">W</span><span class="p">,</span><span class="s1">&#39;fro&#39;</span><span class="p">))</span>
        <span class="n">res_P</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">norm</span><span class="p">(</span><span class="n">P</span><span class="o">-</span><span class="n">Ptil</span><span class="p">,</span><span class="s1">&#39;fro&#39;</span><span class="p">)</span><span class="o">/</span><span class="n">norm</span><span class="p">(</span><span class="n">P</span><span class="p">,</span><span class="s1">&#39;fro&#39;</span><span class="p">))</span>
        <span class="n">res_H</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">norm</span><span class="p">(</span><span class="n">H</span><span class="o">-</span><span class="n">P</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">X</span><span class="p">),</span><span class="s1">&#39;fro&#39;</span><span class="p">)</span><span class="o">/</span><span class="n">norm</span><span class="p">(</span><span class="n">H</span><span class="p">,</span><span class="s1">&#39;fro&#39;</span><span class="p">))</span>
        <span class="n">res_w</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">norm</span><span class="p">(</span><span class="n">wtil</span> <span class="o">-</span> <span class="n">y</span><span class="o">*</span><span class="n">dot</span><span class="p">(</span><span class="n">H</span><span class="o">.</span><span class="n">T</span><span class="p">,</span><span class="n">w</span><span class="p">))</span><span class="o">/</span><span class="n">norm</span><span class="p">(</span><span class="n">wtil</span><span class="p">))</span>
<span class="c1">#        res_w.append(0)</span>

        <span class="c1"># relative change in basis matrix</span>
<span class="c1">#        diffW.append( norm(W-W_old,&#39;fro&#39;)/ norm(W_old, &#39;fro&#39;) )</span>

        <span class="c1">#=== termination check ====#</span>
        <span class="n">check_exit</span>  <span class="o">=</span> <span class="p">(</span><span class="n">diffcost</span><span class="p">[</span><span class="nb">iter</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">tol</span><span class="p">)</span>
        <span class="n">check_exit</span> <span class="o">&amp;=</span> <span class="p">(</span><span class="n">res_W</span><span class="p">[</span><span class="nb">iter</span><span class="p">]</span> <span class="o">&lt;</span>  <span class="n">tol</span><span class="p">)</span>
        <span class="n">check_exit</span> <span class="o">&amp;=</span> <span class="p">(</span><span class="n">res_P</span><span class="p">[</span><span class="nb">iter</span><span class="p">]</span> <span class="o">&lt;</span>  <span class="n">tol</span><span class="p">)</span>
        <span class="n">check_exit</span> <span class="o">&amp;=</span> <span class="p">(</span><span class="n">res_H</span><span class="p">[</span><span class="nb">iter</span><span class="p">]</span> <span class="o">&lt;</span>  <span class="n">tol</span><span class="p">)</span>
        <span class="n">check_exit</span> <span class="o">&amp;=</span> <span class="p">(</span><span class="n">res_w</span><span class="p">[</span><span class="nb">iter</span><span class="p">]</span> <span class="o">&lt;</span>  <span class="n">tol</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">check_exit</span> <span class="ow">and</span> <span class="nb">iter</span> <span class="o">&gt;</span> <span class="mi">300</span><span class="p">:</span> <span class="c1"># allow 300 iterations of &quot;burn-in&quot;</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">silence</span><span class="p">:</span>
                <span class="k">print</span> <span class="s2">&quot;Termination condition met.  Exit at iter =&quot;</span><span class="p">,</span><span class="nb">iter</span><span class="p">,</span>
            <span class="k">break</span>
        <span class="c1">#=============== print current progress ==============================#</span>
<span class="c1">#        if iter % disp_freq == 0:</span>
        <span class="k">if</span> <span class="p">(</span><span class="nb">iter</span><span class="o">&gt;-</span><span class="mi">1</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="nb">iter</span> <span class="o">%</span> <span class="n">disp_freq</span> <span class="o">==</span> <span class="mi">0</span><span class="p">):</span>
<span class="c1">#            print rho,</span>
<span class="c1">#            rho = min(1e6, rho*1.05)</span>
<span class="c1">#            str_ = &quot;iter={:4} cost={:3.3f}&quot;.format(iter,cost_list[iter+1])</span>
            <span class="n">str_</span> <span class="o">=</span> <span class="s2">&quot;iter={:4} cost={:6.5e}&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">iter</span><span class="p">,</span><span class="n">cost_list</span><span class="p">[</span><span class="nb">iter</span><span class="o">+</span><span class="mi">1</span><span class="p">])</span>
            <span class="n">str_</span> <span class="o">+=</span> <span class="s2">&quot; costU={:6.5e}&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">cost_recon_list</span><span class="p">[</span><span class="nb">iter</span><span class="o">+</span><span class="mi">1</span><span class="p">])</span>
            <span class="n">str_</span> <span class="o">+=</span> <span class="s2">&quot; costS={:6.5e}&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">cost_supervised_list</span><span class="p">[</span><span class="nb">iter</span><span class="o">+</span><span class="mi">1</span><span class="p">])</span>
            <span class="n">str_</span> <span class="o">+=</span> <span class="s2">&quot; diffcost={:3.2e}&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">diffcost</span><span class="p">[</span><span class="nb">iter</span><span class="p">])</span>
            <span class="n">str_</span> <span class="o">+=</span> <span class="s2">&quot; W={:3.2e}&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">res_W</span><span class="p">[</span><span class="nb">iter</span><span class="p">])</span>
            <span class="n">str_</span> <span class="o">+=</span> <span class="s2">&quot; W2={:3.2e}&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">res_W2</span><span class="p">[</span><span class="nb">iter</span><span class="p">])</span>
            <span class="n">str_</span> <span class="o">+=</span> <span class="s2">&quot; P={:3.2e}&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">res_P</span><span class="p">[</span><span class="nb">iter</span><span class="p">])</span>
            <span class="n">str_</span> <span class="o">+=</span> <span class="s2">&quot; H={:3.2e}&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">res_H</span><span class="p">[</span><span class="nb">iter</span><span class="p">])</span>
            <span class="n">str_</span> <span class="o">+=</span> <span class="s2">&quot; w={:3.2e}&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">res_w</span><span class="p">[</span><span class="nb">iter</span><span class="p">])</span>
<span class="c1">#            str_ += &quot; diffW={:3.2e}&quot;.format(diffW[iter])</span>
            <span class="k">print</span> <span class="n">str_</span> <span class="o">+</span> <span class="s2">&quot; ({:3.1f} sec)&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span><span class="o">-</span><span class="n">start</span><span class="p">)</span>
    <span class="c1">#%%---- end of admm for loop ---------------------------------------------#</span>
    <span class="n">cost_list</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">cost_list</span><span class="p">)</span>

    <span class="c1"># convert residual in pandas dataframe</span>
    <span class="n">res</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">([</span><span class="n">res_W</span><span class="p">,</span><span class="n">res_P</span><span class="p">,</span><span class="n">res_H</span><span class="p">,</span><span class="n">res_w</span><span class="p">,</span><span class="n">diffcost</span><span class="p">],</span>
                       <span class="n">index</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;res_W&#39;</span><span class="p">,</span><span class="s1">&#39;res_P&#39;</span><span class="p">,</span><span class="s1">&#39;res_H&#39;</span><span class="p">,</span><span class="s1">&#39;res_w&#39;</span><span class="p">,</span><span class="s1">&#39;diffcost&#39;</span><span class="p">])</span><span class="o">.</span><span class="n">T</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">silence</span><span class="p">:</span> <span class="n">print_time</span><span class="p">(</span><span class="n">start</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">W</span><span class="p">,</span><span class="n">P</span><span class="p">,</span><span class="n">H</span><span class="p">,</span><span class="n">w</span><span class="p">,</span><span class="n">Wtil</span><span class="p">,</span><span class="n">Ptil</span><span class="p">,</span><span class="n">cost_list</span><span class="p">,</span><span class="n">res</span>


<span class="c1">#%%=== label constraint method that didn&#39;t turnout so useful ====</span>
<span class="k">def</span> <span class="nf">lc_spnmf_admm</span><span class="p">(</span><span class="n">X</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">r</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span><span class="n">alpha</span><span class="o">=</span><span class="mf">1e-1</span><span class="p">,</span><span class="n">constraint</span><span class="o">=</span><span class="s1">&#39;stiefel&#39;</span><span class="p">,</span><span class="n">rho</span><span class="o">=</span><span class="mf">1e3</span><span class="p">,</span><span class="n">max_iter</span><span class="o">=</span><span class="mi">5000</span><span class="p">,</span>
                  <span class="n">tol</span><span class="o">=</span><span class="mf">1e-4</span><span class="p">,</span><span class="n">W_init</span><span class="o">=</span><span class="s1">&#39;nndsvd&#39;</span><span class="p">,</span><span class="n">disp_freq</span><span class="o">=</span><span class="mi">1000</span><span class="p">,</span><span class="n">silence</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Label constrained Spectral Projective NMF using ADMM.</span>

<span class="sd">    **LC** Idea from 2011 Z. Jiang (CVPR) - Learning a discriminative</span>
<span class="sd">    dictionary for sparse coding via label constrained k-svd</span>

<span class="sd">    Usage</span>
<span class="sd">    -----</span>
<span class="sd">    &gt;&gt;&gt; W,P,H,Wtil,Ptil,A,cost,res = lc_spnmf_admm(....)</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    X : ndarray of shape (n_features, n_samples)=(p,n)</span>
<span class="sd">        Data matrix with columns as data points</span>
<span class="sd">    y : array-like of shape [n_samples,]</span>
<span class="sd">        Label vector</span>
<span class="sd">    r : int (must be even for this LC-approach)</span>
<span class="sd">        Dimension of the embedding space (n_components)</span>
<span class="sd">    alpha : float</span>
<span class="sd">        Regularization for discriminative code</span>
<span class="sd">    constraint : ``&#39;stiefel&#39;`` or ``&#39;convex&#39;``</span>
<span class="sd">        The type of spectral constraint (default: ``&#39;stiefel&#39;``).  This</span>
<span class="sd">        determines the type of spectral projection applied.</span>
<span class="sd">    rho : float</span>
<span class="sd">        Augmented Lagrangian parameter</span>
<span class="sd">    max_iter : int</span>
<span class="sd">        max number of iterations</span>
<span class="sd">    tol : float</span>
<span class="sd">        convergence tolerance (on relative change in objective value and</span>
<span class="sd">        all primal residuals)</span>
<span class="sd">    W_init : None, rng, or &#39;nndsvd&#39; (default)</span>
<span class="sd">        Way to initialize W (and H).  If ``None`` or ``RandomState object``</span>
<span class="sd">        is supplied, both W and H will be initialized via non-negative</span>
<span class="sd">        random number.  If ``&#39;nndsvd&#39;``, will use deterministic initialization</span>
<span class="sd">        NNDSVD &quot;Non-Negative Double Singular Value Decomposition&quot;, proposed by</span>
<span class="sd">        Boutsidis2008.</span>
<span class="sd">    disp_freq : int</span>
<span class="sd">        Frequency of update display (in iterations)</span>
<span class="sd">    silence : bool</span>
<span class="sd">        If True, don&#39;t print-out convergence detail at the end.</span>

<span class="sd">    History</span>
<span class="sd">    --------------</span>
<span class="sd">    **02/08/2016** - function created (forked from ``spnmf_admm``)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">p</span><span class="p">,</span><span class="n">n</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">shape</span>
    <span class="n">alpha</span> <span class="o">*=</span> <span class="mf">1.0</span>
    <span class="n">rho</span> <span class="o">*=</span> <span class="mf">1.0</span>
    <span class="k">if</span> <span class="n">r</span><span class="o">%</span><span class="mi">2</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;r must be an even integer&quot;</span><span class="p">)</span>
    <span class="c1">#%%=== initialize variables =====</span>
    <span class="k">if</span> <span class="n">W_init</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
        <span class="n">W</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="n">p</span><span class="p">,</span><span class="n">r</span><span class="p">)</span>
        <span class="n">W</span> <span class="o">/=</span> <span class="n">norm</span><span class="p">(</span><span class="n">W</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>

        <span class="n">H</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="n">r</span><span class="p">,</span><span class="n">n</span><span class="p">)</span>
        <span class="n">H</span> <span class="o">/=</span> <span class="n">norm</span><span class="p">(</span><span class="n">H</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">W_init</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">RandomState</span><span class="p">):</span>
        <span class="n">rng</span> <span class="o">=</span> <span class="n">W_init</span>

        <span class="n">W</span> <span class="o">=</span> <span class="n">rng</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="n">p</span><span class="p">,</span><span class="n">r</span><span class="p">)</span>
        <span class="n">W</span> <span class="o">/=</span> <span class="n">norm</span><span class="p">(</span><span class="n">W</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>

        <span class="n">H</span> <span class="o">=</span> <span class="n">rng</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="n">r</span><span class="p">,</span><span class="n">n</span><span class="p">)</span>
        <span class="n">H</span> <span class="o">/=</span> <span class="n">norm</span><span class="p">(</span><span class="n">H</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">W_init</span> <span class="o">==</span> <span class="s1">&#39;nndsvd&#39;</span><span class="p">:</span>
<span class="c1">#        W = nnd_svd(X,r)</span>
        <span class="n">W</span><span class="p">,</span><span class="n">H</span> <span class="o">=</span> <span class="n">nnd_svd</span><span class="p">(</span><span class="n">X</span><span class="p">,</span><span class="n">r</span><span class="p">,</span><span class="n">get_H</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Invalid input for &quot;W_init&quot;&#39;</span><span class="p">)</span>

    <span class="n">P</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">r</span><span class="p">,</span><span class="n">p</span><span class="p">))</span>
<span class="c1">#    P = np.random.rand(r,p)</span>

    <span class="c1"># aux. variables</span>
    <span class="n">W1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">W</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
    <span class="n">W2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">W</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
    <span class="n">Ptil</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">P</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>

    <span class="c1"># dual variables</span>
    <span class="n">Lam_W1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">W</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
    <span class="n">Lam_W2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">W</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
    <span class="n">Lam_P</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">P</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
    <span class="n">Lam_H</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">H</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>

    <span class="c1">#--- variables for LC approach ---#</span>
    <span class="c1"># linear transformation matrix that parametrizes LC</span>
    <span class="n">A</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">r</span><span class="p">,</span><span class="n">r</span><span class="p">))</span>

    <span class="c1"># get discriminative codes</span>
    <span class="n">Q</span> <span class="o">=</span> <span class="n">get_discriminative_codes</span><span class="p">(</span><span class="n">y</span><span class="p">,</span><span class="n">r</span><span class="p">)</span>
    <span class="c1">#%%=== create empty lists for tracking updates ===</span>
    <span class="c1"># keep track of frobenius norm loss</span>
    <span class="n">cost_list</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">cost_nmf_list</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">cost_LC_list</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="n">cost_nmf</span> <span class="o">=</span> <span class="n">norm</span><span class="p">(</span><span class="n">W1</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">Ptil</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">X</span><span class="p">))</span> <span class="o">-</span> <span class="n">X</span><span class="p">,</span><span class="s1">&#39;fro&#39;</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="o">/</span><span class="mi">2</span>
    <span class="n">cost_LC</span> <span class="o">=</span> <span class="n">alpha</span><span class="o">*</span><span class="n">norm</span><span class="p">(</span> <span class="n">Q</span> <span class="o">-</span> <span class="n">A</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">H</span><span class="p">),</span> <span class="s1">&#39;fro&#39;</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="o">/</span><span class="mi">2</span>
    <span class="n">cost</span> <span class="o">=</span> <span class="n">cost_nmf</span> <span class="o">+</span> <span class="n">cost_LC</span>

    <span class="n">cost_nmf_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">cost_nmf</span><span class="p">)</span>
    <span class="n">cost_LC_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">cost_LC</span><span class="p">)</span>
    <span class="n">cost_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">cost</span><span class="p">)</span>

    <span class="c1"># relative change in cost</span>
    <span class="n">diffcost</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="c1"># keep track of relative primal residual</span>
    <span class="n">res_W1</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">res_W2</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">res_P</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">res_H</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="c1"># also keep track of diffW</span>
<span class="c1">#    diffW = []</span>
    <span class="c1">#%%=== run admm iterations ===</span>
    <span class="n">eye_r</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="n">r</span><span class="p">)</span>

    <span class="c1"># precompute term needed for inversion lemma</span>
    <span class="n">K</span> <span class="o">=</span> <span class="n">solve</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="o">+</span> <span class="n">dot</span><span class="p">(</span><span class="n">X</span><span class="o">.</span><span class="n">T</span><span class="p">,</span><span class="n">X</span><span class="p">),</span> <span class="n">X</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>



    <span class="n">start</span><span class="o">=</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
    <span class="k">for</span> <span class="nb">iter</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">max_iter</span><span class="p">):</span>
<span class="c1">#        W_old = W #&lt;- to keep track of diffW</span>

        <span class="c1">#================ primal updates (P, W, H, Ptil, Wtil) ===============#</span>
        <span class="c1"># update for P involves inversion lemma...</span>
        <span class="n">_R</span> <span class="o">=</span> <span class="n">dot</span><span class="p">(</span><span class="n">X</span><span class="p">,</span><span class="n">Lam_H</span><span class="o">.</span><span class="n">T</span><span class="p">)</span><span class="o">/</span><span class="n">rho</span> <span class="o">-</span> <span class="n">Lam_P</span><span class="o">.</span><span class="n">T</span><span class="o">/</span><span class="n">rho</span> <span class="o">+</span> <span class="n">dot</span><span class="p">(</span><span class="n">X</span><span class="p">,</span><span class="n">H</span><span class="o">.</span><span class="n">T</span><span class="p">)</span> <span class="o">+</span> <span class="n">Ptil</span><span class="o">.</span><span class="n">T</span>
        <span class="n">P</span> <span class="o">=</span> <span class="p">(</span><span class="n">_R</span> <span class="o">-</span> <span class="n">X</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span> <span class="n">dot</span><span class="p">(</span><span class="n">K</span><span class="p">,</span><span class="n">_R</span><span class="p">)</span> <span class="p">))</span><span class="o">.</span><span class="n">T</span>
        <span class="n">Ptil</span> <span class="o">=</span> <span class="p">(</span><span class="n">P</span><span class="o">+</span><span class="n">Lam_P</span><span class="o">/</span><span class="n">rho</span><span class="p">)</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>

        <span class="c1"># (W,H) updates</span>
        <span class="n">H</span> <span class="o">=</span> <span class="n">solve</span><span class="p">(</span><span class="n">dot</span><span class="p">(</span><span class="n">W</span><span class="o">.</span><span class="n">T</span><span class="p">,</span><span class="n">W</span><span class="p">)</span><span class="o">+</span><span class="n">rho</span><span class="o">*</span><span class="n">eye_r</span> <span class="o">+</span> <span class="n">alpha</span><span class="o">*</span><span class="n">dot</span><span class="p">(</span><span class="n">A</span><span class="o">.</span><span class="n">T</span><span class="p">,</span><span class="n">A</span><span class="p">),</span>
                  <span class="n">dot</span><span class="p">(</span><span class="n">W</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">X</span><span class="p">)</span> <span class="o">+</span> <span class="n">rho</span><span class="o">*</span><span class="n">dot</span><span class="p">(</span><span class="n">P</span><span class="p">,</span><span class="n">X</span><span class="p">)</span> <span class="o">-</span> <span class="n">Lam_H</span> <span class="o">+</span> <span class="n">alpha</span><span class="o">*</span><span class="n">dot</span><span class="p">(</span><span class="n">A</span><span class="o">.</span><span class="n">T</span><span class="p">,</span><span class="n">Q</span><span class="p">)</span> <span class="p">)</span>
        <span class="n">A</span> <span class="o">=</span> <span class="n">solve</span><span class="p">(</span> <span class="n">H</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">H</span><span class="o">.</span><span class="n">T</span><span class="p">),</span> <span class="n">H</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">Q</span><span class="o">.</span><span class="n">T</span><span class="p">))</span><span class="o">.</span><span class="n">T</span>
        <span class="n">W</span> <span class="o">=</span> <span class="n">solve</span><span class="p">(</span><span class="n">dot</span><span class="p">(</span><span class="n">H</span><span class="p">,</span><span class="n">H</span><span class="o">.</span><span class="n">T</span><span class="p">)</span><span class="o">+</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">rho</span><span class="p">)</span><span class="o">*</span><span class="n">eye_r</span><span class="p">,</span>
                  <span class="n">dot</span><span class="p">(</span><span class="n">H</span><span class="p">,</span> <span class="n">X</span><span class="o">.</span><span class="n">T</span><span class="p">)</span> <span class="o">+</span> <span class="n">rho</span><span class="o">*</span><span class="p">(</span><span class="n">W1</span><span class="o">+</span><span class="n">W2</span><span class="p">)</span><span class="o">.</span><span class="n">T</span> <span class="o">-</span> <span class="n">Lam_W1</span><span class="o">.</span><span class="n">T</span> <span class="o">-</span> <span class="n">Lam_W2</span><span class="o">.</span><span class="n">T</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>

        <span class="c1"># projections</span>
        <span class="n">W1</span> <span class="o">=</span> <span class="p">(</span><span class="n">W</span><span class="o">+</span><span class="n">Lam_W1</span><span class="o">/</span><span class="n">rho</span><span class="p">)</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">W2</span> <span class="o">=</span> <span class="n">projection_spectral</span><span class="p">(</span><span class="n">W</span><span class="o">+</span><span class="n">Lam_W2</span><span class="o">/</span><span class="n">rho</span><span class="p">,</span><span class="n">projection_type</span><span class="o">=</span><span class="n">constraint</span><span class="p">)</span>

        <span class="c1">#====================== dual updates =================================#</span>
        <span class="n">Lam_W1</span> <span class="o">=</span> <span class="n">Lam_W1</span> <span class="o">+</span> <span class="n">rho</span><span class="o">*</span><span class="p">(</span><span class="n">W</span> <span class="o">-</span> <span class="n">W1</span><span class="p">)</span>
        <span class="n">Lam_W2</span> <span class="o">=</span> <span class="n">Lam_W2</span> <span class="o">+</span> <span class="n">rho</span><span class="o">*</span><span class="p">(</span><span class="n">W</span> <span class="o">-</span> <span class="n">W2</span><span class="p">)</span>
        <span class="n">Lam_P</span> <span class="o">=</span> <span class="n">Lam_P</span> <span class="o">+</span> <span class="n">rho</span><span class="o">*</span><span class="p">(</span><span class="n">P</span> <span class="o">-</span> <span class="n">Ptil</span><span class="p">)</span>
        <span class="n">Lam_H</span> <span class="o">=</span> <span class="n">Lam_H</span> <span class="o">+</span> <span class="n">rho</span><span class="o">*</span><span class="p">(</span><span class="n">H</span> <span class="o">-</span> <span class="n">dot</span><span class="p">(</span><span class="n">P</span><span class="p">,</span><span class="n">X</span><span class="p">))</span>

        <span class="c1">#============ comptute objective values ==============================#</span>
        <span class="c1"># main loss function</span>
        <span class="n">cost_nmf</span> <span class="o">=</span> <span class="n">norm</span><span class="p">(</span><span class="n">W1</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">Ptil</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">X</span><span class="p">))</span> <span class="o">-</span> <span class="n">X</span><span class="p">,</span><span class="s1">&#39;fro&#39;</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="o">/</span><span class="mi">2</span>
        <span class="n">cost_LC</span> <span class="o">=</span> <span class="n">alpha</span><span class="o">*</span><span class="n">norm</span><span class="p">(</span> <span class="n">Q</span> <span class="o">-</span> <span class="n">A</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">H</span><span class="p">),</span> <span class="s1">&#39;fro&#39;</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="o">/</span><span class="mi">2</span>
        <span class="n">cost</span> <span class="o">=</span> <span class="n">cost_nmf</span> <span class="o">+</span> <span class="n">cost_LC</span>

        <span class="n">cost_nmf_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">cost_nmf</span><span class="p">)</span>
        <span class="n">cost_LC_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">cost_LC</span><span class="p">)</span>
        <span class="n">cost_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">cost</span><span class="p">)</span>

        <span class="c1"># relative change in cost</span>
        <span class="n">diffcost</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">cost_list</span><span class="p">[</span><span class="nb">iter</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">cost_list</span><span class="p">[</span><span class="nb">iter</span><span class="p">])</span><span class="o">/</span><span class="n">cost_list</span><span class="p">[</span><span class="nb">iter</span><span class="p">])</span>

        <span class="c1"># relative primal residuals</span>
        <span class="n">res_W1</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">norm</span><span class="p">(</span><span class="n">W</span><span class="o">-</span><span class="n">W1</span><span class="p">,</span><span class="s1">&#39;fro&#39;</span><span class="p">)</span><span class="o">/</span><span class="n">norm</span><span class="p">(</span><span class="n">W</span><span class="p">,</span><span class="s1">&#39;fro&#39;</span><span class="p">))</span>
        <span class="n">res_W2</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">norm</span><span class="p">(</span><span class="n">W</span><span class="o">-</span><span class="n">W2</span><span class="p">,</span><span class="s1">&#39;fro&#39;</span><span class="p">)</span><span class="o">/</span><span class="n">norm</span><span class="p">(</span><span class="n">W</span><span class="p">,</span><span class="s1">&#39;fro&#39;</span><span class="p">))</span>
        <span class="n">res_P</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">norm</span><span class="p">(</span><span class="n">P</span><span class="o">-</span><span class="n">Ptil</span><span class="p">,</span><span class="s1">&#39;fro&#39;</span><span class="p">)</span><span class="o">/</span><span class="n">norm</span><span class="p">(</span><span class="n">P</span><span class="p">,</span><span class="s1">&#39;fro&#39;</span><span class="p">))</span>
        <span class="n">res_H</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">norm</span><span class="p">(</span><span class="n">H</span><span class="o">-</span><span class="n">P</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">X</span><span class="p">),</span><span class="s1">&#39;fro&#39;</span><span class="p">)</span><span class="o">/</span><span class="n">norm</span><span class="p">(</span><span class="n">H</span><span class="p">,</span><span class="s1">&#39;fro&#39;</span><span class="p">))</span>

        <span class="c1"># relative change in basis matrix</span>
<span class="c1">#        diffW.append( norm(W-W_old,&#39;fro&#39;)/ norm(W_old, &#39;fro&#39;) )</span>

        <span class="c1">#=== termination check =============#</span>
        <span class="n">check_exit</span> <span class="o">=</span>  <span class="p">(</span><span class="n">diffcost</span><span class="p">[</span><span class="nb">iter</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">tol</span><span class="p">)</span>
        <span class="n">check_exit</span> <span class="o">&amp;=</span> <span class="p">(</span>  <span class="n">res_W1</span><span class="p">[</span><span class="nb">iter</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">tol</span><span class="p">)</span>
        <span class="n">check_exit</span> <span class="o">&amp;=</span> <span class="p">(</span>  <span class="n">res_W2</span><span class="p">[</span><span class="nb">iter</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">tol</span><span class="p">)</span>
        <span class="n">check_exit</span> <span class="o">&amp;=</span> <span class="p">(</span>   <span class="n">res_P</span><span class="p">[</span><span class="nb">iter</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">tol</span><span class="p">)</span>
        <span class="n">check_exit</span> <span class="o">&amp;=</span> <span class="p">(</span>   <span class="n">res_H</span><span class="p">[</span><span class="nb">iter</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">tol</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">check_exit</span> <span class="ow">and</span> <span class="nb">iter</span> <span class="o">&gt;</span> <span class="mi">300</span><span class="p">:</span> <span class="c1"># allow 300 iterations of &quot;burn-in&quot;</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">silence</span><span class="p">:</span>
                <span class="k">print</span> <span class="s2">&quot;Termination condition met.  Exit at iter =&quot;</span><span class="p">,</span><span class="nb">iter</span><span class="p">,</span>
            <span class="k">break</span>
        <span class="c1">#=============== print current progress ==============================#</span>
<span class="c1">#        if iter % disp_freq == 0:</span>
        <span class="k">if</span> <span class="p">(</span><span class="nb">iter</span><span class="o">&gt;</span><span class="mi">1</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="nb">iter</span> <span class="o">%</span> <span class="n">disp_freq</span> <span class="o">==</span> <span class="mi">0</span><span class="p">):</span>
            <span class="n">str_</span> <span class="o">=</span> <span class="s2">&quot;iter={:4} cost={:6.5e}&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">iter</span><span class="p">,</span><span class="n">cost</span><span class="p">)</span>
            <span class="n">str_</span> <span class="o">+=</span> <span class="s2">&quot; nmf={:.2e}&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">cost_nmf</span><span class="p">)</span>
            <span class="n">str_</span> <span class="o">+=</span> <span class="s2">&quot; LC={:.2e}&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">cost_LC</span><span class="p">)</span>
            <span class="n">str_</span> <span class="o">+=</span> <span class="s2">&quot; diffcost={:3.2e}&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">diffcost</span><span class="p">[</span><span class="nb">iter</span><span class="p">])</span>
            <span class="n">str_</span> <span class="o">+=</span> <span class="s2">&quot; W1={:3.2e}&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">res_W1</span><span class="p">[</span><span class="nb">iter</span><span class="p">])</span>
            <span class="n">str_</span> <span class="o">+=</span> <span class="s2">&quot; W2={:3.2e}&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">res_W2</span><span class="p">[</span><span class="nb">iter</span><span class="p">])</span>
            <span class="n">str_</span> <span class="o">+=</span> <span class="s2">&quot; P={:3.2e}&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">res_P</span><span class="p">[</span><span class="nb">iter</span><span class="p">])</span>
            <span class="n">str_</span> <span class="o">+=</span> <span class="s2">&quot; H={:3.2e}&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">res_H</span><span class="p">[</span><span class="nb">iter</span><span class="p">])</span>
<span class="c1">#            str_ += &quot; diffW={:3.2e}&quot;.format(diffW[iter])</span>
            <span class="k">print</span> <span class="n">str_</span> <span class="o">+</span> <span class="s2">&quot; ({:3.1f} sec)&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span><span class="o">-</span><span class="n">start</span><span class="p">)</span>
    <span class="c1">#%%---- end of admm for loop ---------------------------------------------#</span>
<span class="c1">#    cost_list = np.array(cost_list)</span>

    <span class="c1"># convert residual in pandas dataframe</span>
    <span class="n">cost</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">([</span><span class="n">cost_list</span><span class="p">,</span> <span class="n">cost_nmf_list</span><span class="p">,</span> <span class="n">cost_LC_list</span><span class="p">],</span>
                        <span class="n">index</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;total&#39;</span><span class="p">,</span><span class="s1">&#39;nmf&#39;</span><span class="p">,</span><span class="s1">&#39;LC&#39;</span><span class="p">])</span><span class="o">.</span><span class="n">T</span>
    <span class="n">res</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">([</span><span class="n">res_W1</span><span class="p">,</span><span class="n">res_W2</span><span class="p">,</span><span class="n">res_P</span><span class="p">,</span><span class="n">res_H</span><span class="p">,</span><span class="n">diffcost</span><span class="p">],</span>
                       <span class="n">index</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;res_W1&#39;</span><span class="p">,</span><span class="s1">&#39;res_W2&#39;</span><span class="p">,</span><span class="s1">&#39;res_P&#39;</span><span class="p">,</span><span class="s1">&#39;res_H&#39;</span><span class="p">,</span><span class="s1">&#39;diffcost&#39;</span><span class="p">])</span><span class="o">.</span><span class="n">T</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">silence</span><span class="p">:</span> <span class="n">print_time</span><span class="p">(</span><span class="n">start</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">W</span><span class="p">,</span><span class="n">P</span><span class="p">,</span><span class="n">H</span><span class="p">,</span><span class="n">W1</span><span class="p">,</span><span class="n">Ptil</span><span class="p">,</span><span class="n">A</span><span class="p">,</span><span class="n">cost</span><span class="p">,</span><span class="n">res</span>





<span class="k">def</span> <span class="nf">lslc_spnmf_admm</span><span class="p">(</span><span class="n">X</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">r</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span><span class="n">alpha</span><span class="o">=</span><span class="mf">1e-1</span><span class="p">,</span><span class="n">gam</span><span class="o">=</span><span class="mf">1e-1</span><span class="p">,</span><span class="n">constraint</span><span class="o">=</span><span class="s1">&#39;stiefel&#39;</span><span class="p">,</span><span class="n">rho</span><span class="o">=</span><span class="mf">1e3</span><span class="p">,</span>
                    <span class="n">max_iter</span><span class="o">=</span><span class="mi">5000</span><span class="p">,</span>
                  <span class="n">tol</span><span class="o">=</span><span class="mf">1e-4</span><span class="p">,</span><span class="n">W_init</span><span class="o">=</span><span class="s1">&#39;nndsvd&#39;</span><span class="p">,</span><span class="n">disp_freq</span><span class="o">=</span><span class="mi">1000</span><span class="p">,</span><span class="n">silence</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Least-squares Label constrained Spectral Projective NMF using ADMM.</span>

<span class="sd">    **LC** Idea from 2011 Z. Jiang (CVPR) - Learning a discriminative</span>
<span class="sd">    dictionary for sparse coding via label constrained k-svd</span>

<span class="sd">    Usage</span>
<span class="sd">    -----</span>
<span class="sd">    &gt;&gt;&gt; W,P,H,Wtil,Ptil,A,w,cost,res = lslc_spnmf_admm(....)</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    X : ndarray of shape (n_features, n_samples)=(p,n)</span>
<span class="sd">        Data matrix with columns as data points</span>
<span class="sd">    y : array-like of shape [n_samples,]</span>
<span class="sd">        Label vector</span>
<span class="sd">    r : int (must be even for this LC-approach)</span>
<span class="sd">        Dimension of the embedding space (n_components)</span>
<span class="sd">    alpha : float</span>
<span class="sd">        Regularization for discriminative code</span>
<span class="sd">    gam : float</span>
<span class="sd">        Regularization on the least-squares fit</span>
<span class="sd">    constraint : ``&#39;stiefel&#39;`` or ``&#39;convex&#39;``</span>
<span class="sd">        The type of spectral constraint (default: ``&#39;stiefel&#39;``).  This</span>
<span class="sd">        determines the type of spectral projection applied.</span>
<span class="sd">    rho : float</span>
<span class="sd">        Augmented Lagrangian parameter</span>
<span class="sd">    max_iter : int</span>
<span class="sd">        max number of iterations</span>
<span class="sd">    tol : float</span>
<span class="sd">        convergence tolerance (on relative change in objective value and</span>
<span class="sd">        all primal residuals)</span>
<span class="sd">    W_init : None, rng, or &#39;nndsvd&#39;</span>
<span class="sd">        Way to initialize W (and H).  If ``None`` or ``RandomState object``</span>
<span class="sd">        is supplied, both W and H will be initialized via non-negative</span>
<span class="sd">        random number.  If ``&#39;nndsvd&#39;``, will use deterministic initialization</span>
<span class="sd">        NNDSVD &quot;Non-Negative Double Singular Value Decomposition&quot;, proposed by</span>
<span class="sd">        Boutsidis2008.</span>
<span class="sd">    disp_freq : int</span>
<span class="sd">        Frequency of update display (in iterations)</span>
<span class="sd">    silence : bool</span>
<span class="sd">        If True, don&#39;t print-out convergence detail at the end.</span>

<span class="sd">    History</span>
<span class="sd">    --------------</span>
<span class="sd">    **02/08/2016** - function created (forked from ``lc_spnmf_admm``)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">p</span><span class="p">,</span><span class="n">n</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">shape</span>
    <span class="n">alpha</span> <span class="o">*=</span> <span class="mf">1.0</span>
    <span class="n">rho</span> <span class="o">*=</span> <span class="mf">1.0</span>
    <span class="k">if</span> <span class="n">r</span><span class="o">%</span><span class="mi">2</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;r must be an even integer&quot;</span><span class="p">)</span>
    <span class="c1">#%%=== initialize variables =====</span>
    <span class="k">if</span> <span class="n">W_init</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
        <span class="n">W</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="n">p</span><span class="p">,</span><span class="n">r</span><span class="p">)</span>
        <span class="n">W</span> <span class="o">/=</span> <span class="n">norm</span><span class="p">(</span><span class="n">W</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>

        <span class="n">H</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="n">r</span><span class="p">,</span><span class="n">n</span><span class="p">)</span>
        <span class="n">H</span> <span class="o">/=</span> <span class="n">norm</span><span class="p">(</span><span class="n">H</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">W_init</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">RandomState</span><span class="p">):</span>
        <span class="n">rng</span> <span class="o">=</span> <span class="n">W_init</span>

        <span class="n">W</span> <span class="o">=</span> <span class="n">rng</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="n">p</span><span class="p">,</span><span class="n">r</span><span class="p">)</span>
        <span class="n">W</span> <span class="o">/=</span> <span class="n">norm</span><span class="p">(</span><span class="n">W</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>

        <span class="n">H</span> <span class="o">=</span> <span class="n">rng</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="n">r</span><span class="p">,</span><span class="n">n</span><span class="p">)</span>
        <span class="n">H</span> <span class="o">/=</span> <span class="n">norm</span><span class="p">(</span><span class="n">H</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">W_init</span> <span class="o">==</span> <span class="s1">&#39;nndsvd&#39;</span><span class="p">:</span>
<span class="c1">#        W = nnd_svd(X,r)</span>
        <span class="n">W</span><span class="p">,</span><span class="n">H</span> <span class="o">=</span> <span class="n">nnd_svd</span><span class="p">(</span><span class="n">X</span><span class="p">,</span><span class="n">r</span><span class="p">,</span><span class="n">get_H</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Invalid input for &quot;W_init&quot;&#39;</span><span class="p">)</span>

    <span class="n">P</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">r</span><span class="p">,</span><span class="n">p</span><span class="p">))</span>
<span class="c1">#    P = np.random.rand(r,p)</span>

    <span class="c1"># aux. variables</span>
    <span class="n">W1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">W</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
    <span class="n">W2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">W</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
    <span class="n">Ptil</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">P</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>

    <span class="c1"># dual variables</span>
    <span class="n">Lam_W1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">W</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
    <span class="n">Lam_W2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">W</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
    <span class="n">Lam_P</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">P</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
    <span class="n">Lam_H</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">H</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>

    <span class="c1">#--- variables for LC approach ---#</span>
    <span class="c1"># linear transformation matrix that parametrizes LC</span>
    <span class="n">A</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">r</span><span class="p">,</span><span class="n">r</span><span class="p">))</span>

    <span class="c1"># get discriminative codes</span>
    <span class="n">Q</span> <span class="o">=</span> <span class="n">get_discriminative_codes</span><span class="p">(</span><span class="n">y</span><span class="p">,</span><span class="n">r</span><span class="p">)</span>

    <span class="c1"># classifier</span>
    <span class="n">w</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">r</span><span class="p">)</span>
    <span class="c1">#%%=== create empty lists for tracking updates ===</span>
    <span class="c1"># keep track of frobenius norm loss</span>
    <span class="n">cost_list</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">cost_nmf_list</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">cost_LC_list</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">cost_ls_list</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="n">PX</span> <span class="o">=</span> <span class="n">Ptil</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>
    <span class="n">cost_nmf</span> <span class="o">=</span> <span class="n">norm</span><span class="p">(</span><span class="n">W1</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">PX</span><span class="p">)</span> <span class="o">-</span> <span class="n">X</span><span class="p">,</span><span class="s1">&#39;fro&#39;</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="o">/</span><span class="mi">2</span>
    <span class="n">cost_LC</span> <span class="o">=</span> <span class="n">alpha</span><span class="o">*</span><span class="n">norm</span><span class="p">(</span> <span class="n">Q</span> <span class="o">-</span> <span class="n">A</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">H</span><span class="p">),</span> <span class="s1">&#39;fro&#39;</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="o">/</span><span class="mi">2</span>
    <span class="n">cost_ls</span>  <span class="o">=</span> <span class="n">gam</span><span class="o">*</span><span class="n">norm</span><span class="p">(</span><span class="n">y</span> <span class="o">-</span> <span class="n">PX</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">w</span><span class="p">))</span> <span class="o">**</span><span class="mi">2</span><span class="o">/</span><span class="mi">2</span>
    <span class="n">cost</span> <span class="o">=</span> <span class="n">cost_nmf</span> <span class="o">+</span> <span class="n">cost_LC</span> <span class="o">+</span> <span class="n">cost_ls</span>

    <span class="n">cost_nmf_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">cost_nmf</span><span class="p">)</span>
    <span class="n">cost_LC_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">cost_LC</span><span class="p">)</span>
    <span class="n">cost_ls_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">cost_ls</span><span class="p">)</span>
    <span class="n">cost_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">cost</span><span class="p">)</span>

    <span class="c1"># relative change in cost</span>
    <span class="n">diffcost</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="c1"># keep track of relative primal residual</span>
    <span class="n">res_W1</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">res_W2</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">res_P</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">res_H</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="c1"># also keep track of diffW</span>
<span class="c1">#    diffW = []</span>
    <span class="c1">#%%=== run admm iterations ===</span>
    <span class="n">eye_r</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="n">r</span><span class="p">)</span>

    <span class="c1"># precompute term needed for inversion lemma</span>
    <span class="n">K</span> <span class="o">=</span> <span class="n">solve</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="o">+</span> <span class="n">dot</span><span class="p">(</span><span class="n">X</span><span class="o">.</span><span class="n">T</span><span class="p">,</span><span class="n">X</span><span class="p">),</span> <span class="n">X</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>



    <span class="n">start</span><span class="o">=</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
    <span class="k">for</span> <span class="nb">iter</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">max_iter</span><span class="p">):</span>
<span class="c1">#        W_old = W #&lt;- to keep track of diffW</span>

        <span class="c1">#================ primal updates (P, W, H, Ptil, Wtil) ===============#</span>
        <span class="c1"># update for P involves inversion lemma...</span>
        <span class="n">_R</span> <span class="o">=</span> <span class="n">dot</span><span class="p">(</span><span class="n">X</span><span class="p">,</span><span class="n">Lam_H</span><span class="o">.</span><span class="n">T</span><span class="p">)</span><span class="o">/</span><span class="n">rho</span> <span class="o">-</span> <span class="n">Lam_P</span><span class="o">.</span><span class="n">T</span><span class="o">/</span><span class="n">rho</span> <span class="o">+</span> <span class="n">dot</span><span class="p">(</span><span class="n">X</span><span class="p">,</span><span class="n">H</span><span class="o">.</span><span class="n">T</span><span class="p">)</span> <span class="o">+</span> <span class="n">Ptil</span><span class="o">.</span><span class="n">T</span>
        <span class="n">P</span> <span class="o">=</span> <span class="p">(</span><span class="n">_R</span> <span class="o">-</span> <span class="n">X</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span> <span class="n">dot</span><span class="p">(</span><span class="n">K</span><span class="p">,</span><span class="n">_R</span><span class="p">)</span> <span class="p">))</span><span class="o">.</span><span class="n">T</span>
        <span class="n">Ptil</span> <span class="o">=</span> <span class="p">(</span><span class="n">P</span><span class="o">+</span><span class="n">Lam_P</span><span class="o">/</span><span class="n">rho</span><span class="p">)</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>

        <span class="c1"># (W,H) updates</span>
        <span class="n">H</span> <span class="o">=</span> <span class="n">solve</span><span class="p">(</span><span class="n">dot</span><span class="p">(</span><span class="n">W</span><span class="o">.</span><span class="n">T</span><span class="p">,</span><span class="n">W</span><span class="p">)</span><span class="o">+</span><span class="n">rho</span><span class="o">*</span><span class="n">eye_r</span> <span class="o">+</span> <span class="n">alpha</span><span class="o">*</span><span class="n">dot</span><span class="p">(</span><span class="n">A</span><span class="o">.</span><span class="n">T</span><span class="p">,</span><span class="n">A</span><span class="p">),</span>
                  <span class="n">dot</span><span class="p">(</span><span class="n">W</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">X</span><span class="p">)</span> <span class="o">+</span> <span class="n">rho</span><span class="o">*</span><span class="n">dot</span><span class="p">(</span><span class="n">P</span><span class="p">,</span><span class="n">X</span><span class="p">)</span> <span class="o">-</span> <span class="n">Lam_H</span> <span class="o">+</span> <span class="n">alpha</span><span class="o">*</span><span class="n">dot</span><span class="p">(</span><span class="n">A</span><span class="o">.</span><span class="n">T</span><span class="p">,</span><span class="n">Q</span><span class="p">)</span> <span class="p">)</span>
        <span class="n">A</span> <span class="o">=</span> <span class="n">solve</span><span class="p">(</span> <span class="n">H</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">H</span><span class="o">.</span><span class="n">T</span><span class="p">),</span> <span class="n">H</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">Q</span><span class="o">.</span><span class="n">T</span><span class="p">))</span><span class="o">.</span><span class="n">T</span>
        <span class="n">w</span> <span class="o">=</span> <span class="n">solve</span><span class="p">(</span> <span class="n">H</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">H</span><span class="o">.</span><span class="n">T</span><span class="p">),</span> <span class="n">H</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">y</span><span class="p">))</span>
        <span class="n">W</span> <span class="o">=</span> <span class="n">solve</span><span class="p">(</span><span class="n">dot</span><span class="p">(</span><span class="n">H</span><span class="p">,</span><span class="n">H</span><span class="o">.</span><span class="n">T</span><span class="p">)</span><span class="o">+</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">rho</span><span class="p">)</span><span class="o">*</span><span class="n">eye_r</span><span class="p">,</span>
                  <span class="n">dot</span><span class="p">(</span><span class="n">H</span><span class="p">,</span> <span class="n">X</span><span class="o">.</span><span class="n">T</span><span class="p">)</span> <span class="o">+</span> <span class="n">rho</span><span class="o">*</span><span class="p">(</span><span class="n">W1</span><span class="o">+</span><span class="n">W2</span><span class="p">)</span><span class="o">.</span><span class="n">T</span> <span class="o">-</span> <span class="n">Lam_W1</span><span class="o">.</span><span class="n">T</span> <span class="o">-</span> <span class="n">Lam_W2</span><span class="o">.</span><span class="n">T</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>

        <span class="c1"># projections</span>
        <span class="n">W1</span> <span class="o">=</span> <span class="p">(</span><span class="n">W</span><span class="o">+</span><span class="n">Lam_W1</span><span class="o">/</span><span class="n">rho</span><span class="p">)</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">W2</span> <span class="o">=</span> <span class="n">projection_spectral</span><span class="p">(</span><span class="n">W</span><span class="o">+</span><span class="n">Lam_W2</span><span class="o">/</span><span class="n">rho</span><span class="p">,</span><span class="n">projection_type</span><span class="o">=</span><span class="n">constraint</span><span class="p">)</span>

        <span class="c1">#====================== dual updates =================================#</span>
        <span class="n">Lam_W1</span> <span class="o">=</span> <span class="n">Lam_W1</span> <span class="o">+</span> <span class="n">rho</span><span class="o">*</span><span class="p">(</span><span class="n">W</span> <span class="o">-</span> <span class="n">W1</span><span class="p">)</span>
        <span class="n">Lam_W2</span> <span class="o">=</span> <span class="n">Lam_W2</span> <span class="o">+</span> <span class="n">rho</span><span class="o">*</span><span class="p">(</span><span class="n">W</span> <span class="o">-</span> <span class="n">W2</span><span class="p">)</span>
        <span class="n">Lam_P</span> <span class="o">=</span> <span class="n">Lam_P</span> <span class="o">+</span> <span class="n">rho</span><span class="o">*</span><span class="p">(</span><span class="n">P</span> <span class="o">-</span> <span class="n">Ptil</span><span class="p">)</span>
        <span class="n">Lam_H</span> <span class="o">=</span> <span class="n">Lam_H</span> <span class="o">+</span> <span class="n">rho</span><span class="o">*</span><span class="p">(</span><span class="n">H</span> <span class="o">-</span> <span class="n">dot</span><span class="p">(</span><span class="n">P</span><span class="p">,</span><span class="n">X</span><span class="p">))</span>

        <span class="c1">#============ comptute objective values ==============================#</span>
        <span class="c1"># main loss function</span>
        <span class="n">PX</span> <span class="o">=</span> <span class="n">Ptil</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>
        <span class="n">cost_nmf</span> <span class="o">=</span> <span class="n">norm</span><span class="p">(</span><span class="n">W1</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">PX</span><span class="p">)</span> <span class="o">-</span> <span class="n">X</span><span class="p">,</span><span class="s1">&#39;fro&#39;</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="o">/</span><span class="mi">2</span>
        <span class="n">cost_LC</span> <span class="o">=</span> <span class="n">alpha</span><span class="o">*</span><span class="n">norm</span><span class="p">(</span> <span class="n">Q</span> <span class="o">-</span> <span class="n">A</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">H</span><span class="p">),</span> <span class="s1">&#39;fro&#39;</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="o">/</span><span class="mi">2</span>
        <span class="n">cost_ls</span>  <span class="o">=</span> <span class="n">gam</span><span class="o">*</span><span class="n">norm</span><span class="p">(</span><span class="n">y</span> <span class="o">-</span> <span class="n">PX</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">w</span><span class="p">))</span> <span class="o">**</span><span class="mi">2</span><span class="o">/</span><span class="mi">2</span>
        <span class="n">cost</span> <span class="o">=</span> <span class="n">cost_nmf</span> <span class="o">+</span> <span class="n">cost_LC</span> <span class="o">+</span> <span class="n">cost_ls</span>

        <span class="n">cost_nmf_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">cost_nmf</span><span class="p">)</span>
        <span class="n">cost_LC_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">cost_LC</span><span class="p">)</span>
        <span class="n">cost_ls_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">cost_ls</span><span class="p">)</span>
        <span class="n">cost_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">cost</span><span class="p">)</span>

        <span class="c1"># relative change in cost</span>
        <span class="n">diffcost</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">cost_list</span><span class="p">[</span><span class="nb">iter</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">cost_list</span><span class="p">[</span><span class="nb">iter</span><span class="p">])</span><span class="o">/</span><span class="n">cost_list</span><span class="p">[</span><span class="nb">iter</span><span class="p">])</span>

        <span class="c1"># relative primal residuals</span>
        <span class="n">res_W1</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">norm</span><span class="p">(</span><span class="n">W</span><span class="o">-</span><span class="n">W1</span><span class="p">,</span><span class="s1">&#39;fro&#39;</span><span class="p">)</span><span class="o">/</span><span class="n">norm</span><span class="p">(</span><span class="n">W</span><span class="p">,</span><span class="s1">&#39;fro&#39;</span><span class="p">))</span>
        <span class="n">res_W2</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">norm</span><span class="p">(</span><span class="n">W</span><span class="o">-</span><span class="n">W2</span><span class="p">,</span><span class="s1">&#39;fro&#39;</span><span class="p">)</span><span class="o">/</span><span class="n">norm</span><span class="p">(</span><span class="n">W</span><span class="p">,</span><span class="s1">&#39;fro&#39;</span><span class="p">))</span>
        <span class="n">res_P</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">norm</span><span class="p">(</span><span class="n">P</span><span class="o">-</span><span class="n">Ptil</span><span class="p">,</span><span class="s1">&#39;fro&#39;</span><span class="p">)</span><span class="o">/</span><span class="n">norm</span><span class="p">(</span><span class="n">P</span><span class="p">,</span><span class="s1">&#39;fro&#39;</span><span class="p">))</span>
        <span class="n">res_H</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">norm</span><span class="p">(</span><span class="n">H</span><span class="o">-</span><span class="n">P</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">X</span><span class="p">),</span><span class="s1">&#39;fro&#39;</span><span class="p">)</span><span class="o">/</span><span class="n">norm</span><span class="p">(</span><span class="n">H</span><span class="p">,</span><span class="s1">&#39;fro&#39;</span><span class="p">))</span>

        <span class="c1"># relative change in basis matrix</span>
<span class="c1">#        diffW.append( norm(W-W_old,&#39;fro&#39;)/ norm(W_old, &#39;fro&#39;) )</span>

        <span class="c1">#=== termination check =============#</span>
        <span class="n">check_exit</span> <span class="o">=</span>  <span class="p">(</span><span class="n">diffcost</span><span class="p">[</span><span class="nb">iter</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">tol</span><span class="p">)</span>
        <span class="n">check_exit</span> <span class="o">&amp;=</span> <span class="p">(</span>  <span class="n">res_W1</span><span class="p">[</span><span class="nb">iter</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">tol</span><span class="p">)</span>
        <span class="n">check_exit</span> <span class="o">&amp;=</span> <span class="p">(</span>  <span class="n">res_W2</span><span class="p">[</span><span class="nb">iter</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">tol</span><span class="p">)</span>
        <span class="n">check_exit</span> <span class="o">&amp;=</span> <span class="p">(</span>   <span class="n">res_P</span><span class="p">[</span><span class="nb">iter</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">tol</span><span class="p">)</span>
        <span class="n">check_exit</span> <span class="o">&amp;=</span> <span class="p">(</span>   <span class="n">res_H</span><span class="p">[</span><span class="nb">iter</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">tol</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">check_exit</span> <span class="ow">and</span> <span class="nb">iter</span> <span class="o">&gt;</span> <span class="mi">300</span><span class="p">:</span> <span class="c1"># allow 300 iterations of &quot;burn-in&quot;</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">silence</span><span class="p">:</span>
                <span class="k">print</span> <span class="s2">&quot;Termination condition met.  Exit at iter =&quot;</span><span class="p">,</span><span class="nb">iter</span><span class="p">,</span>
            <span class="k">break</span>
        <span class="c1">#=============== print current progress ==============================#</span>
<span class="c1">#        if iter % disp_freq == 0:</span>
        <span class="k">if</span> <span class="p">(</span><span class="nb">iter</span><span class="o">&gt;</span><span class="mi">1</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="nb">iter</span> <span class="o">%</span> <span class="n">disp_freq</span> <span class="o">==</span> <span class="mi">0</span><span class="p">):</span>
            <span class="n">str_</span> <span class="o">=</span> <span class="s2">&quot;iter={:4} cost={:6.5e}&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">iter</span><span class="p">,</span><span class="n">cost</span><span class="p">)</span>
            <span class="n">str_</span> <span class="o">+=</span> <span class="s2">&quot; nmf={:.2e}&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">cost_nmf</span><span class="p">)</span>
            <span class="n">str_</span> <span class="o">+=</span> <span class="s2">&quot; LC={:.2e}&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">cost_LC</span><span class="p">)</span>
            <span class="n">str_</span> <span class="o">+=</span> <span class="s2">&quot; LS={:.2e}&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">cost_ls</span><span class="p">)</span>
            <span class="n">str_</span> <span class="o">+=</span> <span class="s2">&quot; diffcost={:3.2e}&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">diffcost</span><span class="p">[</span><span class="nb">iter</span><span class="p">])</span>
            <span class="n">str_</span> <span class="o">+=</span> <span class="s2">&quot; W1={:3.2e}&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">res_W1</span><span class="p">[</span><span class="nb">iter</span><span class="p">])</span>
            <span class="n">str_</span> <span class="o">+=</span> <span class="s2">&quot; W2={:3.2e}&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">res_W2</span><span class="p">[</span><span class="nb">iter</span><span class="p">])</span>
            <span class="n">str_</span> <span class="o">+=</span> <span class="s2">&quot; P={:3.2e}&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">res_P</span><span class="p">[</span><span class="nb">iter</span><span class="p">])</span>
            <span class="n">str_</span> <span class="o">+=</span> <span class="s2">&quot; H={:3.2e}&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">res_H</span><span class="p">[</span><span class="nb">iter</span><span class="p">])</span>
<span class="c1">#            str_ += &quot; diffW={:3.2e}&quot;.format(diffW[iter])</span>
            <span class="k">print</span> <span class="n">str_</span> <span class="o">+</span> <span class="s2">&quot; ({:3.1f} sec)&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span><span class="o">-</span><span class="n">start</span><span class="p">)</span>
    <span class="c1">#%%---- end of admm for loop ---------------------------------------------#</span>
<span class="c1">#    cost_list = np.array(cost_list)</span>

    <span class="c1"># convert residual in pandas dataframe</span>
    <span class="n">cost</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">([</span><span class="n">cost_list</span><span class="p">,</span> <span class="n">cost_nmf_list</span><span class="p">,</span> <span class="n">cost_LC_list</span><span class="p">,</span><span class="n">cost_ls_list</span><span class="p">],</span>
                        <span class="n">index</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;total&#39;</span><span class="p">,</span><span class="s1">&#39;nmf&#39;</span><span class="p">,</span><span class="s1">&#39;LC&#39;</span><span class="p">,</span><span class="s1">&#39;cost_ls&#39;</span><span class="p">])</span><span class="o">.</span><span class="n">T</span>
    <span class="n">res</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">([</span><span class="n">res_W1</span><span class="p">,</span><span class="n">res_W2</span><span class="p">,</span><span class="n">res_P</span><span class="p">,</span><span class="n">res_H</span><span class="p">,</span><span class="n">diffcost</span><span class="p">],</span>
                       <span class="n">index</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;res_W1&#39;</span><span class="p">,</span><span class="s1">&#39;res_W2&#39;</span><span class="p">,</span><span class="s1">&#39;res_P&#39;</span><span class="p">,</span><span class="s1">&#39;res_H&#39;</span><span class="p">,</span><span class="s1">&#39;diffcost&#39;</span><span class="p">])</span><span class="o">.</span><span class="n">T</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">silence</span><span class="p">:</span> <span class="n">print_time</span><span class="p">(</span><span class="n">start</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">W</span><span class="p">,</span><span class="n">P</span><span class="p">,</span><span class="n">H</span><span class="p">,</span><span class="n">W1</span><span class="p">,</span><span class="n">Ptil</span><span class="p">,</span><span class="n">A</span><span class="p">,</span><span class="n">w</span><span class="p">,</span><span class="n">cost</span><span class="p">,</span><span class="n">res</span>

<span class="k">class</span> <span class="nc">LC_SPNMF_ADMM</span><span class="p">(</span><span class="n">BaseEstimator</span><span class="p">,</span><span class="n">TransformerMixin</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Label constrained Spectral Projective NMF using ADMM.</span>

<span class="sd">    History</span>
<span class="sd">    --------------</span>
<span class="sd">    **02/08/2016** - function created (forked from ``spnmf_admm``)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">r</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span><span class="n">alpha</span><span class="o">=</span><span class="mf">1e-1</span><span class="p">,</span><span class="n">constraint</span><span class="o">=</span><span class="s1">&#39;stiefel&#39;</span><span class="p">,</span><span class="n">rho</span><span class="o">=</span><span class="mf">1e3</span><span class="p">,</span>
                 <span class="n">max_iter</span><span class="o">=</span><span class="mi">5000</span><span class="p">,</span><span class="n">tol</span><span class="o">=</span><span class="mf">1e-4</span><span class="p">,</span><span class="n">W_init</span><span class="o">=</span><span class="s1">&#39;nndsvd&#39;</span><span class="p">,</span>
                 <span class="n">disp_freq</span><span class="o">=</span><span class="mi">50000</span><span class="p">,</span><span class="n">silence</span><span class="o">=</span><span class="bp">True</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">r</span><span class="o">%</span><span class="mi">2</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;r must be an even integer&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">r</span> <span class="o">=</span> <span class="n">r</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">alpha</span> <span class="o">=</span> <span class="n">alpha</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">constraint</span> <span class="o">=</span> <span class="n">constraint</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">rho</span> <span class="o">=</span> <span class="n">rho</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">max_iter</span> <span class="o">=</span> <span class="n">max_iter</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tol</span> <span class="o">=</span> <span class="n">tol</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">W_init</span> <span class="o">=</span> <span class="n">W_init</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">disp_freq</span> <span class="o">=</span> <span class="n">disp_freq</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">silence</span> <span class="o">=</span> <span class="n">silence</span>

    <span class="k">def</span> <span class="nf">fit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">X</span><span class="p">,</span><span class="n">y</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;WARNING: Here, to conform with scikit&#39;s convention, X is [n,p]</span>
<span class="sd">        shaped, so need to apply transpose before inputting to function&quot;&quot;&quot;</span>
        <span class="n">W</span><span class="p">,</span><span class="n">P</span><span class="p">,</span><span class="n">H</span><span class="p">,</span><span class="n">Wtil</span><span class="p">,</span><span class="n">Ptil</span><span class="p">,</span><span class="n">A</span><span class="p">,</span><span class="n">cost</span><span class="p">,</span><span class="n">res</span> <span class="o">=</span> <span class="n">lc_spnmf_admm</span><span class="p">(</span><span class="n">X</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">r</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">r</span><span class="p">,</span>
            <span class="n">alpha</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">alpha</span><span class="p">,</span>
            <span class="n">constraint</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">constraint</span><span class="p">,</span> <span class="n">rho</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">rho</span><span class="p">,</span> <span class="n">max_iter</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">max_iter</span><span class="p">,</span>
            <span class="n">tol</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">tol</span><span class="p">,</span> <span class="n">W_init</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">W_init</span><span class="p">,</span> <span class="n">disp_freq</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">disp_freq</span><span class="p">,</span>
            <span class="n">silence</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">silence</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">W_</span> <span class="o">=</span> <span class="n">Wtil</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">P_</span> <span class="o">=</span> <span class="n">Ptil</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">H_</span> <span class="o">=</span> <span class="n">H</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">A_</span> <span class="o">=</span> <span class="n">A</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cost_</span> <span class="o">=</span> <span class="n">cost</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">resid_</span> <span class="o">=</span> <span class="n">res</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="nf">transform</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">X</span><span class="p">,</span><span class="n">y</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;WARNING: Here, to conform with scikit&#39;s convention, X is [n,p] shaped&quot;&quot;&quot;</span>
        <span class="n">check_is_fitted</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="s1">&#39;P_&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">P_</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>


<span class="k">class</span> <span class="nc">LSLC_SPNMF_ADMM</span><span class="p">(</span><span class="n">BaseEstimator</span><span class="p">,</span><span class="n">TransformerMixin</span><span class="p">,</span><span class="n">ClassifierMixin</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Least squares Label constrained Spectral Projective NMF using ADMM.</span>

<span class="sd">    History</span>
<span class="sd">    --------------</span>
<span class="sd">    **02/08/2016** - function created (forked from ``LC_SPNMF_ADMM``)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">r</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span><span class="n">alpha</span><span class="o">=</span><span class="mf">1e-1</span><span class="p">,</span><span class="n">gam</span><span class="o">=</span><span class="mf">1e-1</span><span class="p">,</span><span class="n">constraint</span><span class="o">=</span><span class="s1">&#39;stiefel&#39;</span><span class="p">,</span><span class="n">rho</span><span class="o">=</span><span class="mf">1e3</span><span class="p">,</span>
                 <span class="n">max_iter</span><span class="o">=</span><span class="mi">5000</span><span class="p">,</span><span class="n">tol</span><span class="o">=</span><span class="mf">1e-4</span><span class="p">,</span><span class="n">W_init</span><span class="o">=</span><span class="s1">&#39;nndsvd&#39;</span><span class="p">,</span>
                 <span class="n">disp_freq</span><span class="o">=</span><span class="mi">50000</span><span class="p">,</span><span class="n">silence</span><span class="o">=</span><span class="bp">True</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">r</span><span class="o">%</span><span class="mi">2</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;r must be an even integer&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">r</span> <span class="o">=</span> <span class="n">r</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">alpha</span> <span class="o">=</span> <span class="n">alpha</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">gam</span> <span class="o">=</span> <span class="n">gam</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">constraint</span> <span class="o">=</span> <span class="n">constraint</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">rho</span> <span class="o">=</span> <span class="n">rho</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">max_iter</span> <span class="o">=</span> <span class="n">max_iter</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tol</span> <span class="o">=</span> <span class="n">tol</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">W_init</span> <span class="o">=</span> <span class="n">W_init</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">disp_freq</span> <span class="o">=</span> <span class="n">disp_freq</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">silence</span> <span class="o">=</span> <span class="n">silence</span>

    <span class="k">def</span> <span class="nf">fit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">X</span><span class="p">,</span><span class="n">y</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;WARNING: Here, to conform with scikit&#39;s convention, X is [n,p]</span>
<span class="sd">        shaped, so need to apply transpose before inputting to function&quot;&quot;&quot;</span>
        <span class="n">W</span><span class="p">,</span><span class="n">P</span><span class="p">,</span><span class="n">H</span><span class="p">,</span><span class="n">Wtil</span><span class="p">,</span><span class="n">Ptil</span><span class="p">,</span><span class="n">A</span><span class="p">,</span><span class="n">w</span><span class="p">,</span><span class="n">cost</span><span class="p">,</span><span class="n">res</span> <span class="o">=</span> <span class="n">lslc_spnmf_admm</span><span class="p">(</span><span class="n">X</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">r</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">r</span><span class="p">,</span>
            <span class="n">alpha</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">alpha</span><span class="p">,</span> <span class="n">gam</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">gam</span><span class="p">,</span>
            <span class="n">constraint</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">constraint</span><span class="p">,</span> <span class="n">rho</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">rho</span><span class="p">,</span> <span class="n">max_iter</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">max_iter</span><span class="p">,</span>
            <span class="n">tol</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">tol</span><span class="p">,</span> <span class="n">W_init</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">W_init</span><span class="p">,</span> <span class="n">disp_freq</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">disp_freq</span><span class="p">,</span>
            <span class="n">silence</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">silence</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">W_</span> <span class="o">=</span> <span class="n">Wtil</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">P_</span> <span class="o">=</span> <span class="n">Ptil</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">H_</span> <span class="o">=</span> <span class="n">H</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">A_</span> <span class="o">=</span> <span class="n">A</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">w_</span> <span class="o">=</span> <span class="n">w</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cost_</span> <span class="o">=</span> <span class="n">cost</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">resid_</span> <span class="o">=</span> <span class="n">res</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="nf">transform</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">X</span><span class="p">,</span><span class="n">y</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;WARNING: Here, to conform with scikit&#39;s convention, X is [n,p] shaped&quot;&quot;&quot;</span>
        <span class="n">check_is_fitted</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="s1">&#39;P_&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">P_</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">decision_function</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">X</span><span class="p">):</span>
        <span class="n">check_is_fitted</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="s1">&#39;P_&#39;</span><span class="p">)</span>
        <span class="c1"># project data to low dimensional space</span>
        <span class="n">H</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">P_</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>

        <span class="c1"># apply classifier</span>
        <span class="n">score</span> <span class="o">=</span> <span class="n">H</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">w_</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">score</span>

    <span class="k">def</span> <span class="nf">predict</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">X</span><span class="p">):</span>
        <span class="n">check_is_fitted</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="s1">&#39;P_&#39;</span><span class="p">)</span>

        <span class="c1"># project data to low dimensional space</span>
        <span class="n">H</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">P_</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>

        <span class="c1"># apply classifier</span>
        <span class="n">score</span> <span class="o">=</span> <span class="n">H</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">w_</span><span class="p">)</span>
        <span class="n">ypr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sign</span><span class="p">(</span><span class="n">score</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">ypr</span>


<span class="k">def</span> <span class="nf">get_discriminative_codes</span><span class="p">(</span><span class="n">y</span><span class="p">,</span><span class="n">r</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Get codes for **Label-constraint**</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    y : array-like of shape [n_samples,]</span>
<span class="sd">        label vector</span>
<span class="sd">    r : int divisible by 2</span>
<span class="sd">        Embedding space. For simplicity, I&#39;m going to let the number of</span>
<span class="sd">        dimension for +1 and -1 both be the same at r/2</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    Q : array-like of shape</span>

<span class="sd">    Idea from 2011 Z. Jiang (CVPR) - Learning a discriminative dictionary</span>
<span class="sd">    for sparse coding via label constrained k-svd</span>

<span class="sd">    Created 02/08/2016</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">r</span><span class="o">%</span><span class="mi">2</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;r must be an even integer&quot;</span><span class="p">)</span>

    <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
    <span class="n">Q</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">r</span><span class="p">,</span><span class="n">n</span><span class="p">))</span>
    <span class="n">q</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">r</span><span class="p">)</span>
    <span class="n">qp</span> <span class="o">=</span> <span class="n">q</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="n">qm</span> <span class="o">=</span> <span class="n">q</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="n">qp</span><span class="p">[:</span><span class="n">r</span><span class="o">/</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="n">qm</span><span class="p">[</span><span class="n">r</span><span class="o">/</span><span class="mi">2</span><span class="p">:]</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span> <span class="nb">len</span><span class="p">(</span><span class="n">y</span><span class="p">)):</span>
        <span class="k">if</span> <span class="n">y</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">==+</span><span class="mi">1</span><span class="p">:</span>
            <span class="n">Q</span><span class="p">[:,</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">qp</span>
        <span class="k">elif</span> <span class="n">y</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">==-</span><span class="mi">1</span><span class="p">:</span>
            <span class="n">Q</span><span class="p">[:,</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">qm</span>
    <span class="k">return</span> <span class="n">Q</span>

</pre></div>

           </div>
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
      Last updated on Jan 01, 2017.

    </p>
  </div> 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'../../../',
            VERSION:'',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true
        };
    </script>
      <script type="text/javascript" src="../../../_static/jquery.js"></script>
      <script type="text/javascript" src="../../../_static/underscore.js"></script>
      <script type="text/javascript" src="../../../_static/doctools.js"></script>
      <script type="text/javascript" src="../../../_static/copybutton.js"></script>
      <script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

  

  
  
    <script type="text/javascript" src="../../../_static/js/theme.js"></script>
  

  
  
  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.StickyNav.enable();
      });
  </script>
   

</body>
</html>